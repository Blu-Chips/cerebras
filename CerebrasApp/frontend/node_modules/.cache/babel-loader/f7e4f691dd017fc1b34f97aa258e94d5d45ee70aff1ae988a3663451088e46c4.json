{"ast":null,"code":"import { getValuePercent, getPercentValue, snapValueToStep, clampValue, toFixedNumber, mod } from '@zag-js/utils';\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, key + \"\", value);\n\n// src/color-format-gradient.ts\nvar generateRGB_R = (orientation, dir, zValue) => {\n  const maskImage = \"linear-gradient(to \".concat(orientation[Number(!dir)], \", transparent, #000)\");\n  const result = {\n    areaStyles: {\n      backgroundImage: \"linear-gradient(to \".concat(orientation[Number(dir)], \",rgb(\").concat(zValue, \",0,0),rgb(\").concat(zValue, \",255,0))\")\n    },\n    areaGradientStyles: {\n      backgroundImage: \"linear-gradient(to \".concat(orientation[Number(dir)], \",rgb(\").concat(zValue, \",0,255),rgb(\").concat(zValue, \",255,255))\"),\n      WebkitMaskImage: maskImage,\n      maskImage\n    }\n  };\n  return result;\n};\nvar generateRGB_G = (orientation, dir, zValue) => {\n  const maskImage = \"linear-gradient(to \".concat(orientation[Number(!dir)], \", transparent, #000)\");\n  const result = {\n    areaStyles: {\n      backgroundImage: \"linear-gradient(to \".concat(orientation[Number(dir)], \",rgb(0,\").concat(zValue, \",0),rgb(255,\").concat(zValue, \",0))\")\n    },\n    areaGradientStyles: {\n      backgroundImage: \"linear-gradient(to \".concat(orientation[Number(dir)], \",rgb(0,\").concat(zValue, \",255),rgb(255,\").concat(zValue, \",255))\"),\n      WebkitMaskImage: maskImage,\n      maskImage\n    }\n  };\n  return result;\n};\nvar generateRGB_B = (orientation, dir, zValue) => {\n  const maskImage = \"linear-gradient(to \".concat(orientation[Number(!dir)], \", transparent, #000)\");\n  const result = {\n    areaStyles: {\n      backgroundImage: \"linear-gradient(to \".concat(orientation[Number(dir)], \",rgb(0,0,\").concat(zValue, \"),rgb(255,0,\").concat(zValue, \"))\")\n    },\n    areaGradientStyles: {\n      backgroundImage: \"linear-gradient(to \".concat(orientation[Number(dir)], \",rgb(0,255,\").concat(zValue, \"),rgb(255,255,\").concat(zValue, \"))\"),\n      WebkitMaskImage: maskImage,\n      maskImage\n    }\n  };\n  return result;\n};\nvar generateHSL_H = (orientation, dir, zValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\"linear-gradient(to \".concat(orientation[Number(dir)], \", hsla(0,0%,0%,1) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,1) 100%)\"), \"linear-gradient(to \".concat(orientation[Number(!dir)], \",hsl(0,0%,50%),hsla(0,0%,50%,0))\"), \"hsl(\".concat(zValue, \", 100%, 50%)\")].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSL_S = (orientation, dir, alphaValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\"linear-gradient(to \".concat(orientation[Number(!dir)], \", hsla(0,0%,0%,\").concat(alphaValue, \") 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,\").concat(alphaValue, \") 100%)\"), \"linear-gradient(to \".concat(orientation[Number(dir)], \",hsla(0,100%,50%,\").concat(alphaValue, \"),hsla(60,100%,50%,\").concat(alphaValue, \"),hsla(120,100%,50%,\").concat(alphaValue, \"),hsla(180,100%,50%,\").concat(alphaValue, \"),hsla(240,100%,50%,\").concat(alphaValue, \"),hsla(300,100%,50%,\").concat(alphaValue, \"),hsla(359,100%,50%,\").concat(alphaValue, \"))\"), \"hsl(0, 0%, 50%)\"].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSL_L = (orientation, dir, zValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      backgroundImage: [\"linear-gradient(to \".concat(orientation[Number(!dir)], \",hsl(0,0%,\").concat(zValue, \"%),hsla(0,0%,\").concat(zValue, \"%,0))\"), \"linear-gradient(to \".concat(orientation[Number(dir)], \",hsl(0,100%,\").concat(zValue, \"%),hsl(60,100%,\").concat(zValue, \"%),hsl(120,100%,\").concat(zValue, \"%),hsl(180,100%,\").concat(zValue, \"%),hsl(240,100%,\").concat(zValue, \"%),hsl(300,100%,\").concat(zValue, \"%),hsl(360,100%,\").concat(zValue, \"%))\")].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSB_H = (orientation, dir, zValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\"linear-gradient(to \".concat(orientation[Number(dir)], \",hsl(0,0%,0%),hsla(0,0%,0%,0))\"), \"linear-gradient(to \".concat(orientation[Number(!dir)], \",hsl(0,0%,100%),hsla(0,0%,100%,0))\"), \"hsl(\".concat(zValue, \", 100%, 50%)\")].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSB_S = (orientation, dir, alphaValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\"linear-gradient(to \".concat(orientation[Number(!dir)], \",hsla(0,0%,0%,\").concat(alphaValue, \"),hsla(0,0%,0%,0))\"), \"linear-gradient(to \".concat(orientation[Number(dir)], \",hsla(0,100%,50%,\").concat(alphaValue, \"),hsla(60,100%,50%,\").concat(alphaValue, \"),hsla(120,100%,50%,\").concat(alphaValue, \"),hsla(180,100%,50%,\").concat(alphaValue, \"),hsla(240,100%,50%,\").concat(alphaValue, \"),hsla(300,100%,50%,\").concat(alphaValue, \"),hsla(359,100%,50%,\").concat(alphaValue, \"))\"), \"linear-gradient(to \".concat(orientation[Number(!dir)], \",hsl(0,0%,0%),hsl(0,0%,100%))\")].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSB_B = (orientation, dir, alphaValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\"linear-gradient(to \".concat(orientation[Number(!dir)], \",hsla(0,0%,100%,\").concat(alphaValue, \"),hsla(0,0%,100%,0))\"), \"linear-gradient(to \".concat(orientation[Number(dir)], \",hsla(0,100%,50%,\").concat(alphaValue, \"),hsla(60,100%,50%,\").concat(alphaValue, \"),hsla(120,100%,50%,\").concat(alphaValue, \"),hsla(180,100%,50%,\").concat(alphaValue, \"),hsla(240,100%,50%,\").concat(alphaValue, \"),hsla(300,100%,50%,\").concat(alphaValue, \"),hsla(359,100%,50%,\").concat(alphaValue, \"))\"), \"#000\"].join(\",\")\n    }\n  };\n  return result;\n};\n\n// src/area-gradient.ts\nfunction getColorAreaGradient(color, options) {\n  const {\n    xChannel,\n    yChannel,\n    dir: dirProp = \"ltr\"\n  } = options;\n  const {\n    zChannel\n  } = color.getColorAxes({\n    xChannel,\n    yChannel\n  });\n  const zValue = color.getChannelValue(zChannel);\n  const {\n    minValue: zMin,\n    maxValue: zMax\n  } = color.getChannelRange(zChannel);\n  const orientation = [\"top\", dirProp === \"rtl\" ? \"left\" : \"right\"];\n  let dir = false;\n  let background = {\n    areaStyles: {},\n    areaGradientStyles: {}\n  };\n  let alphaValue = (zValue - zMin) / (zMax - zMin);\n  let isHSL = color.getFormat() === \"hsla\";\n  switch (zChannel) {\n    case \"red\":\n      {\n        dir = xChannel === \"green\";\n        background = generateRGB_R(orientation, dir, zValue);\n        break;\n      }\n    case \"green\":\n      {\n        dir = xChannel === \"red\";\n        background = generateRGB_G(orientation, dir, zValue);\n        break;\n      }\n    case \"blue\":\n      {\n        dir = xChannel === \"red\";\n        background = generateRGB_B(orientation, dir, zValue);\n        break;\n      }\n    case \"hue\":\n      {\n        dir = xChannel !== \"saturation\";\n        if (isHSL) {\n          background = generateHSL_H(orientation, dir, zValue);\n        } else {\n          background = generateHSB_H(orientation, dir, zValue);\n        }\n        break;\n      }\n    case \"saturation\":\n      {\n        dir = xChannel === \"hue\";\n        if (isHSL) {\n          background = generateHSL_S(orientation, dir, alphaValue);\n        } else {\n          background = generateHSB_S(orientation, dir, alphaValue);\n        }\n        break;\n      }\n    case \"brightness\":\n      {\n        dir = xChannel === \"hue\";\n        background = generateHSB_B(orientation, dir, alphaValue);\n        break;\n      }\n    case \"lightness\":\n      {\n        dir = xChannel === \"hue\";\n        background = generateHSL_L(orientation, dir, zValue);\n        break;\n      }\n  }\n  return background;\n}\nvar isEqualObject = (a, b) => {\n  if (Object.keys(a).length !== Object.keys(b).length) return false;\n  for (let key in a) if (a[key] !== b[key]) return false;\n  return true;\n};\nvar Color = class {\n  toHexInt() {\n    return this.toFormat(\"rgba\").toHexInt();\n  }\n  getChannelValue(channel) {\n    if (channel in this) return this[channel];\n    throw new Error(\"Unsupported color channel: \" + channel);\n  }\n  getChannelValuePercent(channel, valueToCheck) {\n    const value = valueToCheck !== null && valueToCheck !== void 0 ? valueToCheck : this.getChannelValue(channel);\n    const {\n      minValue,\n      maxValue\n    } = this.getChannelRange(channel);\n    return getValuePercent(value, minValue, maxValue);\n  }\n  getChannelPercentValue(channel, percentToCheck) {\n    const {\n      minValue,\n      maxValue,\n      step\n    } = this.getChannelRange(channel);\n    const percentValue = getPercentValue(percentToCheck, minValue, maxValue, step);\n    return snapValueToStep(percentValue, minValue, maxValue, step);\n  }\n  withChannelValue(channel, value) {\n    const {\n      minValue,\n      maxValue\n    } = this.getChannelRange(channel);\n    if (channel in this) {\n      let clone = this.clone();\n      clone[channel] = clampValue(value, minValue, maxValue);\n      return clone;\n    }\n    throw new Error(\"Unsupported color channel: \" + channel);\n  }\n  getColorAxes(xyChannels) {\n    let {\n      xChannel,\n      yChannel\n    } = xyChannels;\n    let xCh = xChannel || this.getChannels().find(c => c !== yChannel);\n    let yCh = yChannel || this.getChannels().find(c => c !== xCh);\n    let zCh = this.getChannels().find(c => c !== xCh && c !== yCh);\n    return {\n      xChannel: xCh,\n      yChannel: yCh,\n      zChannel: zCh\n    };\n  }\n  incrementChannel(channel, stepSize) {\n    const {\n      minValue,\n      maxValue,\n      step\n    } = this.getChannelRange(channel);\n    const value = snapValueToStep(clampValue(this.getChannelValue(channel) + stepSize, minValue, maxValue), minValue, maxValue, step);\n    return this.withChannelValue(channel, value);\n  }\n  decrementChannel(channel, stepSize) {\n    return this.incrementChannel(channel, -stepSize);\n  }\n  isEqual(color) {\n    const isSame = isEqualObject(this.toJSON(), color.toJSON());\n    return isSame && this.getChannelValue(\"alpha\") === color.getChannelValue(\"alpha\");\n  }\n};\nvar HEX_COLOR_REGEX = /^#[\\da-f]+$/i;\nvar RGB_COLOR_REGEX = /^rgba?\\((.*)\\)$/;\nvar HEX_STARTING_REGEX = /[^#]/gi;\nvar _RGBColor = class _RGBColor extends Color {\n  constructor(red, green, blue, alpha) {\n    super();\n    this.red = red;\n    this.green = green;\n    this.blue = blue;\n    this.alpha = alpha;\n  }\n  static parse(value) {\n    var _colors$;\n    let colors = [];\n    if (HEX_COLOR_REGEX.test(value) && [4, 5, 7, 9].includes(value.length)) {\n      const values = (value.length < 6 ? value.replace(HEX_STARTING_REGEX, \"$&$&\") : value).slice(1).split(\"\");\n      while (values.length > 0) {\n        colors.push(parseInt(values.splice(0, 2).join(\"\"), 16));\n      }\n      colors[3] = colors[3] !== void 0 ? colors[3] / 255 : void 0;\n    }\n    const match = value.match(RGB_COLOR_REGEX);\n    if (match !== null && match !== void 0 && match[1]) {\n      colors = match[1].split(\",\").map(value2 => Number(value2.trim())).map((num, i) => clampValue(num, 0, i < 3 ? 255 : 1));\n    }\n    return colors.length < 3 ? void 0 : new _RGBColor(colors[0], colors[1], colors[2], (_colors$ = colors[3]) !== null && _colors$ !== void 0 ? _colors$ : 1);\n  }\n  toString(format) {\n    switch (format) {\n      case \"hex\":\n        return \"#\" + (this.red.toString(16).padStart(2, \"0\") + this.green.toString(16).padStart(2, \"0\") + this.blue.toString(16).padStart(2, \"0\")).toUpperCase();\n      case \"hexa\":\n        return \"#\" + (this.red.toString(16).padStart(2, \"0\") + this.green.toString(16).padStart(2, \"0\") + this.blue.toString(16).padStart(2, \"0\") + Math.round(this.alpha * 255).toString(16).padStart(2, \"0\")).toUpperCase();\n      case \"rgb\":\n        return \"rgb(\".concat(this.red, \", \").concat(this.green, \", \").concat(this.blue, \")\");\n      case \"css\":\n      case \"rgba\":\n        return \"rgba(\".concat(this.red, \", \").concat(this.green, \", \").concat(this.blue, \", \").concat(this.alpha, \")\");\n      case \"hsl\":\n        return this.toHSL().toString(\"hsl\");\n      case \"hsb\":\n        return this.toHSB().toString(\"hsb\");\n      default:\n        return this.toFormat(format).toString(format);\n    }\n  }\n  toFormat(format) {\n    switch (format) {\n      case \"rgba\":\n        return this;\n      case \"hsba\":\n        return this.toHSB();\n      case \"hsla\":\n        return this.toHSL();\n      default:\n        throw new Error(\"Unsupported color conversion: rgb -> \" + format);\n    }\n  }\n  toHexInt() {\n    return this.red << 16 | this.green << 8 | this.blue;\n  }\n  /**\n   * Converts an RGB color value to HSB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.\n   * @returns An HSBColor object.\n   */\n  toHSB() {\n    const red = this.red / 255;\n    const green = this.green / 255;\n    const blue = this.blue / 255;\n    const min = Math.min(red, green, blue);\n    const brightness = Math.max(red, green, blue);\n    const chroma = brightness - min;\n    const saturation = brightness === 0 ? 0 : chroma / brightness;\n    let hue = 0;\n    if (chroma !== 0) {\n      switch (brightness) {\n        case red:\n          hue = (green - blue) / chroma + (green < blue ? 6 : 0);\n          break;\n        case green:\n          hue = (blue - red) / chroma + 2;\n          break;\n        case blue:\n          hue = (red - green) / chroma + 4;\n          break;\n      }\n      hue /= 6;\n    }\n    return new HSBColor(toFixedNumber(hue * 360, 2), toFixedNumber(saturation * 100, 2), toFixedNumber(brightness * 100, 2), toFixedNumber(this.alpha, 2));\n  }\n  /**\n   * Converts an RGB color value to HSL.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.\n   * @returns An HSLColor object.\n   */\n  toHSL() {\n    const red = this.red / 255;\n    const green = this.green / 255;\n    const blue = this.blue / 255;\n    const min = Math.min(red, green, blue);\n    const max = Math.max(red, green, blue);\n    const lightness = (max + min) / 2;\n    const chroma = max - min;\n    let hue = -1;\n    let saturation = -1;\n    if (chroma === 0) {\n      hue = saturation = 0;\n    } else {\n      saturation = chroma / (lightness < 0.5 ? max + min : 2 - max - min);\n      switch (max) {\n        case red:\n          hue = (green - blue) / chroma + (green < blue ? 6 : 0);\n          break;\n        case green:\n          hue = (blue - red) / chroma + 2;\n          break;\n        case blue:\n          hue = (red - green) / chroma + 4;\n          break;\n      }\n      hue /= 6;\n    }\n    return new HSLColor(toFixedNumber(hue * 360, 2), toFixedNumber(saturation * 100, 2), toFixedNumber(lightness * 100, 2), toFixedNumber(this.alpha, 2));\n  }\n  clone() {\n    return new _RGBColor(this.red, this.green, this.blue, this.alpha);\n  }\n  getChannelFormatOptions(channel) {\n    switch (channel) {\n      case \"red\":\n      case \"green\":\n      case \"blue\":\n        return {\n          style: \"decimal\"\n        };\n      case \"alpha\":\n        return {\n          style: \"percent\"\n        };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  formatChannelValue(channel, locale) {\n    let options = this.getChannelFormatOptions(channel);\n    let value = this.getChannelValue(channel);\n    return new Intl.NumberFormat(locale, options).format(value);\n  }\n  getChannelRange(channel) {\n    switch (channel) {\n      case \"red\":\n      case \"green\":\n      case \"blue\":\n        return {\n          minValue: 0,\n          maxValue: 255,\n          step: 1,\n          pageSize: 17\n        };\n      case \"alpha\":\n        return {\n          minValue: 0,\n          maxValue: 1,\n          step: 0.01,\n          pageSize: 0.1\n        };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  toJSON() {\n    return {\n      r: this.red,\n      g: this.green,\n      b: this.blue,\n      a: this.alpha\n    };\n  }\n  getFormat() {\n    return \"rgba\";\n  }\n  getChannels() {\n    return _RGBColor.colorChannels;\n  }\n};\n__publicField(_RGBColor, \"colorChannels\", [\"red\", \"green\", \"blue\"]);\nvar RGBColor = _RGBColor;\n\n// src/hsl-color.ts\nvar HSL_REGEX = /hsl\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%)\\)|hsla\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d(.\\d+)?)\\)/;\nvar _HSLColor = class _HSLColor extends Color {\n  constructor(hue, saturation, lightness, alpha) {\n    super();\n    this.hue = hue;\n    this.saturation = saturation;\n    this.lightness = lightness;\n    this.alpha = alpha;\n  }\n  static parse(value) {\n    let m;\n    if (m = value.match(HSL_REGEX)) {\n      var _m$;\n      const [h, s, l, a] = ((_m$ = m[1]) !== null && _m$ !== void 0 ? _m$ : m[2]).split(\",\").map(n => Number(n.trim().replace(\"%\", \"\")));\n      return new _HSLColor(mod(h, 360), clampValue(s, 0, 100), clampValue(l, 0, 100), clampValue(a !== null && a !== void 0 ? a : 1, 0, 1));\n    }\n  }\n  toString(format) {\n    switch (format) {\n      case \"hex\":\n        return this.toRGB().toString(\"hex\");\n      case \"hexa\":\n        return this.toRGB().toString(\"hexa\");\n      case \"hsl\":\n        return \"hsl(\".concat(this.hue, \", \").concat(toFixedNumber(this.saturation, 2), \"%, \").concat(toFixedNumber(this.lightness, 2), \"%)\");\n      case \"css\":\n      case \"hsla\":\n        return \"hsla(\".concat(this.hue, \", \").concat(toFixedNumber(this.saturation, 2), \"%, \").concat(toFixedNumber(this.lightness, 2), \"%, \").concat(this.alpha, \")\");\n      case \"hsb\":\n        return this.toHSB().toString(\"hsb\");\n      case \"rgb\":\n        return this.toRGB().toString(\"rgb\");\n      default:\n        return this.toFormat(format).toString(format);\n    }\n  }\n  toFormat(format) {\n    switch (format) {\n      case \"hsla\":\n        return this;\n      case \"hsba\":\n        return this.toHSB();\n      case \"rgba\":\n        return this.toRGB();\n      default:\n        throw new Error(\"Unsupported color conversion: hsl -> \" + format);\n    }\n  }\n  /**\n   * Converts a HSL color to HSB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_HSV.\n   * @returns An HSBColor object.\n   */\n  toHSB() {\n    let saturation = this.saturation / 100;\n    let lightness = this.lightness / 100;\n    let brightness = lightness + saturation * Math.min(lightness, 1 - lightness);\n    saturation = brightness === 0 ? 0 : 2 * (1 - lightness / brightness);\n    return new HSBColor(toFixedNumber(this.hue, 2), toFixedNumber(saturation * 100, 2), toFixedNumber(brightness * 100, 2), toFixedNumber(this.alpha, 2));\n  }\n  /**\n   * Converts a HSL color to RGB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative.\n   * @returns An RGBColor object.\n   */\n  toRGB() {\n    let hue = this.hue;\n    let saturation = this.saturation / 100;\n    let lightness = this.lightness / 100;\n    let a = saturation * Math.min(lightness, 1 - lightness);\n    let fn = function (n) {\n      let k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (n + hue / 30) % 12;\n      return lightness - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n    };\n    return new RGBColor(Math.round(fn(0) * 255), Math.round(fn(8) * 255), Math.round(fn(4) * 255), toFixedNumber(this.alpha, 2));\n  }\n  clone() {\n    return new _HSLColor(this.hue, this.saturation, this.lightness, this.alpha);\n  }\n  getChannelFormatOptions(channel) {\n    switch (channel) {\n      case \"hue\":\n        return {\n          style: \"unit\",\n          unit: \"degree\",\n          unitDisplay: \"narrow\"\n        };\n      case \"saturation\":\n      case \"lightness\":\n      case \"alpha\":\n        return {\n          style: \"percent\"\n        };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  formatChannelValue(channel, locale) {\n    let options = this.getChannelFormatOptions(channel);\n    let value = this.getChannelValue(channel);\n    if (channel === \"saturation\" || channel === \"lightness\") {\n      value /= 100;\n    }\n    return new Intl.NumberFormat(locale, options).format(value);\n  }\n  getChannelRange(channel) {\n    switch (channel) {\n      case \"hue\":\n        return {\n          minValue: 0,\n          maxValue: 360,\n          step: 1,\n          pageSize: 15\n        };\n      case \"saturation\":\n      case \"lightness\":\n        return {\n          minValue: 0,\n          maxValue: 100,\n          step: 1,\n          pageSize: 10\n        };\n      case \"alpha\":\n        return {\n          minValue: 0,\n          maxValue: 1,\n          step: 0.01,\n          pageSize: 0.1\n        };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  toJSON() {\n    return {\n      h: this.hue,\n      s: this.saturation,\n      l: this.lightness,\n      a: this.alpha\n    };\n  }\n  getFormat() {\n    return \"hsla\";\n  }\n  getChannels() {\n    return _HSLColor.colorChannels;\n  }\n};\n__publicField(_HSLColor, \"colorChannels\", [\"hue\", \"saturation\", \"lightness\"]);\nvar HSLColor = _HSLColor;\n\n// src/hsb-color.ts\nvar HSB_REGEX = /hsb\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%)\\)|hsba\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d(.\\d+)?)\\)/;\nvar _HSBColor = class _HSBColor extends Color {\n  constructor(hue, saturation, brightness, alpha) {\n    super();\n    this.hue = hue;\n    this.saturation = saturation;\n    this.brightness = brightness;\n    this.alpha = alpha;\n  }\n  static parse(value) {\n    let m;\n    if (m = value.match(HSB_REGEX)) {\n      var _m$2;\n      const [h, s, b, a] = ((_m$2 = m[1]) !== null && _m$2 !== void 0 ? _m$2 : m[2]).split(\",\").map(n => Number(n.trim().replace(\"%\", \"\")));\n      return new _HSBColor(mod(h, 360), clampValue(s, 0, 100), clampValue(b, 0, 100), clampValue(a !== null && a !== void 0 ? a : 1, 0, 1));\n    }\n  }\n  toString(format) {\n    switch (format) {\n      case \"css\":\n        return this.toHSL().toString(\"css\");\n      case \"hex\":\n        return this.toRGB().toString(\"hex\");\n      case \"hexa\":\n        return this.toRGB().toString(\"hexa\");\n      case \"hsb\":\n        return \"hsb(\".concat(this.hue, \", \").concat(toFixedNumber(this.saturation, 2), \"%, \").concat(toFixedNumber(this.brightness, 2), \"%)\");\n      case \"hsba\":\n        return \"hsba(\".concat(this.hue, \", \").concat(toFixedNumber(this.saturation, 2), \"%, \").concat(toFixedNumber(this.brightness, 2), \"%, \").concat(this.alpha, \")\");\n      case \"hsl\":\n        return this.toHSL().toString(\"hsl\");\n      case \"rgb\":\n        return this.toRGB().toString(\"rgb\");\n      default:\n        return this.toFormat(format).toString(format);\n    }\n  }\n  toFormat(format) {\n    switch (format) {\n      case \"hsba\":\n        return this;\n      case \"hsla\":\n        return this.toHSL();\n      case \"rgba\":\n        return this.toRGB();\n      default:\n        throw new Error(\"Unsupported color conversion: hsb -> \" + format);\n    }\n  }\n  /**\n   * Converts a HSB color to HSL.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_HSL.\n   * @returns An HSLColor object.\n   */\n  toHSL() {\n    let saturation = this.saturation / 100;\n    let brightness = this.brightness / 100;\n    let lightness = brightness * (1 - saturation / 2);\n    saturation = lightness === 0 || lightness === 1 ? 0 : (brightness - lightness) / Math.min(lightness, 1 - lightness);\n    return new HSLColor(toFixedNumber(this.hue, 2), toFixedNumber(saturation * 100, 2), toFixedNumber(lightness * 100, 2), toFixedNumber(this.alpha, 2));\n  }\n  /**\n   * Converts a HSV color value to RGB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB_alternative.\n   * @returns An RGBColor object.\n   */\n  toRGB() {\n    let hue = this.hue;\n    let saturation = this.saturation / 100;\n    let brightness = this.brightness / 100;\n    let fn = function (n) {\n      let k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (n + hue / 60) % 6;\n      return brightness - saturation * brightness * Math.max(Math.min(k, 4 - k, 1), 0);\n    };\n    return new RGBColor(Math.round(fn(5) * 255), Math.round(fn(3) * 255), Math.round(fn(1) * 255), toFixedNumber(this.alpha, 2));\n  }\n  clone() {\n    return new _HSBColor(this.hue, this.saturation, this.brightness, this.alpha);\n  }\n  getChannelFormatOptions(channel) {\n    switch (channel) {\n      case \"hue\":\n        return {\n          style: \"unit\",\n          unit: \"degree\",\n          unitDisplay: \"narrow\"\n        };\n      case \"saturation\":\n      case \"brightness\":\n      case \"alpha\":\n        return {\n          style: \"percent\"\n        };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  formatChannelValue(channel, locale) {\n    let options = this.getChannelFormatOptions(channel);\n    let value = this.getChannelValue(channel);\n    if (channel === \"saturation\" || channel === \"brightness\") {\n      value /= 100;\n    }\n    return new Intl.NumberFormat(locale, options).format(value);\n  }\n  getChannelRange(channel) {\n    switch (channel) {\n      case \"hue\":\n        return {\n          minValue: 0,\n          maxValue: 360,\n          step: 1,\n          pageSize: 15\n        };\n      case \"saturation\":\n      case \"brightness\":\n        return {\n          minValue: 0,\n          maxValue: 100,\n          step: 1,\n          pageSize: 10\n        };\n      case \"alpha\":\n        return {\n          minValue: 0,\n          maxValue: 1,\n          step: 0.01,\n          pageSize: 0.1\n        };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  toJSON() {\n    return {\n      h: this.hue,\n      s: this.saturation,\n      b: this.brightness,\n      a: this.alpha\n    };\n  }\n  getFormat() {\n    return \"hsba\";\n  }\n  getChannels() {\n    return _HSBColor.colorChannels;\n  }\n};\n__publicField(_HSBColor, \"colorChannels\", [\"hue\", \"saturation\", \"brightness\"]);\nvar HSBColor = _HSBColor;\n\n// src/native-color.ts\nvar nativeColors = \"aliceblue:f0f8ff,antiquewhite:faebd7,aqua:00ffff,aquamarine:7fffd4,azure:f0ffff,beige:f5f5dc,bisque:ffe4c4,black:000000,blanchedalmond:ffebcd,blue:0000ff,blueviolet:8a2be2,brown:a52a2a,burlywood:deb887,cadetblue:5f9ea0,chartreuse:7fff00,chocolate:d2691e,coral:ff7f50,cornflowerblue:6495ed,cornsilk:fff8dc,crimson:dc143c,cyan:00ffff,darkblue:00008b,darkcyan:008b8b,darkgoldenrod:b8860b,darkgray:a9a9a9,darkgreen:006400,darkkhaki:bdb76b,darkmagenta:8b008b,darkolivegreen:556b2f,darkorange:ff8c00,darkorchid:9932cc,darkred:8b0000,darksalmon:e9967a,darkseagreen:8fbc8f,darkslateblue:483d8b,darkslategray:2f4f4f,darkturquoise:00ced1,darkviolet:9400d3,deeppink:ff1493,deepskyblue:00bfff,dimgray:696969,dodgerblue:1e90ff,firebrick:b22222,floralwhite:fffaf0,forestgreen:228b22,fuchsia:ff00ff,gainsboro:dcdcdc,ghostwhite:f8f8ff,gold:ffd700,goldenrod:daa520,gray:808080,green:008000,greenyellow:adff2f,honeydew:f0fff0,hotpink:ff69b4,indianred:cd5c5c,indigo:4b0082,ivory:fffff0,khaki:f0e68c,lavender:e6e6fa,lavenderblush:fff0f5,lawngreen:7cfc00,lemonchiffon:fffacd,lightblue:add8e6,lightcoral:f08080,lightcyan:e0ffff,lightgoldenrodyellow:fafad2,lightgrey:d3d3d3,lightgreen:90ee90,lightpink:ffb6c1,lightsalmon:ffa07a,lightseagreen:20b2aa,lightskyblue:87cefa,lightslategray:778899,lightsteelblue:b0c4de,lightyellow:ffffe0,lime:00ff00,limegreen:32cd32,linen:faf0e6,magenta:ff00ff,maroon:800000,mediumaquamarine:66cdaa,mediumblue:0000cd,mediumorchid:ba55d3,mediumpurple:9370d8,mediumseagreen:3cb371,mediumslateblue:7b68ee,mediumspringgreen:00fa9a,mediumturquoise:48d1cc,mediumvioletred:c71585,midnightblue:191970,mintcream:f5fffa,mistyrose:ffe4e1,moccasin:ffe4b5,navajowhite:ffdead,navy:000080,oldlace:fdf5e6,olive:808000,olivedrab:6b8e23,orange:ffa500,orangered:ff4500,orchid:da70d6,palegoldenrod:eee8aa,palegreen:98fb98,paleturquoise:afeeee,palevioletred:d87093,papayawhip:ffefd5,peachpuff:ffdab9,peru:cd853f,pink:ffc0cb,plum:dda0dd,powderblue:b0e0e6,purple:800080,rebeccapurple:663399,red:ff0000,rosybrown:bc8f8f,royalblue:4169e1,saddlebrown:8b4513,salmon:fa8072,sandybrown:f4a460,seagreen:2e8b57,seashell:fff5ee,sienna:a0522d,silver:c0c0c0,skyblue:87ceeb,slateblue:6a5acd,slategray:708090,snow:fffafa,springgreen:00ff7f,steelblue:4682b4,tan:d2b48c,teal:008080,thistle:d8bfd8,tomato:ff6347,turquoise:40e0d0,violet:ee82ee,wheat:f5deb3,white:ffffff,whitesmoke:f5f5f5,yellow:ffff00,yellowgreen:9acd32\";\nvar makeMap = str => {\n  const map = /* @__PURE__ */new Map();\n  const list = str.split(\",\");\n  for (let i = 0; i < list.length; i++) {\n    const [key, val] = list[i].split(\":\");\n    map.set(key, \"#\".concat(val));\n    if (key.includes(\"gray\")) map.set(key.replace(\"gray\", \"grey\"), \"#\".concat(val));\n  }\n  return map;\n};\nvar nativeColorMap = makeMap(nativeColors);\n\n// src/parse-color.ts\nvar parseColor = value => {\n  if (nativeColorMap.has(value)) {\n    return parseColor(nativeColorMap.get(value));\n  }\n  const result = RGBColor.parse(value) || HSBColor.parse(value) || HSLColor.parse(value);\n  if (!result) {\n    var _Error$captureStackTr;\n    const error = new Error(\"Invalid color value: \" + value);\n    (_Error$captureStackTr = Error.captureStackTrace) === null || _Error$captureStackTr === void 0 || _Error$captureStackTr.call(Error, error, parseColor);\n    throw error;\n  }\n  return result;\n};\nvar normalizeColor = v => {\n  return typeof v === \"string\" ? parseColor(v) : v;\n};\nexport { Color, getColorAreaGradient, normalizeColor, parseColor };","map":{"version":3,"names":["getValuePercent","getPercentValue","snapValueToStep","clampValue","toFixedNumber","mod","__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","generateRGB_R","orientation","dir","zValue","maskImage","concat","Number","result","areaStyles","backgroundImage","areaGradientStyles","WebkitMaskImage","generateRGB_G","generateRGB_B","generateHSL_H","background","join","generateHSL_S","alphaValue","generateHSL_L","generateHSB_H","generateHSB_S","generateHSB_B","getColorAreaGradient","color","options","xChannel","yChannel","dirProp","zChannel","getColorAxes","getChannelValue","minValue","zMin","maxValue","zMax","getChannelRange","isHSL","getFormat","isEqualObject","a","b","keys","length","Color","toHexInt","toFormat","channel","Error","getChannelValuePercent","valueToCheck","getChannelPercentValue","percentToCheck","step","percentValue","withChannelValue","clone","xyChannels","xCh","getChannels","find","c","yCh","zCh","incrementChannel","stepSize","decrementChannel","isEqual","isSame","toJSON","HEX_COLOR_REGEX","RGB_COLOR_REGEX","HEX_STARTING_REGEX","_RGBColor","constructor","red","green","blue","alpha","parse","_colors$","colors","test","includes","values","replace","slice","split","push","parseInt","splice","match","map","value2","trim","num","i","toString","format","padStart","toUpperCase","Math","round","toHSL","toHSB","min","brightness","max","chroma","saturation","hue","HSBColor","lightness","HSLColor","getChannelFormatOptions","style","formatChannelValue","locale","Intl","NumberFormat","pageSize","r","g","colorChannels","RGBColor","HSL_REGEX","_HSLColor","m","_m$","h","s","l","n","toRGB","fn","k","arguments","undefined","unit","unitDisplay","HSB_REGEX","_HSBColor","_m$2","nativeColors","makeMap","str","Map","list","val","set","nativeColorMap","parseColor","has","get","_Error$captureStackTr","error","captureStackTrace","call","normalizeColor","v"],"sources":["C:/Users/JAMES/cerebras-1/CerebrasApp/frontend/node_modules/@zag-js/color-utils/dist/index.mjs"],"sourcesContent":["import { getValuePercent, getPercentValue, snapValueToStep, clampValue, toFixedNumber, mod } from '@zag-js/utils';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, key + \"\" , value);\n\n// src/color-format-gradient.ts\nvar generateRGB_R = (orientation, dir, zValue) => {\n  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;\n  const result = {\n    areaStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,0),rgb(${zValue},255,0))`\n    },\n    areaGradientStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,255),rgb(${zValue},255,255))`,\n      WebkitMaskImage: maskImage,\n      maskImage\n    }\n  };\n  return result;\n};\nvar generateRGB_G = (orientation, dir, zValue) => {\n  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;\n  const result = {\n    areaStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},0),rgb(255,${zValue},0))`\n    },\n    areaGradientStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},255),rgb(255,${zValue},255))`,\n      WebkitMaskImage: maskImage,\n      maskImage\n    }\n  };\n  return result;\n};\nvar generateRGB_B = (orientation, dir, zValue) => {\n  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;\n  const result = {\n    areaStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,0,${zValue}),rgb(255,0,${zValue}))`\n    },\n    areaGradientStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,255,${zValue}),rgb(255,255,${zValue}))`,\n      WebkitMaskImage: maskImage,\n      maskImage\n    }\n  };\n  return result;\n};\nvar generateHSL_H = (orientation, dir, zValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\n        `linear-gradient(to ${orientation[Number(dir)]}, hsla(0,0%,0%,1) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,1) 100%)`,\n        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,50%),hsla(0,0%,50%,0))`,\n        `hsl(${zValue}, 100%, 50%)`\n      ].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSL_S = (orientation, dir, alphaValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\n        `linear-gradient(to ${orientation[Number(!dir)]}, hsla(0,0%,0%,${alphaValue}) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,${alphaValue}) 100%)`,\n        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,\n        \"hsl(0, 0%, 50%)\"\n      ].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSL_L = (orientation, dir, zValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      backgroundImage: [\n        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,${zValue}%),hsla(0,0%,${zValue}%,0))`,\n        `linear-gradient(to ${orientation[Number(dir)]},hsl(0,100%,${zValue}%),hsl(60,100%,${zValue}%),hsl(120,100%,${zValue}%),hsl(180,100%,${zValue}%),hsl(240,100%,${zValue}%),hsl(300,100%,${zValue}%),hsl(360,100%,${zValue}%))`\n      ].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSB_H = (orientation, dir, zValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\n        `linear-gradient(to ${orientation[Number(dir)]},hsl(0,0%,0%),hsla(0,0%,0%,0))`,\n        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,100%),hsla(0,0%,100%,0))`,\n        `hsl(${zValue}, 100%, 50%)`\n      ].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSB_S = (orientation, dir, alphaValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\n        `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,0%,${alphaValue}),hsla(0,0%,0%,0))`,\n        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,\n        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,0%),hsl(0,0%,100%))`\n      ].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSB_B = (orientation, dir, alphaValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\n        `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,100%,${alphaValue}),hsla(0,0%,100%,0))`,\n        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,\n        \"#000\"\n      ].join(\",\")\n    }\n  };\n  return result;\n};\n\n// src/area-gradient.ts\nfunction getColorAreaGradient(color, options) {\n  const { xChannel, yChannel, dir: dirProp = \"ltr\" } = options;\n  const { zChannel } = color.getColorAxes({ xChannel, yChannel });\n  const zValue = color.getChannelValue(zChannel);\n  const { minValue: zMin, maxValue: zMax } = color.getChannelRange(zChannel);\n  const orientation = [\"top\", dirProp === \"rtl\" ? \"left\" : \"right\"];\n  let dir = false;\n  let background = { areaStyles: {}, areaGradientStyles: {} };\n  let alphaValue = (zValue - zMin) / (zMax - zMin);\n  let isHSL = color.getFormat() === \"hsla\";\n  switch (zChannel) {\n    case \"red\": {\n      dir = xChannel === \"green\";\n      background = generateRGB_R(orientation, dir, zValue);\n      break;\n    }\n    case \"green\": {\n      dir = xChannel === \"red\";\n      background = generateRGB_G(orientation, dir, zValue);\n      break;\n    }\n    case \"blue\": {\n      dir = xChannel === \"red\";\n      background = generateRGB_B(orientation, dir, zValue);\n      break;\n    }\n    case \"hue\": {\n      dir = xChannel !== \"saturation\";\n      if (isHSL) {\n        background = generateHSL_H(orientation, dir, zValue);\n      } else {\n        background = generateHSB_H(orientation, dir, zValue);\n      }\n      break;\n    }\n    case \"saturation\": {\n      dir = xChannel === \"hue\";\n      if (isHSL) {\n        background = generateHSL_S(orientation, dir, alphaValue);\n      } else {\n        background = generateHSB_S(orientation, dir, alphaValue);\n      }\n      break;\n    }\n    case \"brightness\": {\n      dir = xChannel === \"hue\";\n      background = generateHSB_B(orientation, dir, alphaValue);\n      break;\n    }\n    case \"lightness\": {\n      dir = xChannel === \"hue\";\n      background = generateHSL_L(orientation, dir, zValue);\n      break;\n    }\n  }\n  return background;\n}\nvar isEqualObject = (a, b) => {\n  if (Object.keys(a).length !== Object.keys(b).length) return false;\n  for (let key in a) if (a[key] !== b[key]) return false;\n  return true;\n};\nvar Color = class {\n  toHexInt() {\n    return this.toFormat(\"rgba\").toHexInt();\n  }\n  getChannelValue(channel) {\n    if (channel in this) return this[channel];\n    throw new Error(\"Unsupported color channel: \" + channel);\n  }\n  getChannelValuePercent(channel, valueToCheck) {\n    const value = valueToCheck ?? this.getChannelValue(channel);\n    const { minValue, maxValue } = this.getChannelRange(channel);\n    return getValuePercent(value, minValue, maxValue);\n  }\n  getChannelPercentValue(channel, percentToCheck) {\n    const { minValue, maxValue, step } = this.getChannelRange(channel);\n    const percentValue = getPercentValue(percentToCheck, minValue, maxValue, step);\n    return snapValueToStep(percentValue, minValue, maxValue, step);\n  }\n  withChannelValue(channel, value) {\n    const { minValue, maxValue } = this.getChannelRange(channel);\n    if (channel in this) {\n      let clone = this.clone();\n      clone[channel] = clampValue(value, minValue, maxValue);\n      return clone;\n    }\n    throw new Error(\"Unsupported color channel: \" + channel);\n  }\n  getColorAxes(xyChannels) {\n    let { xChannel, yChannel } = xyChannels;\n    let xCh = xChannel || this.getChannels().find((c) => c !== yChannel);\n    let yCh = yChannel || this.getChannels().find((c) => c !== xCh);\n    let zCh = this.getChannels().find((c) => c !== xCh && c !== yCh);\n    return { xChannel: xCh, yChannel: yCh, zChannel: zCh };\n  }\n  incrementChannel(channel, stepSize) {\n    const { minValue, maxValue, step } = this.getChannelRange(channel);\n    const value = snapValueToStep(\n      clampValue(this.getChannelValue(channel) + stepSize, minValue, maxValue),\n      minValue,\n      maxValue,\n      step\n    );\n    return this.withChannelValue(channel, value);\n  }\n  decrementChannel(channel, stepSize) {\n    return this.incrementChannel(channel, -stepSize);\n  }\n  isEqual(color) {\n    const isSame = isEqualObject(this.toJSON(), color.toJSON());\n    return isSame && this.getChannelValue(\"alpha\") === color.getChannelValue(\"alpha\");\n  }\n};\nvar HEX_COLOR_REGEX = /^#[\\da-f]+$/i;\nvar RGB_COLOR_REGEX = /^rgba?\\((.*)\\)$/;\nvar HEX_STARTING_REGEX = /[^#]/gi;\nvar _RGBColor = class _RGBColor extends Color {\n  constructor(red, green, blue, alpha) {\n    super();\n    this.red = red;\n    this.green = green;\n    this.blue = blue;\n    this.alpha = alpha;\n  }\n  static parse(value) {\n    let colors = [];\n    if (HEX_COLOR_REGEX.test(value) && [4, 5, 7, 9].includes(value.length)) {\n      const values = (value.length < 6 ? value.replace(HEX_STARTING_REGEX, \"$&$&\") : value).slice(1).split(\"\");\n      while (values.length > 0) {\n        colors.push(parseInt(values.splice(0, 2).join(\"\"), 16));\n      }\n      colors[3] = colors[3] !== void 0 ? colors[3] / 255 : void 0;\n    }\n    const match = value.match(RGB_COLOR_REGEX);\n    if (match?.[1]) {\n      colors = match[1].split(\",\").map((value2) => Number(value2.trim())).map((num, i) => clampValue(num, 0, i < 3 ? 255 : 1));\n    }\n    return colors.length < 3 ? void 0 : new _RGBColor(colors[0], colors[1], colors[2], colors[3] ?? 1);\n  }\n  toString(format) {\n    switch (format) {\n      case \"hex\":\n        return \"#\" + (this.red.toString(16).padStart(2, \"0\") + this.green.toString(16).padStart(2, \"0\") + this.blue.toString(16).padStart(2, \"0\")).toUpperCase();\n      case \"hexa\":\n        return \"#\" + (this.red.toString(16).padStart(2, \"0\") + this.green.toString(16).padStart(2, \"0\") + this.blue.toString(16).padStart(2, \"0\") + Math.round(this.alpha * 255).toString(16).padStart(2, \"0\")).toUpperCase();\n      case \"rgb\":\n        return `rgb(${this.red}, ${this.green}, ${this.blue})`;\n      case \"css\":\n      case \"rgba\":\n        return `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`;\n      case \"hsl\":\n        return this.toHSL().toString(\"hsl\");\n      case \"hsb\":\n        return this.toHSB().toString(\"hsb\");\n      default:\n        return this.toFormat(format).toString(format);\n    }\n  }\n  toFormat(format) {\n    switch (format) {\n      case \"rgba\":\n        return this;\n      case \"hsba\":\n        return this.toHSB();\n      case \"hsla\":\n        return this.toHSL();\n      default:\n        throw new Error(\"Unsupported color conversion: rgb -> \" + format);\n    }\n  }\n  toHexInt() {\n    return this.red << 16 | this.green << 8 | this.blue;\n  }\n  /**\n   * Converts an RGB color value to HSB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.\n   * @returns An HSBColor object.\n   */\n  toHSB() {\n    const red = this.red / 255;\n    const green = this.green / 255;\n    const blue = this.blue / 255;\n    const min = Math.min(red, green, blue);\n    const brightness = Math.max(red, green, blue);\n    const chroma = brightness - min;\n    const saturation = brightness === 0 ? 0 : chroma / brightness;\n    let hue = 0;\n    if (chroma !== 0) {\n      switch (brightness) {\n        case red:\n          hue = (green - blue) / chroma + (green < blue ? 6 : 0);\n          break;\n        case green:\n          hue = (blue - red) / chroma + 2;\n          break;\n        case blue:\n          hue = (red - green) / chroma + 4;\n          break;\n      }\n      hue /= 6;\n    }\n    return new HSBColor(\n      toFixedNumber(hue * 360, 2),\n      toFixedNumber(saturation * 100, 2),\n      toFixedNumber(brightness * 100, 2),\n      toFixedNumber(this.alpha, 2)\n    );\n  }\n  /**\n   * Converts an RGB color value to HSL.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.\n   * @returns An HSLColor object.\n   */\n  toHSL() {\n    const red = this.red / 255;\n    const green = this.green / 255;\n    const blue = this.blue / 255;\n    const min = Math.min(red, green, blue);\n    const max = Math.max(red, green, blue);\n    const lightness = (max + min) / 2;\n    const chroma = max - min;\n    let hue = -1;\n    let saturation = -1;\n    if (chroma === 0) {\n      hue = saturation = 0;\n    } else {\n      saturation = chroma / (lightness < 0.5 ? max + min : 2 - max - min);\n      switch (max) {\n        case red:\n          hue = (green - blue) / chroma + (green < blue ? 6 : 0);\n          break;\n        case green:\n          hue = (blue - red) / chroma + 2;\n          break;\n        case blue:\n          hue = (red - green) / chroma + 4;\n          break;\n      }\n      hue /= 6;\n    }\n    return new HSLColor(\n      toFixedNumber(hue * 360, 2),\n      toFixedNumber(saturation * 100, 2),\n      toFixedNumber(lightness * 100, 2),\n      toFixedNumber(this.alpha, 2)\n    );\n  }\n  clone() {\n    return new _RGBColor(this.red, this.green, this.blue, this.alpha);\n  }\n  getChannelFormatOptions(channel) {\n    switch (channel) {\n      case \"red\":\n      case \"green\":\n      case \"blue\":\n        return { style: \"decimal\" };\n      case \"alpha\":\n        return { style: \"percent\" };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  formatChannelValue(channel, locale) {\n    let options = this.getChannelFormatOptions(channel);\n    let value = this.getChannelValue(channel);\n    return new Intl.NumberFormat(locale, options).format(value);\n  }\n  getChannelRange(channel) {\n    switch (channel) {\n      case \"red\":\n      case \"green\":\n      case \"blue\":\n        return { minValue: 0, maxValue: 255, step: 1, pageSize: 17 };\n      case \"alpha\":\n        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  toJSON() {\n    return { r: this.red, g: this.green, b: this.blue, a: this.alpha };\n  }\n  getFormat() {\n    return \"rgba\";\n  }\n  getChannels() {\n    return _RGBColor.colorChannels;\n  }\n};\n__publicField(_RGBColor, \"colorChannels\", [\"red\", \"green\", \"blue\"]);\nvar RGBColor = _RGBColor;\n\n// src/hsl-color.ts\nvar HSL_REGEX = /hsl\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%)\\)|hsla\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d(.\\d+)?)\\)/;\nvar _HSLColor = class _HSLColor extends Color {\n  constructor(hue, saturation, lightness, alpha) {\n    super();\n    this.hue = hue;\n    this.saturation = saturation;\n    this.lightness = lightness;\n    this.alpha = alpha;\n  }\n  static parse(value) {\n    let m;\n    if (m = value.match(HSL_REGEX)) {\n      const [h, s, l, a] = (m[1] ?? m[2]).split(\",\").map((n) => Number(n.trim().replace(\"%\", \"\")));\n      return new _HSLColor(mod(h, 360), clampValue(s, 0, 100), clampValue(l, 0, 100), clampValue(a ?? 1, 0, 1));\n    }\n  }\n  toString(format) {\n    switch (format) {\n      case \"hex\":\n        return this.toRGB().toString(\"hex\");\n      case \"hexa\":\n        return this.toRGB().toString(\"hexa\");\n      case \"hsl\":\n        return `hsl(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.lightness, 2)}%)`;\n      case \"css\":\n      case \"hsla\":\n        return `hsla(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.lightness, 2)}%, ${this.alpha})`;\n      case \"hsb\":\n        return this.toHSB().toString(\"hsb\");\n      case \"rgb\":\n        return this.toRGB().toString(\"rgb\");\n      default:\n        return this.toFormat(format).toString(format);\n    }\n  }\n  toFormat(format) {\n    switch (format) {\n      case \"hsla\":\n        return this;\n      case \"hsba\":\n        return this.toHSB();\n      case \"rgba\":\n        return this.toRGB();\n      default:\n        throw new Error(\"Unsupported color conversion: hsl -> \" + format);\n    }\n  }\n  /**\n   * Converts a HSL color to HSB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_HSV.\n   * @returns An HSBColor object.\n   */\n  toHSB() {\n    let saturation = this.saturation / 100;\n    let lightness = this.lightness / 100;\n    let brightness = lightness + saturation * Math.min(lightness, 1 - lightness);\n    saturation = brightness === 0 ? 0 : 2 * (1 - lightness / brightness);\n    return new HSBColor(\n      toFixedNumber(this.hue, 2),\n      toFixedNumber(saturation * 100, 2),\n      toFixedNumber(brightness * 100, 2),\n      toFixedNumber(this.alpha, 2)\n    );\n  }\n  /**\n   * Converts a HSL color to RGB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative.\n   * @returns An RGBColor object.\n   */\n  toRGB() {\n    let hue = this.hue;\n    let saturation = this.saturation / 100;\n    let lightness = this.lightness / 100;\n    let a = saturation * Math.min(lightness, 1 - lightness);\n    let fn = (n, k = (n + hue / 30) % 12) => lightness - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n    return new RGBColor(\n      Math.round(fn(0) * 255),\n      Math.round(fn(8) * 255),\n      Math.round(fn(4) * 255),\n      toFixedNumber(this.alpha, 2)\n    );\n  }\n  clone() {\n    return new _HSLColor(this.hue, this.saturation, this.lightness, this.alpha);\n  }\n  getChannelFormatOptions(channel) {\n    switch (channel) {\n      case \"hue\":\n        return { style: \"unit\", unit: \"degree\", unitDisplay: \"narrow\" };\n      case \"saturation\":\n      case \"lightness\":\n      case \"alpha\":\n        return { style: \"percent\" };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  formatChannelValue(channel, locale) {\n    let options = this.getChannelFormatOptions(channel);\n    let value = this.getChannelValue(channel);\n    if (channel === \"saturation\" || channel === \"lightness\") {\n      value /= 100;\n    }\n    return new Intl.NumberFormat(locale, options).format(value);\n  }\n  getChannelRange(channel) {\n    switch (channel) {\n      case \"hue\":\n        return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 };\n      case \"saturation\":\n      case \"lightness\":\n        return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 };\n      case \"alpha\":\n        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  toJSON() {\n    return { h: this.hue, s: this.saturation, l: this.lightness, a: this.alpha };\n  }\n  getFormat() {\n    return \"hsla\";\n  }\n  getChannels() {\n    return _HSLColor.colorChannels;\n  }\n};\n__publicField(_HSLColor, \"colorChannels\", [\"hue\", \"saturation\", \"lightness\"]);\nvar HSLColor = _HSLColor;\n\n// src/hsb-color.ts\nvar HSB_REGEX = /hsb\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%)\\)|hsba\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d(.\\d+)?)\\)/;\nvar _HSBColor = class _HSBColor extends Color {\n  constructor(hue, saturation, brightness, alpha) {\n    super();\n    this.hue = hue;\n    this.saturation = saturation;\n    this.brightness = brightness;\n    this.alpha = alpha;\n  }\n  static parse(value) {\n    let m;\n    if (m = value.match(HSB_REGEX)) {\n      const [h, s, b, a] = (m[1] ?? m[2]).split(\",\").map((n) => Number(n.trim().replace(\"%\", \"\")));\n      return new _HSBColor(mod(h, 360), clampValue(s, 0, 100), clampValue(b, 0, 100), clampValue(a ?? 1, 0, 1));\n    }\n  }\n  toString(format) {\n    switch (format) {\n      case \"css\":\n        return this.toHSL().toString(\"css\");\n      case \"hex\":\n        return this.toRGB().toString(\"hex\");\n      case \"hexa\":\n        return this.toRGB().toString(\"hexa\");\n      case \"hsb\":\n        return `hsb(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.brightness, 2)}%)`;\n      case \"hsba\":\n        return `hsba(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.brightness, 2)}%, ${this.alpha})`;\n      case \"hsl\":\n        return this.toHSL().toString(\"hsl\");\n      case \"rgb\":\n        return this.toRGB().toString(\"rgb\");\n      default:\n        return this.toFormat(format).toString(format);\n    }\n  }\n  toFormat(format) {\n    switch (format) {\n      case \"hsba\":\n        return this;\n      case \"hsla\":\n        return this.toHSL();\n      case \"rgba\":\n        return this.toRGB();\n      default:\n        throw new Error(\"Unsupported color conversion: hsb -> \" + format);\n    }\n  }\n  /**\n   * Converts a HSB color to HSL.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_HSL.\n   * @returns An HSLColor object.\n   */\n  toHSL() {\n    let saturation = this.saturation / 100;\n    let brightness = this.brightness / 100;\n    let lightness = brightness * (1 - saturation / 2);\n    saturation = lightness === 0 || lightness === 1 ? 0 : (brightness - lightness) / Math.min(lightness, 1 - lightness);\n    return new HSLColor(\n      toFixedNumber(this.hue, 2),\n      toFixedNumber(saturation * 100, 2),\n      toFixedNumber(lightness * 100, 2),\n      toFixedNumber(this.alpha, 2)\n    );\n  }\n  /**\n   * Converts a HSV color value to RGB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB_alternative.\n   * @returns An RGBColor object.\n   */\n  toRGB() {\n    let hue = this.hue;\n    let saturation = this.saturation / 100;\n    let brightness = this.brightness / 100;\n    let fn = (n, k = (n + hue / 60) % 6) => brightness - saturation * brightness * Math.max(Math.min(k, 4 - k, 1), 0);\n    return new RGBColor(\n      Math.round(fn(5) * 255),\n      Math.round(fn(3) * 255),\n      Math.round(fn(1) * 255),\n      toFixedNumber(this.alpha, 2)\n    );\n  }\n  clone() {\n    return new _HSBColor(this.hue, this.saturation, this.brightness, this.alpha);\n  }\n  getChannelFormatOptions(channel) {\n    switch (channel) {\n      case \"hue\":\n        return { style: \"unit\", unit: \"degree\", unitDisplay: \"narrow\" };\n      case \"saturation\":\n      case \"brightness\":\n      case \"alpha\":\n        return { style: \"percent\" };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  formatChannelValue(channel, locale) {\n    let options = this.getChannelFormatOptions(channel);\n    let value = this.getChannelValue(channel);\n    if (channel === \"saturation\" || channel === \"brightness\") {\n      value /= 100;\n    }\n    return new Intl.NumberFormat(locale, options).format(value);\n  }\n  getChannelRange(channel) {\n    switch (channel) {\n      case \"hue\":\n        return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 };\n      case \"saturation\":\n      case \"brightness\":\n        return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 };\n      case \"alpha\":\n        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  toJSON() {\n    return { h: this.hue, s: this.saturation, b: this.brightness, a: this.alpha };\n  }\n  getFormat() {\n    return \"hsba\";\n  }\n  getChannels() {\n    return _HSBColor.colorChannels;\n  }\n};\n__publicField(_HSBColor, \"colorChannels\", [\"hue\", \"saturation\", \"brightness\"]);\nvar HSBColor = _HSBColor;\n\n// src/native-color.ts\nvar nativeColors = \"aliceblue:f0f8ff,antiquewhite:faebd7,aqua:00ffff,aquamarine:7fffd4,azure:f0ffff,beige:f5f5dc,bisque:ffe4c4,black:000000,blanchedalmond:ffebcd,blue:0000ff,blueviolet:8a2be2,brown:a52a2a,burlywood:deb887,cadetblue:5f9ea0,chartreuse:7fff00,chocolate:d2691e,coral:ff7f50,cornflowerblue:6495ed,cornsilk:fff8dc,crimson:dc143c,cyan:00ffff,darkblue:00008b,darkcyan:008b8b,darkgoldenrod:b8860b,darkgray:a9a9a9,darkgreen:006400,darkkhaki:bdb76b,darkmagenta:8b008b,darkolivegreen:556b2f,darkorange:ff8c00,darkorchid:9932cc,darkred:8b0000,darksalmon:e9967a,darkseagreen:8fbc8f,darkslateblue:483d8b,darkslategray:2f4f4f,darkturquoise:00ced1,darkviolet:9400d3,deeppink:ff1493,deepskyblue:00bfff,dimgray:696969,dodgerblue:1e90ff,firebrick:b22222,floralwhite:fffaf0,forestgreen:228b22,fuchsia:ff00ff,gainsboro:dcdcdc,ghostwhite:f8f8ff,gold:ffd700,goldenrod:daa520,gray:808080,green:008000,greenyellow:adff2f,honeydew:f0fff0,hotpink:ff69b4,indianred:cd5c5c,indigo:4b0082,ivory:fffff0,khaki:f0e68c,lavender:e6e6fa,lavenderblush:fff0f5,lawngreen:7cfc00,lemonchiffon:fffacd,lightblue:add8e6,lightcoral:f08080,lightcyan:e0ffff,lightgoldenrodyellow:fafad2,lightgrey:d3d3d3,lightgreen:90ee90,lightpink:ffb6c1,lightsalmon:ffa07a,lightseagreen:20b2aa,lightskyblue:87cefa,lightslategray:778899,lightsteelblue:b0c4de,lightyellow:ffffe0,lime:00ff00,limegreen:32cd32,linen:faf0e6,magenta:ff00ff,maroon:800000,mediumaquamarine:66cdaa,mediumblue:0000cd,mediumorchid:ba55d3,mediumpurple:9370d8,mediumseagreen:3cb371,mediumslateblue:7b68ee,mediumspringgreen:00fa9a,mediumturquoise:48d1cc,mediumvioletred:c71585,midnightblue:191970,mintcream:f5fffa,mistyrose:ffe4e1,moccasin:ffe4b5,navajowhite:ffdead,navy:000080,oldlace:fdf5e6,olive:808000,olivedrab:6b8e23,orange:ffa500,orangered:ff4500,orchid:da70d6,palegoldenrod:eee8aa,palegreen:98fb98,paleturquoise:afeeee,palevioletred:d87093,papayawhip:ffefd5,peachpuff:ffdab9,peru:cd853f,pink:ffc0cb,plum:dda0dd,powderblue:b0e0e6,purple:800080,rebeccapurple:663399,red:ff0000,rosybrown:bc8f8f,royalblue:4169e1,saddlebrown:8b4513,salmon:fa8072,sandybrown:f4a460,seagreen:2e8b57,seashell:fff5ee,sienna:a0522d,silver:c0c0c0,skyblue:87ceeb,slateblue:6a5acd,slategray:708090,snow:fffafa,springgreen:00ff7f,steelblue:4682b4,tan:d2b48c,teal:008080,thistle:d8bfd8,tomato:ff6347,turquoise:40e0d0,violet:ee82ee,wheat:f5deb3,white:ffffff,whitesmoke:f5f5f5,yellow:ffff00,yellowgreen:9acd32\";\nvar makeMap = (str) => {\n  const map = /* @__PURE__ */ new Map();\n  const list = str.split(\",\");\n  for (let i = 0; i < list.length; i++) {\n    const [key, val] = list[i].split(\":\");\n    map.set(key, `#${val}`);\n    if (key.includes(\"gray\")) map.set(key.replace(\"gray\", \"grey\"), `#${val}`);\n  }\n  return map;\n};\nvar nativeColorMap = makeMap(nativeColors);\n\n// src/parse-color.ts\nvar parseColor = (value) => {\n  if (nativeColorMap.has(value)) {\n    return parseColor(nativeColorMap.get(value));\n  }\n  const result = RGBColor.parse(value) || HSBColor.parse(value) || HSLColor.parse(value);\n  if (!result) {\n    const error = new Error(\"Invalid color value: \" + value);\n    Error.captureStackTrace?.(error, parseColor);\n    throw error;\n  }\n  return result;\n};\nvar normalizeColor = (v) => {\n  return typeof v === \"string\" ? parseColor(v) : v;\n};\n\nexport { Color, getColorAreaGradient, normalizeColor, parseColor };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}