{"ast":null,"code":"import _objectSpread from \"C:/Users/JAMES/cerebras-1/CerebrasApp/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { createAnatomy } from '@zag-js/anatomy';\nimport { setRafTimeout, setRafInterval, clampValue, createSplitProps, match, isObject } from '@zag-js/utils';\nimport { createMachine, memo } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/timer.anatomy.ts\nvar anatomy = createAnatomy(\"timer\").parts(\"root\", \"area\", \"control\", \"item\", \"itemValue\", \"itemLabel\", \"actionTrigger\", \"separator\");\nvar parts = anatomy.build();\n\n// src/timer.dom.ts\nvar getRootId = ctx => {\n  var _ctx$ids$root, _ctx$ids;\n  return (_ctx$ids$root = (_ctx$ids = ctx.ids) === null || _ctx$ids === void 0 ? void 0 : _ctx$ids.root) !== null && _ctx$ids$root !== void 0 ? _ctx$ids$root : \"timer:\".concat(ctx.id, \":root\");\n};\nvar getAreaId = ctx => {\n  var _ctx$ids$area, _ctx$ids2;\n  return (_ctx$ids$area = (_ctx$ids2 = ctx.ids) === null || _ctx$ids2 === void 0 ? void 0 : _ctx$ids2.area) !== null && _ctx$ids$area !== void 0 ? _ctx$ids$area : \"timer:\".concat(ctx.id, \":area\");\n};\n\n// src/timer.connect.ts\nvar validActions = /* @__PURE__ */new Set([\"start\", \"pause\", \"resume\", \"reset\", \"restart\"]);\nfunction connect(service, normalize) {\n  const {\n    state,\n    send,\n    computed,\n    scope\n  } = service;\n  const running = state.matches(\"running\");\n  const paused = state.matches(\"paused\");\n  const time = computed(\"time\");\n  const formattedTime = computed(\"formattedTime\");\n  const progressPercent = computed(\"progressPercent\");\n  return {\n    running,\n    paused,\n    time,\n    formattedTime,\n    progressPercent,\n    start() {\n      send({\n        type: \"START\"\n      });\n    },\n    pause() {\n      send({\n        type: \"PAUSE\"\n      });\n    },\n    resume() {\n      send({\n        type: \"RESUME\"\n      });\n    },\n    reset() {\n      send({\n        type: \"RESET\"\n      });\n    },\n    restart() {\n      send({\n        type: \"RESTART\"\n      });\n    },\n    getRootProps() {\n      return normalize.element(_objectSpread({\n        id: getRootId(scope)\n      }, parts.root.attrs));\n    },\n    getAreaProps() {\n      return normalize.element(_objectSpread({\n        role: \"timer\",\n        id: getAreaId(scope),\n        \"aria-label\": \"\".concat(time.days, \" days \").concat(formattedTime.hours, \":\").concat(formattedTime.minutes, \":\").concat(formattedTime.seconds),\n        \"aria-atomic\": true\n      }, parts.area.attrs));\n    },\n    getControlProps() {\n      return normalize.element(_objectSpread({}, parts.control.attrs));\n    },\n    getItemProps(props2) {\n      const value = time[props2.type];\n      return normalize.element(_objectSpread(_objectSpread({}, parts.item.attrs), {}, {\n        \"data-type\": props2.type,\n        style: {\n          \"--value\": value\n        }\n      }));\n    },\n    getItemLabelProps(props2) {\n      return normalize.element(_objectSpread(_objectSpread({}, parts.itemLabel.attrs), {}, {\n        \"data-type\": props2.type\n      }));\n    },\n    getItemValueProps(props2) {\n      return normalize.element(_objectSpread(_objectSpread({}, parts.itemValue.attrs), {}, {\n        \"data-type\": props2.type\n      }));\n    },\n    getSeparatorProps() {\n      return normalize.element(_objectSpread({\n        \"aria-hidden\": true\n      }, parts.separator.attrs));\n    },\n    getActionTriggerProps(props2) {\n      if (!validActions.has(props2.action)) {\n        throw new Error(\"[zag-js] Invalid action: \".concat(props2.action, \". Must be one of: \").concat(Array.from(validActions).join(\", \")));\n      }\n      return normalize.button(_objectSpread(_objectSpread({}, parts.actionTrigger.attrs), {}, {\n        hidden: match(props2.action, {\n          start: () => running || paused,\n          pause: () => !running,\n          reset: () => !running && !paused,\n          resume: () => !paused,\n          restart: () => false\n        }),\n        type: \"button\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: props2.action.toUpperCase()\n          });\n        }\n      }));\n    }\n  };\n}\nvar machine = createMachine({\n  props(_ref) {\n    let {\n      props: props2\n    } = _ref;\n    validateProps(props2);\n    return _objectSpread({\n      interval: 1e3,\n      startMs: 0\n    }, props2);\n  },\n  initialState(_ref2) {\n    let {\n      prop\n    } = _ref2;\n    return prop(\"autoStart\") ? \"running\" : \"idle\";\n  },\n  context(_ref3) {\n    let {\n      prop,\n      bindable\n    } = _ref3;\n    return {\n      currentMs: bindable(() => ({\n        defaultValue: prop(\"startMs\")\n      }))\n    };\n  },\n  watch(_ref4) {\n    let {\n      track,\n      send,\n      prop\n    } = _ref4;\n    track([() => prop(\"startMs\")], () => {\n      send({\n        type: \"RESTART\"\n      });\n    });\n  },\n  on: {\n    RESTART: {\n      target: \"running:temp\",\n      actions: [\"resetTime\"]\n    }\n  },\n  computed: {\n    time: _ref5 => {\n      let {\n        context\n      } = _ref5;\n      return msToTime(context.get(\"currentMs\"));\n    },\n    formattedTime: _ref6 => {\n      let {\n        computed\n      } = _ref6;\n      return formatTime(computed(\"time\"));\n    },\n    progressPercent: memo(_ref7 => {\n      let {\n        context,\n        prop\n      } = _ref7;\n      return [context.get(\"currentMs\"), prop(\"targetMs\"), prop(\"startMs\"), prop(\"countdown\")];\n    }, _ref8 => {\n      let [currentMs, targetMs = 0, startMs, countdown] = _ref8;\n      const percent = countdown ? toPercent(currentMs, targetMs, startMs) : toPercent(currentMs, startMs, targetMs);\n      return clampValue(percent, 0, 1);\n    })\n  },\n  states: {\n    idle: {\n      on: {\n        START: {\n          target: \"running\"\n        },\n        RESET: {\n          actions: [\"resetTime\"]\n        }\n      }\n    },\n    \"running:temp\": {\n      effects: [\"waitForNextTick\"],\n      on: {\n        CONTINUE: {\n          target: \"running\"\n        }\n      }\n    },\n    running: {\n      effects: [\"keepTicking\"],\n      on: {\n        PAUSE: {\n          target: \"paused\"\n        },\n        TICK: [{\n          target: \"idle\",\n          guard: \"hasReachedTarget\",\n          actions: [\"invokeOnComplete\"]\n        }, {\n          actions: [\"updateTime\", \"invokeOnTick\"]\n        }],\n        RESET: {\n          actions: [\"resetTime\"]\n        }\n      }\n    },\n    paused: {\n      on: {\n        RESUME: {\n          target: \"running\"\n        },\n        RESET: {\n          target: \"idle\",\n          actions: [\"resetTime\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    effects: {\n      keepTicking(_ref9) {\n        let {\n          prop,\n          send\n        } = _ref9;\n        return setRafInterval(_ref0 => {\n          let {\n            deltaMs\n          } = _ref0;\n          send({\n            type: \"TICK\",\n            deltaMs\n          });\n        }, prop(\"interval\"));\n      },\n      waitForNextTick(_ref1) {\n        let {\n          send\n        } = _ref1;\n        return setRafTimeout(() => {\n          send({\n            type: \"CONTINUE\"\n          });\n        }, 0);\n      }\n    },\n    actions: {\n      updateTime(_ref10) {\n        let {\n          context,\n          prop,\n          event\n        } = _ref10;\n        const sign = prop(\"countdown\") ? -1 : 1;\n        const deltaMs = roundToInterval(event.deltaMs, prop(\"interval\"));\n        context.set(\"currentMs\", prev => {\n          const newValue = prev + sign * deltaMs;\n          let targetMs = prop(\"targetMs\");\n          if (targetMs == null && prop(\"countdown\")) targetMs = 0;\n          if (prop(\"countdown\") && targetMs != null) {\n            return Math.max(newValue, targetMs);\n          } else if (!prop(\"countdown\") && targetMs != null) {\n            return Math.min(newValue, targetMs);\n          }\n          return newValue;\n        });\n      },\n      resetTime(_ref11) {\n        var _prop;\n        let {\n          context,\n          prop\n        } = _ref11;\n        let targetMs = prop(\"targetMs\");\n        if (targetMs == null && prop(\"countdown\")) targetMs = 0;\n        context.set(\"currentMs\", (_prop = prop(\"startMs\")) !== null && _prop !== void 0 ? _prop : 0);\n      },\n      invokeOnTick(_ref12) {\n        var _prop2;\n        let {\n          context,\n          prop,\n          computed\n        } = _ref12;\n        (_prop2 = prop(\"onTick\")) === null || _prop2 === void 0 || _prop2({\n          value: context.get(\"currentMs\"),\n          time: computed(\"time\"),\n          formattedTime: computed(\"formattedTime\")\n        });\n      },\n      invokeOnComplete(_ref13) {\n        var _prop3;\n        let {\n          prop\n        } = _ref13;\n        (_prop3 = prop(\"onComplete\")) === null || _prop3 === void 0 || _prop3();\n      }\n    },\n    guards: {\n      hasReachedTarget: _ref14 => {\n        let {\n          context,\n          prop\n        } = _ref14;\n        let targetMs = prop(\"targetMs\");\n        if (targetMs == null && prop(\"countdown\")) targetMs = 0;\n        if (targetMs == null) return false;\n        const currentMs = context.get(\"currentMs\");\n        return prop(\"countdown\") ? currentMs <= targetMs : currentMs >= targetMs;\n      }\n    }\n  }\n});\nfunction msToTime(ms) {\n  const time = Math.max(0, ms);\n  const milliseconds = time % 1e3;\n  const seconds = Math.floor(time / 1e3) % 60;\n  const minutes = Math.floor(time / (1e3 * 60)) % 60;\n  const hours = Math.floor(time / (1e3 * 60 * 60)) % 24;\n  const days = Math.floor(time / (1e3 * 60 * 60 * 24));\n  return {\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds\n  };\n}\nfunction toPercent(value, minValue, maxValue) {\n  const range = maxValue - minValue;\n  if (range === 0) return 0;\n  return (value - minValue) / range;\n}\nfunction padStart(num) {\n  let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  return num.toString().padStart(size, \"0\");\n}\nfunction roundToInterval(value, interval) {\n  return Math.floor(value / interval) * interval;\n}\nfunction formatTime(time) {\n  const {\n    days,\n    hours,\n    minutes,\n    seconds\n  } = time;\n  return {\n    days: padStart(days),\n    hours: padStart(hours),\n    minutes: padStart(minutes),\n    seconds: padStart(seconds),\n    milliseconds: padStart(time.milliseconds, 3)\n  };\n}\nfunction validateProps(props2) {\n  const {\n    startMs,\n    targetMs,\n    countdown,\n    interval\n  } = props2;\n  if (interval != null && (typeof interval !== \"number\" || interval <= 0)) {\n    throw new Error(\"[timer] Invalid interval: \".concat(interval, \". Must be a positive number.\"));\n  }\n  if (startMs != null && (typeof startMs !== \"number\" || startMs < 0)) {\n    throw new Error(\"[timer] Invalid startMs: \".concat(startMs, \". Must be a non-negative number.\"));\n  }\n  if (targetMs != null && (typeof targetMs !== \"number\" || targetMs < 0)) {\n    throw new Error(\"[timer] Invalid targetMs: \".concat(targetMs, \". Must be a non-negative number.\"));\n  }\n  if (countdown && startMs != null && targetMs != null) {\n    if (startMs <= targetMs) {\n      throw new Error(\"[timer] Invalid countdown configuration: startMs (\".concat(startMs, \") must be greater than targetMs (\").concat(targetMs, \").\"));\n    }\n  }\n  if (!countdown && startMs != null && targetMs != null) {\n    if (startMs >= targetMs) {\n      throw new Error(\"[timer] Invalid stopwatch configuration: startMs (\".concat(startMs, \") must be less than targetMs (\").concat(targetMs, \").\"));\n    }\n  }\n  if (countdown && targetMs == null && startMs != null && startMs <= 0) {\n    throw new Error(\"[timer] Invalid countdown configuration: startMs (\".concat(startMs, \") must be greater than 0 when no targetMs is provided.\"));\n  }\n}\nvar segments = /* @__PURE__ */new Set([\"days\", \"hours\", \"minutes\", \"seconds\"]);\nfunction isTimeSegment(date) {\n  return isObject(date) && Object.keys(date).some(key => segments.has(key));\n}\nfunction parse(date) {\n  if (typeof date === \"string\") {\n    return new Date(date).getTime();\n  }\n  if (isTimeSegment(date)) {\n    const {\n      days = 0,\n      hours = 0,\n      minutes = 0,\n      seconds = 0,\n      milliseconds = 0\n    } = date;\n    const value = (days * 24 * 60 * 60 + hours * 60 * 60 + minutes * 60 + seconds) * 1e3;\n    return value + milliseconds;\n  }\n  throw new Error(\"Invalid date\");\n}\nvar props = createProps()([\"autoStart\", \"countdown\", \"getRootNode\", \"id\", \"ids\", \"interval\", \"onComplete\", \"onTick\", \"startMs\", \"targetMs\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, parse, props, splitProps };","map":{"version":3,"names":["createAnatomy","setRafTimeout","setRafInterval","clampValue","createSplitProps","match","isObject","createMachine","memo","createProps","anatomy","parts","build","getRootId","ctx","_ctx$ids$root","_ctx$ids","ids","root","concat","id","getAreaId","_ctx$ids$area","_ctx$ids2","area","validActions","Set","connect","service","normalize","state","send","computed","scope","running","matches","paused","time","formattedTime","progressPercent","start","type","pause","resume","reset","restart","getRootProps","element","_objectSpread","attrs","getAreaProps","role","days","hours","minutes","seconds","getControlProps","control","getItemProps","props2","value","item","style","getItemLabelProps","itemLabel","getItemValueProps","itemValue","getSeparatorProps","separator","getActionTriggerProps","has","action","Error","Array","from","join","button","actionTrigger","hidden","onClick","event","defaultPrevented","toUpperCase","machine","props","_ref","validateProps","interval","startMs","initialState","_ref2","prop","context","_ref3","bindable","currentMs","defaultValue","watch","_ref4","track","on","RESTART","target","actions","_ref5","msToTime","get","_ref6","formatTime","_ref7","_ref8","targetMs","countdown","percent","toPercent","states","idle","START","RESET","effects","CONTINUE","PAUSE","TICK","guard","RESUME","implementations","keepTicking","_ref9","_ref0","deltaMs","waitForNextTick","_ref1","updateTime","_ref10","sign","roundToInterval","set","prev","newValue","Math","max","min","resetTime","_ref11","_prop","invokeOnTick","_ref12","_prop2","invokeOnComplete","_ref13","_prop3","guards","hasReachedTarget","_ref14","ms","milliseconds","floor","minValue","maxValue","range","padStart","num","size","arguments","length","undefined","toString","segments","isTimeSegment","date","Object","keys","some","key","parse","Date","getTime","splitProps"],"sources":["C:/Users/JAMES/cerebras-1/CerebrasApp/frontend/node_modules/@zag-js/timer/dist/index.mjs"],"sourcesContent":["import { createAnatomy } from '@zag-js/anatomy';\nimport { setRafTimeout, setRafInterval, clampValue, createSplitProps, match, isObject } from '@zag-js/utils';\nimport { createMachine, memo } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/timer.anatomy.ts\nvar anatomy = createAnatomy(\"timer\").parts(\n  \"root\",\n  \"area\",\n  \"control\",\n  \"item\",\n  \"itemValue\",\n  \"itemLabel\",\n  \"actionTrigger\",\n  \"separator\"\n);\nvar parts = anatomy.build();\n\n// src/timer.dom.ts\nvar getRootId = (ctx) => ctx.ids?.root ?? `timer:${ctx.id}:root`;\nvar getAreaId = (ctx) => ctx.ids?.area ?? `timer:${ctx.id}:area`;\n\n// src/timer.connect.ts\nvar validActions = /* @__PURE__ */ new Set([\"start\", \"pause\", \"resume\", \"reset\", \"restart\"]);\nfunction connect(service, normalize) {\n  const { state, send, computed, scope } = service;\n  const running = state.matches(\"running\");\n  const paused = state.matches(\"paused\");\n  const time = computed(\"time\");\n  const formattedTime = computed(\"formattedTime\");\n  const progressPercent = computed(\"progressPercent\");\n  return {\n    running,\n    paused,\n    time,\n    formattedTime,\n    progressPercent,\n    start() {\n      send({ type: \"START\" });\n    },\n    pause() {\n      send({ type: \"PAUSE\" });\n    },\n    resume() {\n      send({ type: \"RESUME\" });\n    },\n    reset() {\n      send({ type: \"RESET\" });\n    },\n    restart() {\n      send({ type: \"RESTART\" });\n    },\n    getRootProps() {\n      return normalize.element({\n        id: getRootId(scope),\n        ...parts.root.attrs\n      });\n    },\n    getAreaProps() {\n      return normalize.element({\n        role: \"timer\",\n        id: getAreaId(scope),\n        \"aria-label\": `${time.days} days ${formattedTime.hours}:${formattedTime.minutes}:${formattedTime.seconds}`,\n        \"aria-atomic\": true,\n        ...parts.area.attrs\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs\n      });\n    },\n    getItemProps(props2) {\n      const value = time[props2.type];\n      return normalize.element({\n        ...parts.item.attrs,\n        \"data-type\": props2.type,\n        style: {\n          \"--value\": value\n        }\n      });\n    },\n    getItemLabelProps(props2) {\n      return normalize.element({\n        ...parts.itemLabel.attrs,\n        \"data-type\": props2.type\n      });\n    },\n    getItemValueProps(props2) {\n      return normalize.element({\n        ...parts.itemValue.attrs,\n        \"data-type\": props2.type\n      });\n    },\n    getSeparatorProps() {\n      return normalize.element({\n        \"aria-hidden\": true,\n        ...parts.separator.attrs\n      });\n    },\n    getActionTriggerProps(props2) {\n      if (!validActions.has(props2.action)) {\n        throw new Error(\n          `[zag-js] Invalid action: ${props2.action}. Must be one of: ${Array.from(validActions).join(\", \")}`\n        );\n      }\n      return normalize.button({\n        ...parts.actionTrigger.attrs,\n        hidden: match(props2.action, {\n          start: () => running || paused,\n          pause: () => !running,\n          reset: () => !running && !paused,\n          resume: () => !paused,\n          restart: () => false\n        }),\n        type: \"button\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({ type: props2.action.toUpperCase() });\n        }\n      });\n    }\n  };\n}\nvar machine = createMachine({\n  props({ props: props2 }) {\n    validateProps(props2);\n    return {\n      interval: 1e3,\n      startMs: 0,\n      ...props2\n    };\n  },\n  initialState({ prop }) {\n    return prop(\"autoStart\") ? \"running\" : \"idle\";\n  },\n  context({ prop, bindable }) {\n    return {\n      currentMs: bindable(() => ({\n        defaultValue: prop(\"startMs\")\n      }))\n    };\n  },\n  watch({ track, send, prop }) {\n    track([() => prop(\"startMs\")], () => {\n      send({ type: \"RESTART\" });\n    });\n  },\n  on: {\n    RESTART: {\n      target: \"running:temp\",\n      actions: [\"resetTime\"]\n    }\n  },\n  computed: {\n    time: ({ context }) => msToTime(context.get(\"currentMs\")),\n    formattedTime: ({ computed }) => formatTime(computed(\"time\")),\n    progressPercent: memo(\n      ({ context, prop }) => [context.get(\"currentMs\"), prop(\"targetMs\"), prop(\"startMs\"), prop(\"countdown\")],\n      ([currentMs, targetMs = 0, startMs, countdown]) => {\n        const percent = countdown ? toPercent(currentMs, targetMs, startMs) : toPercent(currentMs, startMs, targetMs);\n        return clampValue(percent, 0, 1);\n      }\n    )\n  },\n  states: {\n    idle: {\n      on: {\n        START: {\n          target: \"running\"\n        },\n        RESET: {\n          actions: [\"resetTime\"]\n        }\n      }\n    },\n    \"running:temp\": {\n      effects: [\"waitForNextTick\"],\n      on: {\n        CONTINUE: {\n          target: \"running\"\n        }\n      }\n    },\n    running: {\n      effects: [\"keepTicking\"],\n      on: {\n        PAUSE: {\n          target: \"paused\"\n        },\n        TICK: [\n          {\n            target: \"idle\",\n            guard: \"hasReachedTarget\",\n            actions: [\"invokeOnComplete\"]\n          },\n          {\n            actions: [\"updateTime\", \"invokeOnTick\"]\n          }\n        ],\n        RESET: {\n          actions: [\"resetTime\"]\n        }\n      }\n    },\n    paused: {\n      on: {\n        RESUME: {\n          target: \"running\"\n        },\n        RESET: {\n          target: \"idle\",\n          actions: [\"resetTime\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    effects: {\n      keepTicking({ prop, send }) {\n        return setRafInterval(({ deltaMs }) => {\n          send({ type: \"TICK\", deltaMs });\n        }, prop(\"interval\"));\n      },\n      waitForNextTick({ send }) {\n        return setRafTimeout(() => {\n          send({ type: \"CONTINUE\" });\n        }, 0);\n      }\n    },\n    actions: {\n      updateTime({ context, prop, event }) {\n        const sign = prop(\"countdown\") ? -1 : 1;\n        const deltaMs = roundToInterval(event.deltaMs, prop(\"interval\"));\n        context.set(\"currentMs\", (prev) => {\n          const newValue = prev + sign * deltaMs;\n          let targetMs = prop(\"targetMs\");\n          if (targetMs == null && prop(\"countdown\")) targetMs = 0;\n          if (prop(\"countdown\") && targetMs != null) {\n            return Math.max(newValue, targetMs);\n          } else if (!prop(\"countdown\") && targetMs != null) {\n            return Math.min(newValue, targetMs);\n          }\n          return newValue;\n        });\n      },\n      resetTime({ context, prop }) {\n        let targetMs = prop(\"targetMs\");\n        if (targetMs == null && prop(\"countdown\")) targetMs = 0;\n        context.set(\"currentMs\", prop(\"startMs\") ?? 0);\n      },\n      invokeOnTick({ context, prop, computed }) {\n        prop(\"onTick\")?.({\n          value: context.get(\"currentMs\"),\n          time: computed(\"time\"),\n          formattedTime: computed(\"formattedTime\")\n        });\n      },\n      invokeOnComplete({ prop }) {\n        prop(\"onComplete\")?.();\n      }\n    },\n    guards: {\n      hasReachedTarget: ({ context, prop }) => {\n        let targetMs = prop(\"targetMs\");\n        if (targetMs == null && prop(\"countdown\")) targetMs = 0;\n        if (targetMs == null) return false;\n        const currentMs = context.get(\"currentMs\");\n        return prop(\"countdown\") ? currentMs <= targetMs : currentMs >= targetMs;\n      }\n    }\n  }\n});\nfunction msToTime(ms) {\n  const time = Math.max(0, ms);\n  const milliseconds = time % 1e3;\n  const seconds = Math.floor(time / 1e3) % 60;\n  const minutes = Math.floor(time / (1e3 * 60)) % 60;\n  const hours = Math.floor(time / (1e3 * 60 * 60)) % 24;\n  const days = Math.floor(time / (1e3 * 60 * 60 * 24));\n  return {\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds\n  };\n}\nfunction toPercent(value, minValue, maxValue) {\n  const range = maxValue - minValue;\n  if (range === 0) return 0;\n  return (value - minValue) / range;\n}\nfunction padStart(num, size = 2) {\n  return num.toString().padStart(size, \"0\");\n}\nfunction roundToInterval(value, interval) {\n  return Math.floor(value / interval) * interval;\n}\nfunction formatTime(time) {\n  const { days, hours, minutes, seconds } = time;\n  return {\n    days: padStart(days),\n    hours: padStart(hours),\n    minutes: padStart(minutes),\n    seconds: padStart(seconds),\n    milliseconds: padStart(time.milliseconds, 3)\n  };\n}\nfunction validateProps(props2) {\n  const { startMs, targetMs, countdown, interval } = props2;\n  if (interval != null && (typeof interval !== \"number\" || interval <= 0)) {\n    throw new Error(`[timer] Invalid interval: ${interval}. Must be a positive number.`);\n  }\n  if (startMs != null && (typeof startMs !== \"number\" || startMs < 0)) {\n    throw new Error(`[timer] Invalid startMs: ${startMs}. Must be a non-negative number.`);\n  }\n  if (targetMs != null && (typeof targetMs !== \"number\" || targetMs < 0)) {\n    throw new Error(`[timer] Invalid targetMs: ${targetMs}. Must be a non-negative number.`);\n  }\n  if (countdown && startMs != null && targetMs != null) {\n    if (startMs <= targetMs) {\n      throw new Error(\n        `[timer] Invalid countdown configuration: startMs (${startMs}) must be greater than targetMs (${targetMs}).`\n      );\n    }\n  }\n  if (!countdown && startMs != null && targetMs != null) {\n    if (startMs >= targetMs) {\n      throw new Error(\n        `[timer] Invalid stopwatch configuration: startMs (${startMs}) must be less than targetMs (${targetMs}).`\n      );\n    }\n  }\n  if (countdown && targetMs == null && startMs != null && startMs <= 0) {\n    throw new Error(\n      `[timer] Invalid countdown configuration: startMs (${startMs}) must be greater than 0 when no targetMs is provided.`\n    );\n  }\n}\nvar segments = /* @__PURE__ */ new Set([\"days\", \"hours\", \"minutes\", \"seconds\"]);\nfunction isTimeSegment(date) {\n  return isObject(date) && Object.keys(date).some((key) => segments.has(key));\n}\nfunction parse(date) {\n  if (typeof date === \"string\") {\n    return new Date(date).getTime();\n  }\n  if (isTimeSegment(date)) {\n    const { days = 0, hours = 0, minutes = 0, seconds = 0, milliseconds = 0 } = date;\n    const value = (days * 24 * 60 * 60 + hours * 60 * 60 + minutes * 60 + seconds) * 1e3;\n    return value + milliseconds;\n  }\n  throw new Error(\"Invalid date\");\n}\nvar props = createProps()([\n  \"autoStart\",\n  \"countdown\",\n  \"getRootNode\",\n  \"id\",\n  \"ids\",\n  \"interval\",\n  \"onComplete\",\n  \"onTick\",\n  \"startMs\",\n  \"targetMs\"\n]);\nvar splitProps = createSplitProps(props);\n\nexport { anatomy, connect, machine, parse, props, splitProps };\n"],"mappings":";AAAA,SAASA,aAAa,QAAQ,iBAAiB;AAC/C,SAASC,aAAa,EAAEC,cAAc,EAAEC,UAAU,EAAEC,gBAAgB,EAAEC,KAAK,EAAEC,QAAQ,QAAQ,eAAe;AAC5G,SAASC,aAAa,EAAEC,IAAI,QAAQ,cAAc;AAClD,SAASC,WAAW,QAAQ,eAAe;;AAE3C;AACA,IAAIC,OAAO,GAAGV,aAAa,CAAC,OAAO,CAAC,CAACW,KAAK,CACxC,MAAM,EACN,MAAM,EACN,SAAS,EACT,MAAM,EACN,WAAW,EACX,WAAW,EACX,eAAe,EACf,WACF,CAAC;AACD,IAAIA,KAAK,GAAGD,OAAO,CAACE,KAAK,CAAC,CAAC;;AAE3B;AACA,IAAIC,SAAS,GAAIC,GAAG;EAAA,IAAAC,aAAA,EAAAC,QAAA;EAAA,QAAAD,aAAA,IAAAC,QAAA,GAAKF,GAAG,CAACG,GAAG,cAAAD,QAAA,uBAAPA,QAAA,CAASE,IAAI,cAAAH,aAAA,cAAAA,aAAA,YAAAI,MAAA,CAAaL,GAAG,CAACM,EAAE;AAAA,CAAO;AAChE,IAAIC,SAAS,GAAIP,GAAG;EAAA,IAAAQ,aAAA,EAAAC,SAAA;EAAA,QAAAD,aAAA,IAAAC,SAAA,GAAKT,GAAG,CAACG,GAAG,cAAAM,SAAA,uBAAPA,SAAA,CAASC,IAAI,cAAAF,aAAA,cAAAA,aAAA,YAAAH,MAAA,CAAaL,GAAG,CAACM,EAAE;AAAA,CAAO;;AAEhE;AACA,IAAIK,YAAY,GAAG,eAAgB,IAAIC,GAAG,CAAC,CAAC,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,SAAS,CAAC,CAAC;AAC5F,SAASC,OAAOA,CAACC,OAAO,EAAEC,SAAS,EAAE;EACnC,MAAM;IAAEC,KAAK;IAAEC,IAAI;IAAEC,QAAQ;IAAEC;EAAM,CAAC,GAAGL,OAAO;EAChD,MAAMM,OAAO,GAAGJ,KAAK,CAACK,OAAO,CAAC,SAAS,CAAC;EACxC,MAAMC,MAAM,GAAGN,KAAK,CAACK,OAAO,CAAC,QAAQ,CAAC;EACtC,MAAME,IAAI,GAAGL,QAAQ,CAAC,MAAM,CAAC;EAC7B,MAAMM,aAAa,GAAGN,QAAQ,CAAC,eAAe,CAAC;EAC/C,MAAMO,eAAe,GAAGP,QAAQ,CAAC,iBAAiB,CAAC;EACnD,OAAO;IACLE,OAAO;IACPE,MAAM;IACNC,IAAI;IACJC,aAAa;IACbC,eAAe;IACfC,KAAKA,CAAA,EAAG;MACNT,IAAI,CAAC;QAAEU,IAAI,EAAE;MAAQ,CAAC,CAAC;IACzB,CAAC;IACDC,KAAKA,CAAA,EAAG;MACNX,IAAI,CAAC;QAAEU,IAAI,EAAE;MAAQ,CAAC,CAAC;IACzB,CAAC;IACDE,MAAMA,CAAA,EAAG;MACPZ,IAAI,CAAC;QAAEU,IAAI,EAAE;MAAS,CAAC,CAAC;IAC1B,CAAC;IACDG,KAAKA,CAAA,EAAG;MACNb,IAAI,CAAC;QAAEU,IAAI,EAAE;MAAQ,CAAC,CAAC;IACzB,CAAC;IACDI,OAAOA,CAAA,EAAG;MACRd,IAAI,CAAC;QAAEU,IAAI,EAAE;MAAU,CAAC,CAAC;IAC3B,CAAC;IACDK,YAAYA,CAAA,EAAG;MACb,OAAOjB,SAAS,CAACkB,OAAO,CAAAC,aAAA;QACtB5B,EAAE,EAAEP,SAAS,CAACoB,KAAK;MAAC,GACjBtB,KAAK,CAACO,IAAI,CAAC+B,KAAK,CACpB,CAAC;IACJ,CAAC;IACDC,YAAYA,CAAA,EAAG;MACb,OAAOrB,SAAS,CAACkB,OAAO,CAAAC,aAAA;QACtBG,IAAI,EAAE,OAAO;QACb/B,EAAE,EAAEC,SAAS,CAACY,KAAK,CAAC;QACpB,YAAY,KAAAd,MAAA,CAAKkB,IAAI,CAACe,IAAI,YAAAjC,MAAA,CAASmB,aAAa,CAACe,KAAK,OAAAlC,MAAA,CAAImB,aAAa,CAACgB,OAAO,OAAAnC,MAAA,CAAImB,aAAa,CAACiB,OAAO,CAAE;QAC1G,aAAa,EAAE;MAAI,GAChB5C,KAAK,CAACa,IAAI,CAACyB,KAAK,CACpB,CAAC;IACJ,CAAC;IACDO,eAAeA,CAAA,EAAG;MAChB,OAAO3B,SAAS,CAACkB,OAAO,CAAAC,aAAA,KACnBrC,KAAK,CAAC8C,OAAO,CAACR,KAAK,CACvB,CAAC;IACJ,CAAC;IACDS,YAAYA,CAACC,MAAM,EAAE;MACnB,MAAMC,KAAK,GAAGvB,IAAI,CAACsB,MAAM,CAAClB,IAAI,CAAC;MAC/B,OAAOZ,SAAS,CAACkB,OAAO,CAAAC,aAAA,CAAAA,aAAA,KACnBrC,KAAK,CAACkD,IAAI,CAACZ,KAAK;QACnB,WAAW,EAAEU,MAAM,CAAClB,IAAI;QACxBqB,KAAK,EAAE;UACL,SAAS,EAAEF;QACb;MAAC,EACF,CAAC;IACJ,CAAC;IACDG,iBAAiBA,CAACJ,MAAM,EAAE;MACxB,OAAO9B,SAAS,CAACkB,OAAO,CAAAC,aAAA,CAAAA,aAAA,KACnBrC,KAAK,CAACqD,SAAS,CAACf,KAAK;QACxB,WAAW,EAAEU,MAAM,CAAClB;MAAI,EACzB,CAAC;IACJ,CAAC;IACDwB,iBAAiBA,CAACN,MAAM,EAAE;MACxB,OAAO9B,SAAS,CAACkB,OAAO,CAAAC,aAAA,CAAAA,aAAA,KACnBrC,KAAK,CAACuD,SAAS,CAACjB,KAAK;QACxB,WAAW,EAAEU,MAAM,CAAClB;MAAI,EACzB,CAAC;IACJ,CAAC;IACD0B,iBAAiBA,CAAA,EAAG;MAClB,OAAOtC,SAAS,CAACkB,OAAO,CAAAC,aAAA;QACtB,aAAa,EAAE;MAAI,GAChBrC,KAAK,CAACyD,SAAS,CAACnB,KAAK,CACzB,CAAC;IACJ,CAAC;IACDoB,qBAAqBA,CAACV,MAAM,EAAE;MAC5B,IAAI,CAAClC,YAAY,CAAC6C,GAAG,CAACX,MAAM,CAACY,MAAM,CAAC,EAAE;QACpC,MAAM,IAAIC,KAAK,6BAAArD,MAAA,CACewC,MAAM,CAACY,MAAM,wBAAApD,MAAA,CAAqBsD,KAAK,CAACC,IAAI,CAACjD,YAAY,CAAC,CAACkD,IAAI,CAAC,IAAI,CAAC,CACnG,CAAC;MACH;MACA,OAAO9C,SAAS,CAAC+C,MAAM,CAAA5B,aAAA,CAAAA,aAAA,KAClBrC,KAAK,CAACkE,aAAa,CAAC5B,KAAK;QAC5B6B,MAAM,EAAEzE,KAAK,CAACsD,MAAM,CAACY,MAAM,EAAE;UAC3B/B,KAAK,EAAEA,CAAA,KAAMN,OAAO,IAAIE,MAAM;UAC9BM,KAAK,EAAEA,CAAA,KAAM,CAACR,OAAO;UACrBU,KAAK,EAAEA,CAAA,KAAM,CAACV,OAAO,IAAI,CAACE,MAAM;UAChCO,MAAM,EAAEA,CAAA,KAAM,CAACP,MAAM;UACrBS,OAAO,EAAEA,CAAA,KAAM;QACjB,CAAC,CAAC;QACFJ,IAAI,EAAE,QAAQ;QACdsC,OAAOA,CAACC,KAAK,EAAE;UACb,IAAIA,KAAK,CAACC,gBAAgB,EAAE;UAC5BlD,IAAI,CAAC;YAAEU,IAAI,EAAEkB,MAAM,CAACY,MAAM,CAACW,WAAW,CAAC;UAAE,CAAC,CAAC;QAC7C;MAAC,EACF,CAAC;IACJ;EACF,CAAC;AACH;AACA,IAAIC,OAAO,GAAG5E,aAAa,CAAC;EAC1B6E,KAAKA,CAAAC,IAAA,EAAoB;IAAA,IAAnB;MAAED,KAAK,EAAEzB;IAAO,CAAC,GAAA0B,IAAA;IACrBC,aAAa,CAAC3B,MAAM,CAAC;IACrB,OAAAX,aAAA;MACEuC,QAAQ,EAAE,GAAG;MACbC,OAAO,EAAE;IAAC,GACP7B,MAAM;EAEb,CAAC;EACD8B,YAAYA,CAAAC,KAAA,EAAW;IAAA,IAAV;MAAEC;IAAK,CAAC,GAAAD,KAAA;IACnB,OAAOC,IAAI,CAAC,WAAW,CAAC,GAAG,SAAS,GAAG,MAAM;EAC/C,CAAC;EACDC,OAAOA,CAAAC,KAAA,EAAqB;IAAA,IAApB;MAAEF,IAAI;MAAEG;IAAS,CAAC,GAAAD,KAAA;IACxB,OAAO;MACLE,SAAS,EAAED,QAAQ,CAAC,OAAO;QACzBE,YAAY,EAAEL,IAAI,CAAC,SAAS;MAC9B,CAAC,CAAC;IACJ,CAAC;EACH,CAAC;EACDM,KAAKA,CAAAC,KAAA,EAAwB;IAAA,IAAvB;MAAEC,KAAK;MAAEpE,IAAI;MAAE4D;IAAK,CAAC,GAAAO,KAAA;IACzBC,KAAK,CAAC,CAAC,MAAMR,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,MAAM;MACnC5D,IAAI,CAAC;QAAEU,IAAI,EAAE;MAAU,CAAC,CAAC;IAC3B,CAAC,CAAC;EACJ,CAAC;EACD2D,EAAE,EAAE;IACFC,OAAO,EAAE;MACPC,MAAM,EAAE,cAAc;MACtBC,OAAO,EAAE,CAAC,WAAW;IACvB;EACF,CAAC;EACDvE,QAAQ,EAAE;IACRK,IAAI,EAAEmE,KAAA;MAAA,IAAC;QAAEZ;MAAQ,CAAC,GAAAY,KAAA;MAAA,OAAKC,QAAQ,CAACb,OAAO,CAACc,GAAG,CAAC,WAAW,CAAC,CAAC;IAAA;IACzDpE,aAAa,EAAEqE,KAAA;MAAA,IAAC;QAAE3E;MAAS,CAAC,GAAA2E,KAAA;MAAA,OAAKC,UAAU,CAAC5E,QAAQ,CAAC,MAAM,CAAC,CAAC;IAAA;IAC7DO,eAAe,EAAE/B,IAAI,CACnBqG,KAAA;MAAA,IAAC;QAAEjB,OAAO;QAAED;MAAK,CAAC,GAAAkB,KAAA;MAAA,OAAK,CAACjB,OAAO,CAACc,GAAG,CAAC,WAAW,CAAC,EAAEf,IAAI,CAAC,UAAU,CAAC,EAAEA,IAAI,CAAC,SAAS,CAAC,EAAEA,IAAI,CAAC,WAAW,CAAC,CAAC;IAAA,GACvGmB,KAAA,IAAmD;MAAA,IAAlD,CAACf,SAAS,EAAEgB,QAAQ,GAAG,CAAC,EAAEvB,OAAO,EAAEwB,SAAS,CAAC,GAAAF,KAAA;MAC5C,MAAMG,OAAO,GAAGD,SAAS,GAAGE,SAAS,CAACnB,SAAS,EAAEgB,QAAQ,EAAEvB,OAAO,CAAC,GAAG0B,SAAS,CAACnB,SAAS,EAAEP,OAAO,EAAEuB,QAAQ,CAAC;MAC7G,OAAO5G,UAAU,CAAC8G,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC;IAClC,CACF;EACF,CAAC;EACDE,MAAM,EAAE;IACNC,IAAI,EAAE;MACJhB,EAAE,EAAE;QACFiB,KAAK,EAAE;UACLf,MAAM,EAAE;QACV,CAAC;QACDgB,KAAK,EAAE;UACLf,OAAO,EAAE,CAAC,WAAW;QACvB;MACF;IACF,CAAC;IACD,cAAc,EAAE;MACdgB,OAAO,EAAE,CAAC,iBAAiB,CAAC;MAC5BnB,EAAE,EAAE;QACFoB,QAAQ,EAAE;UACRlB,MAAM,EAAE;QACV;MACF;IACF,CAAC;IACDpE,OAAO,EAAE;MACPqF,OAAO,EAAE,CAAC,aAAa,CAAC;MACxBnB,EAAE,EAAE;QACFqB,KAAK,EAAE;UACLnB,MAAM,EAAE;QACV,CAAC;QACDoB,IAAI,EAAE,CACJ;UACEpB,MAAM,EAAE,MAAM;UACdqB,KAAK,EAAE,kBAAkB;UACzBpB,OAAO,EAAE,CAAC,kBAAkB;QAC9B,CAAC,EACD;UACEA,OAAO,EAAE,CAAC,YAAY,EAAE,cAAc;QACxC,CAAC,CACF;QACDe,KAAK,EAAE;UACLf,OAAO,EAAE,CAAC,WAAW;QACvB;MACF;IACF,CAAC;IACDnE,MAAM,EAAE;MACNgE,EAAE,EAAE;QACFwB,MAAM,EAAE;UACNtB,MAAM,EAAE;QACV,CAAC;QACDgB,KAAK,EAAE;UACLhB,MAAM,EAAE,MAAM;UACdC,OAAO,EAAE,CAAC,WAAW;QACvB;MACF;IACF;EACF,CAAC;EACDsB,eAAe,EAAE;IACfN,OAAO,EAAE;MACPO,WAAWA,CAAAC,KAAA,EAAiB;QAAA,IAAhB;UAAEpC,IAAI;UAAE5D;QAAK,CAAC,GAAAgG,KAAA;QACxB,OAAO7H,cAAc,CAAC8H,KAAA,IAAiB;UAAA,IAAhB;YAAEC;UAAQ,CAAC,GAAAD,KAAA;UAChCjG,IAAI,CAAC;YAAEU,IAAI,EAAE,MAAM;YAAEwF;UAAQ,CAAC,CAAC;QACjC,CAAC,EAAEtC,IAAI,CAAC,UAAU,CAAC,CAAC;MACtB,CAAC;MACDuC,eAAeA,CAAAC,KAAA,EAAW;QAAA,IAAV;UAAEpG;QAAK,CAAC,GAAAoG,KAAA;QACtB,OAAOlI,aAAa,CAAC,MAAM;UACzB8B,IAAI,CAAC;YAAEU,IAAI,EAAE;UAAW,CAAC,CAAC;QAC5B,CAAC,EAAE,CAAC,CAAC;MACP;IACF,CAAC;IACD8D,OAAO,EAAE;MACP6B,UAAUA,CAAAC,MAAA,EAA2B;QAAA,IAA1B;UAAEzC,OAAO;UAAED,IAAI;UAAEX;QAAM,CAAC,GAAAqD,MAAA;QACjC,MAAMC,IAAI,GAAG3C,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;QACvC,MAAMsC,OAAO,GAAGM,eAAe,CAACvD,KAAK,CAACiD,OAAO,EAAEtC,IAAI,CAAC,UAAU,CAAC,CAAC;QAChEC,OAAO,CAAC4C,GAAG,CAAC,WAAW,EAAGC,IAAI,IAAK;UACjC,MAAMC,QAAQ,GAAGD,IAAI,GAAGH,IAAI,GAAGL,OAAO;UACtC,IAAIlB,QAAQ,GAAGpB,IAAI,CAAC,UAAU,CAAC;UAC/B,IAAIoB,QAAQ,IAAI,IAAI,IAAIpB,IAAI,CAAC,WAAW,CAAC,EAAEoB,QAAQ,GAAG,CAAC;UACvD,IAAIpB,IAAI,CAAC,WAAW,CAAC,IAAIoB,QAAQ,IAAI,IAAI,EAAE;YACzC,OAAO4B,IAAI,CAACC,GAAG,CAACF,QAAQ,EAAE3B,QAAQ,CAAC;UACrC,CAAC,MAAM,IAAI,CAACpB,IAAI,CAAC,WAAW,CAAC,IAAIoB,QAAQ,IAAI,IAAI,EAAE;YACjD,OAAO4B,IAAI,CAACE,GAAG,CAACH,QAAQ,EAAE3B,QAAQ,CAAC;UACrC;UACA,OAAO2B,QAAQ;QACjB,CAAC,CAAC;MACJ,CAAC;MACDI,SAASA,CAAAC,MAAA,EAAoB;QAAA,IAAAC,KAAA;QAAA,IAAnB;UAAEpD,OAAO;UAAED;QAAK,CAAC,GAAAoD,MAAA;QACzB,IAAIhC,QAAQ,GAAGpB,IAAI,CAAC,UAAU,CAAC;QAC/B,IAAIoB,QAAQ,IAAI,IAAI,IAAIpB,IAAI,CAAC,WAAW,CAAC,EAAEoB,QAAQ,GAAG,CAAC;QACvDnB,OAAO,CAAC4C,GAAG,CAAC,WAAW,GAAAQ,KAAA,GAAErD,IAAI,CAAC,SAAS,CAAC,cAAAqD,KAAA,cAAAA,KAAA,GAAI,CAAC,CAAC;MAChD,CAAC;MACDC,YAAYA,CAAAC,MAAA,EAA8B;QAAA,IAAAC,MAAA;QAAA,IAA7B;UAAEvD,OAAO;UAAED,IAAI;UAAE3D;QAAS,CAAC,GAAAkH,MAAA;QACtC,CAAAC,MAAA,GAAAxD,IAAI,CAAC,QAAQ,CAAC,cAAAwD,MAAA,eAAdA,MAAA,CAAiB;UACfvF,KAAK,EAAEgC,OAAO,CAACc,GAAG,CAAC,WAAW,CAAC;UAC/BrE,IAAI,EAAEL,QAAQ,CAAC,MAAM,CAAC;UACtBM,aAAa,EAAEN,QAAQ,CAAC,eAAe;QACzC,CAAC,CAAC;MACJ,CAAC;MACDoH,gBAAgBA,CAAAC,MAAA,EAAW;QAAA,IAAAC,MAAA;QAAA,IAAV;UAAE3D;QAAK,CAAC,GAAA0D,MAAA;QACvB,CAAAC,MAAA,GAAA3D,IAAI,CAAC,YAAY,CAAC,cAAA2D,MAAA,eAAlBA,MAAA,CAAqB,CAAC;MACxB;IACF,CAAC;IACDC,MAAM,EAAE;MACNC,gBAAgB,EAAEC,MAAA,IAAuB;QAAA,IAAtB;UAAE7D,OAAO;UAAED;QAAK,CAAC,GAAA8D,MAAA;QAClC,IAAI1C,QAAQ,GAAGpB,IAAI,CAAC,UAAU,CAAC;QAC/B,IAAIoB,QAAQ,IAAI,IAAI,IAAIpB,IAAI,CAAC,WAAW,CAAC,EAAEoB,QAAQ,GAAG,CAAC;QACvD,IAAIA,QAAQ,IAAI,IAAI,EAAE,OAAO,KAAK;QAClC,MAAMhB,SAAS,GAAGH,OAAO,CAACc,GAAG,CAAC,WAAW,CAAC;QAC1C,OAAOf,IAAI,CAAC,WAAW,CAAC,GAAGI,SAAS,IAAIgB,QAAQ,GAAGhB,SAAS,IAAIgB,QAAQ;MAC1E;IACF;EACF;AACF,CAAC,CAAC;AACF,SAASN,QAAQA,CAACiD,EAAE,EAAE;EACpB,MAAMrH,IAAI,GAAGsG,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEc,EAAE,CAAC;EAC5B,MAAMC,YAAY,GAAGtH,IAAI,GAAG,GAAG;EAC/B,MAAMkB,OAAO,GAAGoF,IAAI,CAACiB,KAAK,CAACvH,IAAI,GAAG,GAAG,CAAC,GAAG,EAAE;EAC3C,MAAMiB,OAAO,GAAGqF,IAAI,CAACiB,KAAK,CAACvH,IAAI,IAAI,GAAG,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE;EAClD,MAAMgB,KAAK,GAAGsF,IAAI,CAACiB,KAAK,CAACvH,IAAI,IAAI,GAAG,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE;EACrD,MAAMe,IAAI,GAAGuF,IAAI,CAACiB,KAAK,CAACvH,IAAI,IAAI,GAAG,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;EACpD,OAAO;IACLe,IAAI;IACJC,KAAK;IACLC,OAAO;IACPC,OAAO;IACPoG;EACF,CAAC;AACH;AACA,SAASzC,SAASA,CAACtD,KAAK,EAAEiG,QAAQ,EAAEC,QAAQ,EAAE;EAC5C,MAAMC,KAAK,GAAGD,QAAQ,GAAGD,QAAQ;EACjC,IAAIE,KAAK,KAAK,CAAC,EAAE,OAAO,CAAC;EACzB,OAAO,CAACnG,KAAK,GAAGiG,QAAQ,IAAIE,KAAK;AACnC;AACA,SAASC,QAAQA,CAACC,GAAG,EAAY;EAAA,IAAVC,IAAI,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EAC7B,OAAOF,GAAG,CAACK,QAAQ,CAAC,CAAC,CAACN,QAAQ,CAACE,IAAI,EAAE,GAAG,CAAC;AAC3C;AACA,SAAS3B,eAAeA,CAAC3E,KAAK,EAAE2B,QAAQ,EAAE;EACxC,OAAOoD,IAAI,CAACiB,KAAK,CAAChG,KAAK,GAAG2B,QAAQ,CAAC,GAAGA,QAAQ;AAChD;AACA,SAASqB,UAAUA,CAACvE,IAAI,EAAE;EACxB,MAAM;IAAEe,IAAI;IAAEC,KAAK;IAAEC,OAAO;IAAEC;EAAQ,CAAC,GAAGlB,IAAI;EAC9C,OAAO;IACLe,IAAI,EAAE4G,QAAQ,CAAC5G,IAAI,CAAC;IACpBC,KAAK,EAAE2G,QAAQ,CAAC3G,KAAK,CAAC;IACtBC,OAAO,EAAE0G,QAAQ,CAAC1G,OAAO,CAAC;IAC1BC,OAAO,EAAEyG,QAAQ,CAACzG,OAAO,CAAC;IAC1BoG,YAAY,EAAEK,QAAQ,CAAC3H,IAAI,CAACsH,YAAY,EAAE,CAAC;EAC7C,CAAC;AACH;AACA,SAASrE,aAAaA,CAAC3B,MAAM,EAAE;EAC7B,MAAM;IAAE6B,OAAO;IAAEuB,QAAQ;IAAEC,SAAS;IAAEzB;EAAS,CAAC,GAAG5B,MAAM;EACzD,IAAI4B,QAAQ,IAAI,IAAI,KAAK,OAAOA,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,IAAI,CAAC,CAAC,EAAE;IACvE,MAAM,IAAIf,KAAK,8BAAArD,MAAA,CAA8BoE,QAAQ,iCAA8B,CAAC;EACtF;EACA,IAAIC,OAAO,IAAI,IAAI,KAAK,OAAOA,OAAO,KAAK,QAAQ,IAAIA,OAAO,GAAG,CAAC,CAAC,EAAE;IACnE,MAAM,IAAIhB,KAAK,6BAAArD,MAAA,CAA6BqE,OAAO,qCAAkC,CAAC;EACxF;EACA,IAAIuB,QAAQ,IAAI,IAAI,KAAK,OAAOA,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,GAAG,CAAC,CAAC,EAAE;IACtE,MAAM,IAAIvC,KAAK,8BAAArD,MAAA,CAA8B4F,QAAQ,qCAAkC,CAAC;EAC1F;EACA,IAAIC,SAAS,IAAIxB,OAAO,IAAI,IAAI,IAAIuB,QAAQ,IAAI,IAAI,EAAE;IACpD,IAAIvB,OAAO,IAAIuB,QAAQ,EAAE;MACvB,MAAM,IAAIvC,KAAK,sDAAArD,MAAA,CACwCqE,OAAO,uCAAArE,MAAA,CAAoC4F,QAAQ,OAC1G,CAAC;IACH;EACF;EACA,IAAI,CAACC,SAAS,IAAIxB,OAAO,IAAI,IAAI,IAAIuB,QAAQ,IAAI,IAAI,EAAE;IACrD,IAAIvB,OAAO,IAAIuB,QAAQ,EAAE;MACvB,MAAM,IAAIvC,KAAK,sDAAArD,MAAA,CACwCqE,OAAO,oCAAArE,MAAA,CAAiC4F,QAAQ,OACvG,CAAC;IACH;EACF;EACA,IAAIC,SAAS,IAAID,QAAQ,IAAI,IAAI,IAAIvB,OAAO,IAAI,IAAI,IAAIA,OAAO,IAAI,CAAC,EAAE;IACpE,MAAM,IAAIhB,KAAK,sDAAArD,MAAA,CACwCqE,OAAO,2DAC9D,CAAC;EACH;AACF;AACA,IAAI+E,QAAQ,GAAG,eAAgB,IAAI7I,GAAG,CAAC,CAAC,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC;AAC/E,SAAS8I,aAAaA,CAACC,IAAI,EAAE;EAC3B,OAAOnK,QAAQ,CAACmK,IAAI,CAAC,IAAIC,MAAM,CAACC,IAAI,CAACF,IAAI,CAAC,CAACG,IAAI,CAAEC,GAAG,IAAKN,QAAQ,CAACjG,GAAG,CAACuG,GAAG,CAAC,CAAC;AAC7E;AACA,SAASC,KAAKA,CAACL,IAAI,EAAE;EACnB,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;IAC5B,OAAO,IAAIM,IAAI,CAACN,IAAI,CAAC,CAACO,OAAO,CAAC,CAAC;EACjC;EACA,IAAIR,aAAa,CAACC,IAAI,CAAC,EAAE;IACvB,MAAM;MAAErH,IAAI,GAAG,CAAC;MAAEC,KAAK,GAAG,CAAC;MAAEC,OAAO,GAAG,CAAC;MAAEC,OAAO,GAAG,CAAC;MAAEoG,YAAY,GAAG;IAAE,CAAC,GAAGc,IAAI;IAChF,MAAM7G,KAAK,GAAG,CAACR,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAGC,KAAK,GAAG,EAAE,GAAG,EAAE,GAAGC,OAAO,GAAG,EAAE,GAAGC,OAAO,IAAI,GAAG;IACpF,OAAOK,KAAK,GAAG+F,YAAY;EAC7B;EACA,MAAM,IAAInF,KAAK,CAAC,cAAc,CAAC;AACjC;AACA,IAAIY,KAAK,GAAG3E,WAAW,CAAC,CAAC,CAAC,CACxB,WAAW,EACX,WAAW,EACX,aAAa,EACb,IAAI,EACJ,KAAK,EACL,UAAU,EACV,YAAY,EACZ,QAAQ,EACR,SAAS,EACT,UAAU,CACX,CAAC;AACF,IAAIwK,UAAU,GAAG7K,gBAAgB,CAACgF,KAAK,CAAC;AAExC,SAAS1E,OAAO,EAAEiB,OAAO,EAAEwD,OAAO,EAAE2F,KAAK,EAAE1F,KAAK,EAAE6F,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}