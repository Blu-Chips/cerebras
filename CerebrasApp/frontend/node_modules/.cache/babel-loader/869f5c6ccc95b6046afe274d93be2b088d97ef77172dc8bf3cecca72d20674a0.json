{"ast":null,"code":"\"use client\";\n\nimport _objectSpread from \"C:/Users/JAMES/cerebras-1/CerebrasApp/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { createScope, MachineStatus, INIT_STATE } from '@zag-js/core';\nexport { mergeProps } from '@zag-js/core';\nimport { compact, ensure, isFunction, warn, toArray, isString, identity } from '@zag-js/utils';\nimport * as React from 'react';\nimport { useMemo, useRef, useLayoutEffect, useEffect, useState } from 'react';\nimport { flushSync, createPortal } from 'react-dom';\nimport { createNormalizer } from '@zag-js/types';\nimport { jsx } from 'react/jsx-runtime';\n\n// src/index.ts\nvar useSafeLayoutEffect = typeof globalThis.document !== \"undefined\" ? useLayoutEffect : useEffect;\n\n// src/bindable.ts\nfunction useBindable(props) {\n  var _props$value, _props$isEqual;\n  const initial = (_props$value = props().value) !== null && _props$value !== void 0 ? _props$value : props().defaultValue;\n  const eq = (_props$isEqual = props().isEqual) !== null && _props$isEqual !== void 0 ? _props$isEqual : Object.is;\n  const [initialValue] = useState(initial);\n  const [value, setValue] = useState(initialValue);\n  const controlled = props().value !== void 0;\n  const valueRef = useRef(value);\n  valueRef.current = controlled ? props().value : value;\n  const prevValue = useRef(valueRef.current);\n  useSafeLayoutEffect(() => {\n    prevValue.current = valueRef.current;\n  }, [value, props().value]);\n  const setFn = value2 => {\n    const prev = prevValue.current;\n    const next = isFunction(value2) ? value2(prev) : value2;\n    if (props().debug) {\n      console.log(\"[bindable > \".concat(props().debug, \"] setValue\"), {\n        next,\n        prev\n      });\n    }\n    if (!controlled) setValue(next);\n    if (!eq(next, prev)) {\n      var _props$onChange, _props;\n      (_props$onChange = (_props = props()).onChange) === null || _props$onChange === void 0 || _props$onChange.call(_props, next, prev);\n    }\n  };\n  function get() {\n    return controlled ? props().value : value;\n  }\n  return {\n    initial: initialValue,\n    ref: valueRef,\n    get,\n    set(value2) {\n      const exec = props().sync ? flushSync : identity;\n      exec(() => setFn(value2));\n    },\n    invoke(nextValue, prevValue2) {\n      var _props$onChange2, _props2;\n      (_props$onChange2 = (_props2 = props()).onChange) === null || _props$onChange2 === void 0 || _props$onChange2.call(_props2, nextValue, prevValue2);\n    },\n    hash(value2) {\n      var _props$hash, _props$hash2, _props3;\n      return (_props$hash = (_props$hash2 = (_props3 = props()).hash) === null || _props$hash2 === void 0 ? void 0 : _props$hash2.call(_props3, value2)) !== null && _props$hash !== void 0 ? _props$hash : String(value2);\n    }\n  };\n}\nuseBindable.cleanup = fn => {\n  useEffect(() => fn, []);\n};\nuseBindable.ref = defaultValue => {\n  const value = useRef(defaultValue);\n  return {\n    get: () => value.current,\n    set: next => {\n      value.current = next;\n    }\n  };\n};\nfunction useRefs(refs) {\n  const ref = useRef(refs);\n  return {\n    get(key) {\n      return ref.current[key];\n    },\n    set(key, value) {\n      ref.current[key] = value;\n    }\n  };\n}\nvar useTrack = (deps, effect) => {\n  const render = useRef(false);\n  const called = useRef(false);\n  useEffect(() => {\n    const mounted = render.current;\n    const run = mounted && called.current;\n    if (run) return effect();\n    called.current = true;\n  }, [...(deps !== null && deps !== void 0 ? deps : []).map(d => typeof d === \"function\" ? d() : d)]);\n  useEffect(() => {\n    render.current = true;\n    return () => {\n      render.current = false;\n    };\n  }, []);\n};\n\n// src/machine.ts\nfunction useMachine(machine) {\n  var _machine$props, _machine$props2, _machine$context, _machine$refs, _machine$refs2, _machine$watch;\n  let userProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const scope = useMemo(() => {\n    const {\n      id,\n      ids,\n      getRootNode\n    } = userProps;\n    return createScope({\n      id,\n      ids,\n      getRootNode\n    });\n  }, [userProps]);\n  const debug = function () {\n    if (machine.debug) console.log(...arguments);\n  };\n  const props = (_machine$props = (_machine$props2 = machine.props) === null || _machine$props2 === void 0 ? void 0 : _machine$props2.call(machine, {\n    props: compact(userProps),\n    scope\n  })) !== null && _machine$props !== void 0 ? _machine$props : userProps;\n  const prop = useProp(props);\n  const context = (_machine$context = machine.context) === null || _machine$context === void 0 ? void 0 : _machine$context.call(machine, {\n    prop,\n    bindable: useBindable,\n    scope,\n    flush,\n    getContext() {\n      return ctx;\n    },\n    getComputed() {\n      return computed;\n    },\n    getRefs() {\n      return refs;\n    },\n    getEvent() {\n      return getEvent();\n    }\n  });\n  const contextRef = useLiveRef(context);\n  const ctx = {\n    get(key) {\n      var _contextRef$current;\n      return (_contextRef$current = contextRef.current) === null || _contextRef$current === void 0 ? void 0 : _contextRef$current[key].ref.current;\n    },\n    set(key, value) {\n      var _contextRef$current2;\n      (_contextRef$current2 = contextRef.current) === null || _contextRef$current2 === void 0 || _contextRef$current2[key].set(value);\n    },\n    initial(key) {\n      var _contextRef$current3;\n      return (_contextRef$current3 = contextRef.current) === null || _contextRef$current3 === void 0 ? void 0 : _contextRef$current3[key].initial;\n    },\n    hash(key) {\n      var _contextRef$current4, _contextRef$current5;\n      const current = (_contextRef$current4 = contextRef.current) === null || _contextRef$current4 === void 0 ? void 0 : _contextRef$current4[key].get();\n      return (_contextRef$current5 = contextRef.current) === null || _contextRef$current5 === void 0 ? void 0 : _contextRef$current5[key].hash(current);\n    }\n  };\n  const effects = useRef(/* @__PURE__ */new Map());\n  const transitionRef = useRef(null);\n  const previousEventRef = useRef(null);\n  const eventRef = useRef({\n    type: \"\"\n  });\n  const getEvent = () => _objectSpread(_objectSpread({}, eventRef.current), {}, {\n    current() {\n      return eventRef.current;\n    },\n    previous() {\n      return previousEventRef.current;\n    }\n  });\n  const getState = () => _objectSpread(_objectSpread({}, state), {}, {\n    matches() {\n      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n        values[_key] = arguments[_key];\n      }\n      return values.includes(state.ref.current);\n    },\n    hasTag(tag) {\n      var _machine$states$state;\n      return !!((_machine$states$state = machine.states[state.ref.current]) !== null && _machine$states$state !== void 0 && (_machine$states$state = _machine$states$state.tags) !== null && _machine$states$state !== void 0 && _machine$states$state.includes(tag));\n    }\n  });\n  const refs = useRefs((_machine$refs = (_machine$refs2 = machine.refs) === null || _machine$refs2 === void 0 ? void 0 : _machine$refs2.call(machine, {\n    prop,\n    context: ctx\n  })) !== null && _machine$refs !== void 0 ? _machine$refs : {});\n  const getParams = () => ({\n    state: getState(),\n    context: ctx,\n    event: getEvent(),\n    prop,\n    send,\n    action,\n    guard,\n    track: useTrack,\n    refs,\n    computed,\n    flush,\n    scope,\n    choose\n  });\n  const action = keys => {\n    const strs = isFunction(keys) ? keys(getParams()) : keys;\n    if (!strs) return;\n    const fns = strs.map(s => {\n      var _machine$implementati;\n      const fn = (_machine$implementati = machine.implementations) === null || _machine$implementati === void 0 || (_machine$implementati = _machine$implementati.actions) === null || _machine$implementati === void 0 ? void 0 : _machine$implementati[s];\n      if (!fn) warn(\"[zag-js] No implementation found for action \\\"\".concat(JSON.stringify(s), \"\\\"\"));\n      return fn;\n    });\n    for (const fn of fns) {\n      fn === null || fn === void 0 || fn(getParams());\n    }\n  };\n  const guard = str => {\n    var _machine$implementati2;\n    if (isFunction(str)) return str(getParams());\n    return (_machine$implementati2 = machine.implementations) === null || _machine$implementati2 === void 0 || (_machine$implementati2 = _machine$implementati2.guards) === null || _machine$implementati2 === void 0 ? void 0 : _machine$implementati2[str](getParams());\n  };\n  const effect = keys => {\n    const strs = isFunction(keys) ? keys(getParams()) : keys;\n    if (!strs) return;\n    const fns = strs.map(s => {\n      var _machine$implementati3;\n      const fn = (_machine$implementati3 = machine.implementations) === null || _machine$implementati3 === void 0 || (_machine$implementati3 = _machine$implementati3.effects) === null || _machine$implementati3 === void 0 ? void 0 : _machine$implementati3[s];\n      if (!fn) warn(\"[zag-js] No implementation found for effect \\\"\".concat(JSON.stringify(s), \"\\\"\"));\n      return fn;\n    });\n    const cleanups = [];\n    for (const fn of fns) {\n      const cleanup = fn === null || fn === void 0 ? void 0 : fn(getParams());\n      if (cleanup) cleanups.push(cleanup);\n    }\n    return () => cleanups.forEach(fn => fn === null || fn === void 0 ? void 0 : fn());\n  };\n  const choose = transitions => {\n    return toArray(transitions).find(t => {\n      let result = !t.guard;\n      if (isString(t.guard)) result = !!guard(t.guard);else if (isFunction(t.guard)) result = t.guard(getParams());\n      return result;\n    });\n  };\n  const computed = key => {\n    ensure(machine.computed, () => \"[zag-js] No computed object found on machine\");\n    const fn = machine.computed[key];\n    return fn({\n      context: ctx,\n      event: getEvent(),\n      prop,\n      refs,\n      scope,\n      computed\n    });\n  };\n  const state = useBindable(() => ({\n    defaultValue: machine.initialState({\n      prop\n    }),\n    onChange(nextState, prevState) {\n      var _transitionRef$curren, _machine$states$nextS, _machine$states$nextS2;\n      if (prevState) {\n        const exitEffects = effects.current.get(prevState);\n        exitEffects === null || exitEffects === void 0 || exitEffects();\n        effects.current.delete(prevState);\n      }\n      if (prevState) {\n        var _machine$states$prevS;\n        action((_machine$states$prevS = machine.states[prevState]) === null || _machine$states$prevS === void 0 ? void 0 : _machine$states$prevS.exit);\n      }\n      action((_transitionRef$curren = transitionRef.current) === null || _transitionRef$curren === void 0 ? void 0 : _transitionRef$curren.actions);\n      const cleanup = effect((_machine$states$nextS = machine.states[nextState]) === null || _machine$states$nextS === void 0 ? void 0 : _machine$states$nextS.effects);\n      if (cleanup) effects.current.set(nextState, cleanup);\n      if (prevState === INIT_STATE) {\n        action(machine.entry);\n        const cleanup2 = effect(machine.effects);\n        if (cleanup2) effects.current.set(INIT_STATE, cleanup2);\n      }\n      action((_machine$states$nextS2 = machine.states[nextState]) === null || _machine$states$nextS2 === void 0 ? void 0 : _machine$states$nextS2.entry);\n    }\n  }));\n  const hydratedStateRef = useRef(void 0);\n  const statusRef = useRef(MachineStatus.NotStarted);\n  useSafeLayoutEffect(() => {\n    queueMicrotask(() => {\n      var _hydratedStateRef$cur;\n      const started = statusRef.current === MachineStatus.Started;\n      statusRef.current = MachineStatus.Started;\n      debug(started ? \"rehydrating...\" : \"initializing...\");\n      const initialState = (_hydratedStateRef$cur = hydratedStateRef.current) !== null && _hydratedStateRef$cur !== void 0 ? _hydratedStateRef$cur : state.initial;\n      state.invoke(initialState, started ? state.get() : INIT_STATE);\n    });\n    const fns = effects.current;\n    const currentState = state.ref.current;\n    return () => {\n      debug(\"unmounting...\");\n      hydratedStateRef.current = currentState;\n      statusRef.current = MachineStatus.Stopped;\n      fns.forEach(fn => fn === null || fn === void 0 ? void 0 : fn());\n      effects.current = /* @__PURE__ */new Map();\n      transitionRef.current = null;\n      queueMicrotask(() => {\n        action(machine.exit);\n      });\n    };\n  }, []);\n  const getCurrentState = () => {\n    if (\"ref\" in state) return state.ref.current;\n    return state.get();\n  };\n  const send = event => {\n    queueMicrotask(() => {\n      var _machine$states$curre, _machine$states$curre2, _machine$on, _transition$target;\n      if (statusRef.current !== MachineStatus.Started) return;\n      previousEventRef.current = eventRef.current;\n      eventRef.current = event;\n      let currentState = getCurrentState();\n      const transitions = // @ts-ignore\n      (_machine$states$curre = (_machine$states$curre2 = machine.states[currentState].on) === null || _machine$states$curre2 === void 0 ? void 0 : _machine$states$curre2[event.type]) !== null && _machine$states$curre !== void 0 ? _machine$states$curre : // @ts-ignore\n      (_machine$on = machine.on) === null || _machine$on === void 0 ? void 0 : _machine$on[event.type];\n      const transition = choose(transitions);\n      if (!transition) return;\n      transitionRef.current = transition;\n      const target = (_transition$target = transition.target) !== null && _transition$target !== void 0 ? _transition$target : currentState;\n      debug(\"transition\", event.type, transition.target || currentState, \"(\".concat(transition.actions, \")\"));\n      const changed = target !== currentState;\n      if (changed) {\n        flushSync(() => state.set(target));\n      } else if (transition.reenter && !changed) {\n        state.invoke(currentState, currentState);\n      } else {\n        var _transition$actions;\n        action((_transition$actions = transition.actions) !== null && _transition$actions !== void 0 ? _transition$actions : []);\n      }\n    });\n  };\n  (_machine$watch = machine.watch) === null || _machine$watch === void 0 || _machine$watch.call(machine, getParams());\n  return {\n    state: getState(),\n    send,\n    context: ctx,\n    prop,\n    scope,\n    refs,\n    computed,\n    event: getEvent(),\n    getStatus: () => statusRef.current\n  };\n}\nfunction useLiveRef(value) {\n  const ref = useRef(value);\n  ref.current = value;\n  return ref;\n}\nfunction useProp(value) {\n  const ref = useLiveRef(value);\n  return function get(key) {\n    return ref.current[key];\n  };\n}\nfunction flush(fn) {\n  queueMicrotask(() => {\n    flushSync(() => fn());\n  });\n}\nvar normalizeProps = createNormalizer(v => v);\nvar Portal = props => {\n  var _getRootNode$ownerDoc, _container$current;\n  const {\n    children,\n    container,\n    disabled,\n    getRootNode\n  } = props;\n  const isServer = typeof window === \"undefined\";\n  if (isServer || disabled) return /* @__PURE__ */jsx(React.Fragment, {\n    children\n  });\n  const doc = (_getRootNode$ownerDoc = getRootNode === null || getRootNode === void 0 ? void 0 : getRootNode().ownerDocument) !== null && _getRootNode$ownerDoc !== void 0 ? _getRootNode$ownerDoc : document;\n  const mountNode = (_container$current = container === null || container === void 0 ? void 0 : container.current) !== null && _container$current !== void 0 ? _container$current : doc.body;\n  return /* @__PURE__ */jsx(React.Fragment, {\n    children: React.Children.map(children, child => createPortal(child, mountNode))\n  });\n};\nexport { Portal, normalizeProps, useMachine };","map":{"version":3,"names":["_objectSpread","createScope","MachineStatus","INIT_STATE","mergeProps","compact","ensure","isFunction","warn","toArray","isString","identity","React","useMemo","useRef","useLayoutEffect","useEffect","useState","flushSync","createPortal","createNormalizer","jsx","useSafeLayoutEffect","globalThis","document","useBindable","props","_props$value","_props$isEqual","initial","value","defaultValue","eq","isEqual","Object","is","initialValue","setValue","controlled","valueRef","current","prevValue","setFn","value2","prev","next","debug","console","log","concat","_props$onChange","_props","onChange","call","get","ref","set","exec","sync","invoke","nextValue","prevValue2","_props$onChange2","_props2","hash","_props$hash","_props$hash2","_props3","String","cleanup","fn","useRefs","refs","key","useTrack","deps","effect","render","called","mounted","run","map","d","useMachine","machine","_machine$props","_machine$props2","_machine$context","_machine$refs","_machine$refs2","_machine$watch","userProps","arguments","length","undefined","scope","id","ids","getRootNode","prop","useProp","context","bindable","flush","getContext","ctx","getComputed","computed","getRefs","getEvent","contextRef","useLiveRef","_contextRef$current","_contextRef$current2","_contextRef$current3","_contextRef$current4","_contextRef$current5","effects","Map","transitionRef","previousEventRef","eventRef","type","previous","getState","state","matches","_len","values","Array","_key","includes","hasTag","tag","_machine$states$state","states","tags","getParams","event","send","action","guard","track","choose","keys","strs","fns","s","_machine$implementati","implementations","actions","JSON","stringify","str","_machine$implementati2","guards","_machine$implementati3","cleanups","push","forEach","transitions","find","t","result","initialState","nextState","prevState","_transitionRef$curren","_machine$states$nextS","_machine$states$nextS2","exitEffects","delete","_machine$states$prevS","exit","entry","cleanup2","hydratedStateRef","statusRef","NotStarted","queueMicrotask","_hydratedStateRef$cur","started","Started","currentState","Stopped","getCurrentState","_machine$states$curre","_machine$states$curre2","_machine$on","_transition$target","on","transition","target","changed","reenter","_transition$actions","watch","getStatus","normalizeProps","v","Portal","_getRootNode$ownerDoc","_container$current","children","container","disabled","isServer","window","Fragment","doc","ownerDocument","mountNode","body","Children","child"],"sources":["C:/Users/JAMES/cerebras-1/CerebrasApp/frontend/node_modules/@zag-js/react/dist/index.mjs"],"sourcesContent":["\"use client\";\n\nimport { createScope, MachineStatus, INIT_STATE } from '@zag-js/core';\nexport { mergeProps } from '@zag-js/core';\nimport { compact, ensure, isFunction, warn, toArray, isString, identity } from '@zag-js/utils';\nimport * as React from 'react';\nimport { useMemo, useRef, useLayoutEffect, useEffect, useState } from 'react';\nimport { flushSync, createPortal } from 'react-dom';\nimport { createNormalizer } from '@zag-js/types';\nimport { jsx } from 'react/jsx-runtime';\n\n// src/index.ts\nvar useSafeLayoutEffect = typeof globalThis.document !== \"undefined\" ? useLayoutEffect : useEffect;\n\n// src/bindable.ts\nfunction useBindable(props) {\n  const initial = props().value ?? props().defaultValue;\n  const eq = props().isEqual ?? Object.is;\n  const [initialValue] = useState(initial);\n  const [value, setValue] = useState(initialValue);\n  const controlled = props().value !== void 0;\n  const valueRef = useRef(value);\n  valueRef.current = controlled ? props().value : value;\n  const prevValue = useRef(valueRef.current);\n  useSafeLayoutEffect(() => {\n    prevValue.current = valueRef.current;\n  }, [value, props().value]);\n  const setFn = (value2) => {\n    const prev = prevValue.current;\n    const next = isFunction(value2) ? value2(prev) : value2;\n    if (props().debug) {\n      console.log(`[bindable > ${props().debug}] setValue`, { next, prev });\n    }\n    if (!controlled) setValue(next);\n    if (!eq(next, prev)) {\n      props().onChange?.(next, prev);\n    }\n  };\n  function get() {\n    return controlled ? props().value : value;\n  }\n  return {\n    initial: initialValue,\n    ref: valueRef,\n    get,\n    set(value2) {\n      const exec = props().sync ? flushSync : identity;\n      exec(() => setFn(value2));\n    },\n    invoke(nextValue, prevValue2) {\n      props().onChange?.(nextValue, prevValue2);\n    },\n    hash(value2) {\n      return props().hash?.(value2) ?? String(value2);\n    }\n  };\n}\nuseBindable.cleanup = (fn) => {\n  useEffect(() => fn, []);\n};\nuseBindable.ref = (defaultValue) => {\n  const value = useRef(defaultValue);\n  return {\n    get: () => value.current,\n    set: (next) => {\n      value.current = next;\n    }\n  };\n};\nfunction useRefs(refs) {\n  const ref = useRef(refs);\n  return {\n    get(key) {\n      return ref.current[key];\n    },\n    set(key, value) {\n      ref.current[key] = value;\n    }\n  };\n}\nvar useTrack = (deps, effect) => {\n  const render = useRef(false);\n  const called = useRef(false);\n  useEffect(() => {\n    const mounted = render.current;\n    const run = mounted && called.current;\n    if (run) return effect();\n    called.current = true;\n  }, [...(deps ?? []).map((d) => typeof d === \"function\" ? d() : d)]);\n  useEffect(() => {\n    render.current = true;\n    return () => {\n      render.current = false;\n    };\n  }, []);\n};\n\n// src/machine.ts\nfunction useMachine(machine, userProps = {}) {\n  const scope = useMemo(() => {\n    const { id, ids, getRootNode } = userProps;\n    return createScope({ id, ids, getRootNode });\n  }, [userProps]);\n  const debug = (...args) => {\n    if (machine.debug) console.log(...args);\n  };\n  const props = machine.props?.({ props: compact(userProps), scope }) ?? userProps;\n  const prop = useProp(props);\n  const context = machine.context?.({\n    prop,\n    bindable: useBindable,\n    scope,\n    flush,\n    getContext() {\n      return ctx;\n    },\n    getComputed() {\n      return computed;\n    },\n    getRefs() {\n      return refs;\n    },\n    getEvent() {\n      return getEvent();\n    }\n  });\n  const contextRef = useLiveRef(context);\n  const ctx = {\n    get(key) {\n      return contextRef.current?.[key].ref.current;\n    },\n    set(key, value) {\n      contextRef.current?.[key].set(value);\n    },\n    initial(key) {\n      return contextRef.current?.[key].initial;\n    },\n    hash(key) {\n      const current = contextRef.current?.[key].get();\n      return contextRef.current?.[key].hash(current);\n    }\n  };\n  const effects = useRef(/* @__PURE__ */ new Map());\n  const transitionRef = useRef(null);\n  const previousEventRef = useRef(null);\n  const eventRef = useRef({ type: \"\" });\n  const getEvent = () => ({\n    ...eventRef.current,\n    current() {\n      return eventRef.current;\n    },\n    previous() {\n      return previousEventRef.current;\n    }\n  });\n  const getState = () => ({\n    ...state,\n    matches(...values) {\n      return values.includes(state.ref.current);\n    },\n    hasTag(tag) {\n      return !!machine.states[state.ref.current]?.tags?.includes(tag);\n    }\n  });\n  const refs = useRefs(machine.refs?.({ prop, context: ctx }) ?? {});\n  const getParams = () => ({\n    state: getState(),\n    context: ctx,\n    event: getEvent(),\n    prop,\n    send,\n    action,\n    guard,\n    track: useTrack,\n    refs,\n    computed,\n    flush,\n    scope,\n    choose\n  });\n  const action = (keys) => {\n    const strs = isFunction(keys) ? keys(getParams()) : keys;\n    if (!strs) return;\n    const fns = strs.map((s) => {\n      const fn = machine.implementations?.actions?.[s];\n      if (!fn) warn(`[zag-js] No implementation found for action \"${JSON.stringify(s)}\"`);\n      return fn;\n    });\n    for (const fn of fns) {\n      fn?.(getParams());\n    }\n  };\n  const guard = (str) => {\n    if (isFunction(str)) return str(getParams());\n    return machine.implementations?.guards?.[str](getParams());\n  };\n  const effect = (keys) => {\n    const strs = isFunction(keys) ? keys(getParams()) : keys;\n    if (!strs) return;\n    const fns = strs.map((s) => {\n      const fn = machine.implementations?.effects?.[s];\n      if (!fn) warn(`[zag-js] No implementation found for effect \"${JSON.stringify(s)}\"`);\n      return fn;\n    });\n    const cleanups = [];\n    for (const fn of fns) {\n      const cleanup = fn?.(getParams());\n      if (cleanup) cleanups.push(cleanup);\n    }\n    return () => cleanups.forEach((fn) => fn?.());\n  };\n  const choose = (transitions) => {\n    return toArray(transitions).find((t) => {\n      let result = !t.guard;\n      if (isString(t.guard)) result = !!guard(t.guard);\n      else if (isFunction(t.guard)) result = t.guard(getParams());\n      return result;\n    });\n  };\n  const computed = (key) => {\n    ensure(machine.computed, () => `[zag-js] No computed object found on machine`);\n    const fn = machine.computed[key];\n    return fn({\n      context: ctx,\n      event: getEvent(),\n      prop,\n      refs,\n      scope,\n      computed\n    });\n  };\n  const state = useBindable(() => ({\n    defaultValue: machine.initialState({ prop }),\n    onChange(nextState, prevState) {\n      if (prevState) {\n        const exitEffects = effects.current.get(prevState);\n        exitEffects?.();\n        effects.current.delete(prevState);\n      }\n      if (prevState) {\n        action(machine.states[prevState]?.exit);\n      }\n      action(transitionRef.current?.actions);\n      const cleanup = effect(machine.states[nextState]?.effects);\n      if (cleanup) effects.current.set(nextState, cleanup);\n      if (prevState === INIT_STATE) {\n        action(machine.entry);\n        const cleanup2 = effect(machine.effects);\n        if (cleanup2) effects.current.set(INIT_STATE, cleanup2);\n      }\n      action(machine.states[nextState]?.entry);\n    }\n  }));\n  const hydratedStateRef = useRef(void 0);\n  const statusRef = useRef(MachineStatus.NotStarted);\n  useSafeLayoutEffect(() => {\n    queueMicrotask(() => {\n      const started = statusRef.current === MachineStatus.Started;\n      statusRef.current = MachineStatus.Started;\n      debug(started ? \"rehydrating...\" : \"initializing...\");\n      const initialState = hydratedStateRef.current ?? state.initial;\n      state.invoke(initialState, started ? state.get() : INIT_STATE);\n    });\n    const fns = effects.current;\n    const currentState = state.ref.current;\n    return () => {\n      debug(\"unmounting...\");\n      hydratedStateRef.current = currentState;\n      statusRef.current = MachineStatus.Stopped;\n      fns.forEach((fn) => fn?.());\n      effects.current = /* @__PURE__ */ new Map();\n      transitionRef.current = null;\n      queueMicrotask(() => {\n        action(machine.exit);\n      });\n    };\n  }, []);\n  const getCurrentState = () => {\n    if (\"ref\" in state) return state.ref.current;\n    return state.get();\n  };\n  const send = (event) => {\n    queueMicrotask(() => {\n      if (statusRef.current !== MachineStatus.Started) return;\n      previousEventRef.current = eventRef.current;\n      eventRef.current = event;\n      let currentState = getCurrentState();\n      const transitions = (\n        // @ts-ignore\n        machine.states[currentState].on?.[event.type] ?? // @ts-ignore\n        machine.on?.[event.type]\n      );\n      const transition = choose(transitions);\n      if (!transition) return;\n      transitionRef.current = transition;\n      const target = transition.target ?? currentState;\n      debug(\"transition\", event.type, transition.target || currentState, `(${transition.actions})`);\n      const changed = target !== currentState;\n      if (changed) {\n        flushSync(() => state.set(target));\n      } else if (transition.reenter && !changed) {\n        state.invoke(currentState, currentState);\n      } else {\n        action(transition.actions ?? []);\n      }\n    });\n  };\n  machine.watch?.(getParams());\n  return {\n    state: getState(),\n    send,\n    context: ctx,\n    prop,\n    scope,\n    refs,\n    computed,\n    event: getEvent(),\n    getStatus: () => statusRef.current\n  };\n}\nfunction useLiveRef(value) {\n  const ref = useRef(value);\n  ref.current = value;\n  return ref;\n}\nfunction useProp(value) {\n  const ref = useLiveRef(value);\n  return function get(key) {\n    return ref.current[key];\n  };\n}\nfunction flush(fn) {\n  queueMicrotask(() => {\n    flushSync(() => fn());\n  });\n}\nvar normalizeProps = createNormalizer((v) => v);\nvar Portal = (props) => {\n  const { children, container, disabled, getRootNode } = props;\n  const isServer = typeof window === \"undefined\";\n  if (isServer || disabled) return /* @__PURE__ */ jsx(React.Fragment, { children });\n  const doc = getRootNode?.().ownerDocument ?? document;\n  const mountNode = container?.current ?? doc.body;\n  return /* @__PURE__ */ jsx(React.Fragment, { children: React.Children.map(children, (child) => createPortal(child, mountNode)) });\n};\n\nexport { Portal, normalizeProps, useMachine };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}