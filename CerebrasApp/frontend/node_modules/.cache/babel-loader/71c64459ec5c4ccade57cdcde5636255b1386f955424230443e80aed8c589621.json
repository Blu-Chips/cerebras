{"ast":null,"code":"import _objectSpread from \"C:/Users/JAMES/cerebras-1/CerebrasApp/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { createAnatomy } from '@zag-js/anatomy';\nimport { trackPointerMove, query, addDomEvent, getComputedStyle, dataAttr, getEventPoint, contains, getEventTarget } from '@zag-js/dom-query';\nimport { callAll, isEqual, clampValue, createSplitProps, toPx, compact } from '@zag-js/utils';\nimport { createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar anatomy = createAnatomy(\"scroll-area\").parts(\"root\", \"viewport\", \"content\", \"scrollbar\", \"thumb\", \"corner\");\nvar parts = anatomy.build();\nvar getRootId = ctx => {\n  var _ctx$ids$root, _ctx$ids;\n  return (_ctx$ids$root = (_ctx$ids = ctx.ids) === null || _ctx$ids === void 0 ? void 0 : _ctx$ids.root) !== null && _ctx$ids$root !== void 0 ? _ctx$ids$root : \"scroll-area-\".concat(ctx.id);\n};\nvar getViewportId = ctx => {\n  var _ctx$ids$viewport, _ctx$ids2;\n  return (_ctx$ids$viewport = (_ctx$ids2 = ctx.ids) === null || _ctx$ids2 === void 0 ? void 0 : _ctx$ids2.viewport) !== null && _ctx$ids$viewport !== void 0 ? _ctx$ids$viewport : \"scroll-area-\".concat(ctx.id, \":viewport\");\n};\nvar getContentId = ctx => {\n  var _ctx$ids$content, _ctx$ids3;\n  return (_ctx$ids$content = (_ctx$ids3 = ctx.ids) === null || _ctx$ids3 === void 0 ? void 0 : _ctx$ids3.content) !== null && _ctx$ids$content !== void 0 ? _ctx$ids$content : \"scroll-area-\".concat(ctx.id, \":content\");\n};\nvar getRootEl = ctx => ctx.getById(getRootId(ctx));\nvar getViewportEl = ctx => ctx.getById(getViewportId(ctx));\nvar getContentEl = ctx => ctx.getById(getContentId(ctx));\nvar getScrollbarXEl = ctx => query(getRootEl(ctx), \"[data-part=scrollbar][data-orientation=horizontal][data-ownedby=\\\"\".concat(getRootId(ctx), \"\\\"]\"));\nvar getScrollbarYEl = ctx => query(getRootEl(ctx), \"[data-part=scrollbar][data-orientation=vertical][data-ownedby=\\\"\".concat(getRootId(ctx), \"\\\"]\"));\nvar getThumbXEl = ctx => query(getScrollbarXEl(ctx), \"[data-part=thumb][data-orientation=horizontal][data-ownedby=\\\"\".concat(getRootId(ctx), \"\\\"]\"));\nvar getThumbYEl = ctx => query(getScrollbarYEl(ctx), \"[data-part=thumb][data-orientation=vertical][data-ownedby=\\\"\".concat(getRootId(ctx), \"\\\"]\"));\nvar getCornerEl = ctx => query(getRootEl(ctx), \"[data-part=corner][data-ownedby=\\\"\".concat(getRootId(ctx), \"\\\"]\"));\n\n// src/utils/scroll-progress.ts\nfunction getScrollProgress(element, scrollThreshold) {\n  if (!element) return EMPTY_SCROLL_PROGRESS;\n  let progressX = 0;\n  let progressY = 0;\n  const maxScrollX = element.scrollWidth - element.clientWidth;\n  if (maxScrollX > scrollThreshold) {\n    progressX = Math.min(1, Math.max(0, element.scrollLeft / maxScrollX));\n  }\n  const maxScrollY = element.scrollHeight - element.clientHeight;\n  if (maxScrollY > scrollThreshold) {\n    progressY = Math.min(1, Math.max(0, element.scrollTop / maxScrollY));\n  }\n  return {\n    x: progressX,\n    y: progressY\n  };\n}\nvar EMPTY_SCROLL_PROGRESS = {\n  x: 0,\n  y: 0\n};\n\n// src/utils/smooth-scroll.ts\nvar DURATION = 300;\nvar EASE_OUT_QUAD = t => t * (2 - t);\nfunction smoothScroll(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    top,\n    left,\n    duration = DURATION,\n    easing = EASE_OUT_QUAD,\n    onComplete\n  } = options;\n  if (!node) return;\n  const state = {\n    startTime: 0,\n    startScrollTop: node.scrollTop,\n    startScrollLeft: node.scrollLeft,\n    targetScrollTop: top !== null && top !== void 0 ? top : node.scrollTop,\n    targetScrollLeft: left !== null && left !== void 0 ? left : node.scrollLeft\n  };\n  let cancelled = false;\n  const cleanup = () => {\n    if (state.rafId) {\n      cancelAnimationFrame(state.rafId);\n      state.rafId = void 0;\n    }\n    cancelled = true;\n  };\n  const animate = currentTime => {\n    if (cancelled) return;\n    if (state.startTime === 0) {\n      state.startTime = currentTime;\n    }\n    const elapsed = currentTime - state.startTime;\n    const progress = Math.min(elapsed / duration, 1);\n    const easedProgress = easing(progress);\n    const deltaTop = state.targetScrollTop - state.startScrollTop;\n    const deltaLeft = state.targetScrollLeft - state.startScrollLeft;\n    node.scrollTop = state.startScrollTop + deltaTop * easedProgress;\n    node.scrollLeft = state.startScrollLeft + deltaLeft * easedProgress;\n    if (progress < 1) {\n      state.rafId = requestAnimationFrame(animate);\n    } else {\n      onComplete === null || onComplete === void 0 || onComplete();\n    }\n  };\n  state.rafId = requestAnimationFrame(animate);\n  return cleanup;\n}\n\n// src/utils/scroll-to.ts\nfunction scrollTo(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!node) return;\n  const {\n    top,\n    left,\n    behavior = \"smooth\",\n    easing,\n    duration\n  } = options;\n  if (behavior === \"smooth\") {\n    smoothScroll(node, {\n      top,\n      left,\n      easing,\n      duration\n    });\n  } else {\n    const scrollOptions = compact({\n      behavior,\n      top,\n      left\n    });\n    node.scrollTo(scrollOptions);\n  }\n}\nfunction scrollToEdge(node, edge, dir) {\n  let behavior = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"smooth\";\n  let easing = arguments.length > 4 ? arguments[4] : undefined;\n  let duration = arguments.length > 5 ? arguments[5] : undefined;\n  if (!node) return;\n  const maxLeft = node.scrollWidth - node.clientWidth;\n  const maxTop = node.scrollHeight - node.clientHeight;\n  const isRtl = dir === \"rtl\";\n  let targetScrollTop;\n  let targetScrollLeft;\n  switch (edge) {\n    case \"top\":\n      targetScrollTop = 0;\n      break;\n    case \"bottom\":\n      targetScrollTop = maxTop;\n      break;\n    case \"left\":\n      if (isRtl) {\n        const negative = node.scrollLeft <= 0;\n        targetScrollLeft = negative ? -maxLeft : 0;\n      } else {\n        targetScrollLeft = 0;\n      }\n      break;\n    case \"right\":\n      if (isRtl) {\n        const negative = node.scrollLeft <= 0;\n        targetScrollLeft = negative ? 0 : maxLeft;\n      } else {\n        targetScrollLeft = maxLeft;\n      }\n      break;\n  }\n  if (behavior === \"smooth\") {\n    smoothScroll(node, {\n      top: targetScrollTop,\n      left: targetScrollLeft,\n      easing,\n      duration\n    });\n  } else {\n    const options = compact({\n      left: targetScrollLeft,\n      top: targetScrollTop,\n      behavior\n    });\n    node.scrollTo(options);\n  }\n}\n\n// src/scroll-area.connect.ts\nfunction connect(service, normalize) {\n  const {\n    state,\n    send,\n    context,\n    prop,\n    scope\n  } = service;\n  const dragging = state.matches(\"dragging\");\n  const hovering = context.get(\"hovering\");\n  const cornerSize = context.get(\"cornerSize\");\n  const thumbSize = context.get(\"thumbSize\");\n  const hiddenState = context.get(\"hiddenState\");\n  const atSides = context.get(\"atSides\");\n  return {\n    isAtTop: atSides.top,\n    isAtBottom: atSides.bottom,\n    isAtLeft: atSides.left,\n    isAtRight: atSides.right,\n    hasOverflowX: !hiddenState.scrollbarXHidden,\n    hasOverflowY: !hiddenState.scrollbarYHidden,\n    getScrollProgress() {\n      return getScrollProgress(getViewportEl(scope), 0);\n    },\n    scrollToEdge(details) {\n      const {\n        edge,\n        behavior\n      } = details;\n      return scrollToEdge(getViewportEl(scope), edge, prop(\"dir\"), behavior);\n    },\n    scrollTo(details) {\n      return scrollTo(getViewportEl(scope), details);\n    },\n    getScrollbarState(props2) {\n      const horizontal = props2.orientation === \"horizontal\";\n      return {\n        hovering,\n        dragging,\n        scrolling: context.get(horizontal ? \"scrollingX\" : \"scrollingY\"),\n        hidden: horizontal ? hiddenState.scrollbarXHidden : hiddenState.scrollbarYHidden\n      };\n    },\n    getRootProps() {\n      return normalize.element(_objectSpread(_objectSpread({}, parts.root.attrs), {}, {\n        id: getRootId(scope),\n        dir: prop(\"dir\"),\n        role: \"presentation\",\n        \"data-overflow-x\": dataAttr(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": dataAttr(!hiddenState.scrollbarYHidden),\n        onPointerEnter(event) {\n          const target = getEventTarget(event);\n          if (!contains(event.currentTarget, target)) return;\n          send({\n            type: \"root.pointerenter\",\n            pointerType: event.pointerType\n          });\n        },\n        onPointerMove(event) {\n          const target = getEventTarget(event);\n          if (!contains(event.currentTarget, target)) return;\n          send({\n            type: \"root.pointerenter\",\n            pointerType: event.pointerType\n          });\n        },\n        onPointerDown(_ref) {\n          let {\n            pointerType\n          } = _ref;\n          send({\n            type: \"root.pointerdown\",\n            pointerType\n          });\n        },\n        onPointerLeave(event) {\n          if (contains(event.currentTarget, event.relatedTarget)) return;\n          send({\n            type: \"root.pointerleave\"\n          });\n        },\n        style: {\n          position: \"relative\",\n          \"--corner-width\": toPx(cornerSize === null || cornerSize === void 0 ? void 0 : cornerSize.width),\n          \"--corner-height\": toPx(cornerSize === null || cornerSize === void 0 ? void 0 : cornerSize.height),\n          \"--thumb-width\": toPx(thumbSize === null || thumbSize === void 0 ? void 0 : thumbSize.width),\n          \"--thumb-height\": toPx(thumbSize === null || thumbSize === void 0 ? void 0 : thumbSize.height)\n        }\n      }));\n    },\n    getViewportProps() {\n      const handleUserInteraction = () => {\n        send({\n          type: \"user.scroll\"\n        });\n      };\n      return normalize.element(_objectSpread(_objectSpread({}, parts.viewport.attrs), {}, {\n        role: \"presentation\",\n        \"data-ownedby\": getRootId(scope),\n        id: getViewportId(scope),\n        \"data-at-top\": dataAttr(atSides.top),\n        \"data-at-bottom\": dataAttr(atSides.bottom),\n        \"data-at-left\": dataAttr(atSides.left),\n        \"data-at-right\": dataAttr(atSides.right),\n        \"data-overflow-x\": dataAttr(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": dataAttr(!hiddenState.scrollbarYHidden),\n        tabIndex: hiddenState.scrollbarXHidden || hiddenState.scrollbarYHidden ? void 0 : 0,\n        style: {\n          overflow: \"auto\"\n        },\n        onScroll(event) {\n          send({\n            type: \"viewport.scroll\",\n            target: event.currentTarget\n          });\n        },\n        onWheel: handleUserInteraction,\n        onTouchMove: handleUserInteraction,\n        onPointerMove: handleUserInteraction,\n        onPointerEnter: handleUserInteraction,\n        onKeyDown: handleUserInteraction\n      }));\n    },\n    getContentProps() {\n      return normalize.element(_objectSpread(_objectSpread({}, parts.content.attrs), {}, {\n        id: getContentId(scope),\n        role: \"presentation\",\n        \"data-overflow-x\": dataAttr(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": dataAttr(!hiddenState.scrollbarYHidden),\n        style: {\n          minWidth: \"fit-content\"\n        }\n      }));\n    },\n    getScrollbarProps() {\n      let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      const {\n        orientation = \"vertical\"\n      } = props2;\n      return normalize.element(_objectSpread(_objectSpread({}, parts.scrollbar.attrs), {}, {\n        \"data-ownedby\": getRootId(scope),\n        \"data-orientation\": orientation,\n        \"data-scrolling\": dataAttr(context.get(orientation === \"horizontal\" ? \"scrollingX\" : \"scrollingY\")),\n        \"data-hover\": dataAttr(hovering),\n        \"data-dragging\": dataAttr(dragging),\n        \"data-overflow-x\": dataAttr(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": dataAttr(!hiddenState.scrollbarYHidden),\n        onPointerUp() {\n          send({\n            type: \"scrollbar.pointerup\",\n            orientation\n          });\n        },\n        onPointerDown(event) {\n          if (event.button !== 0) {\n            return;\n          }\n          if (event.currentTarget !== event.target) {\n            return;\n          }\n          const point = getEventPoint(event);\n          send({\n            type: \"scrollbar.pointerdown\",\n            orientation,\n            point\n          });\n          event.stopPropagation();\n        },\n        style: _objectSpread(_objectSpread({\n          position: \"absolute\",\n          touchAction: \"none\",\n          WebkitUserSelect: \"none\",\n          userSelect: \"none\"\n        }, orientation === \"vertical\" && {\n          top: 0,\n          bottom: \"var(--corner-height)\",\n          insetInlineEnd: 0\n        }), orientation === \"horizontal\" && {\n          insetInlineStart: 0,\n          insetInlineEnd: \"var(--corner-width)\",\n          bottom: 0\n        })\n      }));\n    },\n    getThumbProps() {\n      let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      const {\n        orientation = \"vertical\"\n      } = props2;\n      return normalize.element(_objectSpread(_objectSpread({}, parts.thumb.attrs), {}, {\n        \"data-ownedby\": getRootId(scope),\n        \"data-orientation\": orientation,\n        \"data-hover\": dataAttr(hovering),\n        \"data-dragging\": dataAttr(dragging),\n        onPointerDown(event) {\n          if (event.button !== 0) return;\n          const point = getEventPoint(event);\n          send({\n            type: \"thumb.pointerdown\",\n            orientation,\n            point\n          });\n        },\n        style: _objectSpread(_objectSpread({}, orientation === \"vertical\" && {\n          height: \"var(--thumb-height)\"\n        }), orientation === \"horizontal\" && {\n          width: \"var(--thumb-width)\"\n        })\n      }));\n    },\n    getCornerProps() {\n      return normalize.element(_objectSpread(_objectSpread({}, parts.corner.attrs), {}, {\n        \"data-ownedby\": getRootId(scope),\n        \"data-hover\": dataAttr(hovering),\n        \"data-state\": hiddenState.cornerHidden ? \"hidden\" : \"visible\",\n        \"data-overflow-x\": dataAttr(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": dataAttr(!hiddenState.scrollbarYHidden),\n        style: {\n          position: \"absolute\",\n          bottom: 0,\n          insetInlineEnd: 0,\n          width: \"var(--corner-width)\",\n          height: \"var(--corner-height)\"\n        }\n      }));\n    }\n  };\n}\nfunction getScrollOffset(element, prop, axis) {\n  if (!element) return 0;\n  const styles = getComputedStyle(element);\n  const start = axis === \"x\" ? \"Left\" : \"Top\";\n  const end = axis === \"x\" ? \"Right\" : \"Bottom\";\n  return parseFloat(styles[\"\".concat(prop).concat(start)]) + parseFloat(styles[\"\".concat(prop).concat(end)]);\n}\n\n// src/utils/scroll-sides.ts\nfunction getScrollSides(node, dir) {\n  const scrollTop = node.scrollTop;\n  const scrollLeft = node.scrollLeft;\n  const isRtl = dir === \"rtl\";\n  const threshold = 1;\n  const hasVerticalScroll = node.scrollHeight - node.clientHeight > threshold;\n  const hasHorizontalScroll = node.scrollWidth - node.clientWidth > threshold;\n  const maxScrollLeft = node.scrollWidth - node.clientWidth;\n  const maxScrollTop = node.scrollHeight - node.clientHeight;\n  let atLeft = false;\n  let atRight = false;\n  let atTop = false;\n  let atBottom = false;\n  if (hasHorizontalScroll) {\n    if (isRtl) {\n      if (scrollLeft <= 0) {\n        atLeft = Math.abs(scrollLeft) >= maxScrollLeft - threshold;\n        atRight = Math.abs(scrollLeft) <= threshold;\n      } else {\n        atLeft = scrollLeft <= threshold;\n        atRight = scrollLeft >= maxScrollLeft - threshold;\n      }\n    } else {\n      atLeft = scrollLeft <= threshold;\n      atRight = scrollLeft >= maxScrollLeft - threshold;\n    }\n  }\n  if (hasVerticalScroll) {\n    atTop = scrollTop <= threshold;\n    atBottom = scrollTop >= maxScrollTop - threshold;\n  }\n  return {\n    top: atTop,\n    right: atRight,\n    bottom: atBottom,\n    left: atLeft\n  };\n}\n\n// src/utils/timeout.ts\nvar EMPTY = 0;\nvar Timeout = class {\n  constructor() {\n    __publicField(this, \"currentId\", EMPTY);\n    __publicField(this, \"clear\", () => {\n      if (this.currentId !== EMPTY) {\n        clearTimeout(this.currentId);\n        this.currentId = EMPTY;\n      }\n    });\n    __publicField(this, \"disposeEffect\", () => {\n      return this.clear;\n    });\n  }\n  start(delay, fn) {\n    this.clear();\n    this.currentId = setTimeout(() => {\n      this.currentId = EMPTY;\n      fn();\n    }, delay);\n  }\n  isStarted() {\n    return this.currentId !== EMPTY;\n  }\n};\n\n// src/scroll-area.machine.ts\nvar MIN_THUMB_SIZE = 20;\nvar SCROLL_TIMEOUT = 1e3;\nvar machine = createMachine({\n  props(_ref2) {\n    let {\n      props: props2\n    } = _ref2;\n    return _objectSpread({\n      id: \"sv\"\n    }, props2);\n  },\n  context(_ref3) {\n    let {\n      bindable\n    } = _ref3;\n    return {\n      scrollingX: bindable(() => ({\n        defaultValue: false\n      })),\n      scrollingY: bindable(() => ({\n        defaultValue: false\n      })),\n      hovering: bindable(() => ({\n        defaultValue: false\n      })),\n      dragging: bindable(() => ({\n        defaultValue: false\n      })),\n      touchModality: bindable(() => ({\n        defaultValue: false\n      })),\n      atSides: bindable(() => ({\n        defaultValue: {\n          top: true,\n          right: false,\n          bottom: false,\n          left: true\n        }\n      })),\n      cornerSize: bindable(() => ({\n        defaultValue: {\n          width: 0,\n          height: 0\n        }\n      })),\n      thumbSize: bindable(() => ({\n        defaultValue: {\n          width: 0,\n          height: 0\n        }\n      })),\n      hiddenState: bindable(() => ({\n        defaultValue: {\n          scrollbarYHidden: false,\n          scrollbarXHidden: false,\n          cornerHidden: false\n        },\n        hash(a) {\n          return \"Y:\".concat(a.scrollbarYHidden, \" X:\").concat(a.scrollbarXHidden, \" C:\").concat(a.cornerHidden);\n        }\n      }))\n    };\n  },\n  refs() {\n    return {\n      orientation: \"vertical\",\n      scrollPosition: {\n        x: 0,\n        y: 0\n      },\n      scrollYTimeout: new Timeout(),\n      scrollXTimeout: new Timeout(),\n      scrollEndTimeout: new Timeout(),\n      startX: 0,\n      startY: 0,\n      startScrollTop: 0,\n      startScrollLeft: 0,\n      programmaticScroll: true\n    };\n  },\n  initialState() {\n    return \"idle\";\n  },\n  watch(_ref4) {\n    let {\n      track,\n      prop,\n      context,\n      send\n    } = _ref4;\n    track([() => prop(\"dir\"), () => context.hash(\"hiddenState\")], () => {\n      send({\n        type: \"thumb.measure\"\n      });\n    });\n  },\n  effects: [\"trackContentResize\", \"trackViewportVisibility\", \"trackWheelEvent\"],\n  entry: [\"checkHovering\"],\n  exit: [\"clearTimeouts\"],\n  on: {\n    \"thumb.measure\": {\n      actions: [\"setThumbSize\"]\n    },\n    \"viewport.scroll\": {\n      actions: [\"setThumbSize\", \"setScrolling\", \"setProgrammaticScroll\"]\n    },\n    \"root.pointerenter\": {\n      actions: [\"setTouchModality\", \"setHovering\"]\n    },\n    \"root.pointerdown\": {\n      actions: [\"setTouchModality\"]\n    },\n    \"root.pointerleave\": {\n      actions: [\"clearHovering\"]\n    }\n  },\n  states: {\n    idle: {\n      on: {\n        \"scrollbar.pointerdown\": {\n          target: \"dragging\",\n          actions: [\"scrollToPointer\", \"startDragging\"]\n        },\n        \"thumb.pointerdown\": {\n          target: \"dragging\",\n          actions: [\"startDragging\"]\n        }\n      }\n    },\n    dragging: {\n      effects: [\"trackPointerMove\"],\n      on: {\n        \"thumb.pointermove\": {\n          actions: [\"setDraggingScroll\"]\n        },\n        \"scrollbar.pointerup\": {\n          target: \"idle\",\n          actions: [\"stopDragging\"]\n        },\n        \"thumb.pointerup\": {\n          target: \"idle\",\n          actions: [\"clearScrolling\", \"stopDragging\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    actions: {\n      setTouchModality(_ref5) {\n        let {\n          context,\n          event\n        } = _ref5;\n        context.set(\"touchModality\", event.pointerType === \"touch\");\n      },\n      setHovering(_ref6) {\n        let {\n          context\n        } = _ref6;\n        context.set(\"hovering\", true);\n      },\n      clearHovering(_ref7) {\n        let {\n          context\n        } = _ref7;\n        context.set(\"hovering\", false);\n      },\n      setProgrammaticScroll(_ref8) {\n        let {\n          refs\n        } = _ref8;\n        const scrollEndTimeout = refs.get(\"scrollEndTimeout\");\n        scrollEndTimeout.start(100, () => {\n          refs.set(\"programmaticScroll\", true);\n        });\n      },\n      clearScrolling(_ref9) {\n        let {\n          context,\n          event\n        } = _ref9;\n        context.set(event.orientation === \"vertical\" ? \"scrollingY\" : \"scrollingX\", false);\n      },\n      setThumbSize(_ref0) {\n        let {\n          context,\n          scope,\n          prop\n        } = _ref0;\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        const scrollableContentHeight = viewportEl.scrollHeight;\n        const scrollableContentWidth = viewportEl.scrollWidth;\n        if (scrollableContentHeight === 0 || scrollableContentWidth === 0) return;\n        const scrollbarYEl = getScrollbarYEl(scope);\n        const scrollbarXEl = getScrollbarXEl(scope);\n        const thumbYEl = getThumbYEl(scope);\n        const thumbXEl = getThumbXEl(scope);\n        const viewportHeight = viewportEl.clientHeight;\n        const viewportWidth = viewportEl.clientWidth;\n        const scrollTop = viewportEl.scrollTop;\n        const scrollLeft = viewportEl.scrollLeft;\n        const scrollbarYHidden = viewportHeight >= scrollableContentHeight;\n        const scrollbarXHidden = viewportWidth >= scrollableContentWidth;\n        const ratioX = viewportWidth / scrollableContentWidth;\n        const ratioY = viewportHeight / scrollableContentHeight;\n        const nextWidth = scrollbarXHidden ? 0 : viewportWidth;\n        const nextHeight = scrollbarYHidden ? 0 : viewportHeight;\n        const scrollbarXOffset = getScrollOffset(scrollbarXEl, \"padding\", \"x\");\n        const scrollbarYOffset = getScrollOffset(scrollbarYEl, \"padding\", \"y\");\n        const thumbXOffset = getScrollOffset(thumbXEl, \"margin\", \"x\");\n        const thumbYOffset = getScrollOffset(thumbYEl, \"margin\", \"y\");\n        const idealNextWidth = nextWidth - scrollbarXOffset - thumbXOffset;\n        const idealNextHeight = nextHeight - scrollbarYOffset - thumbYOffset;\n        const maxNextWidth = scrollbarXEl ? Math.min(scrollbarXEl.offsetWidth, idealNextWidth) : idealNextWidth;\n        const maxNextHeight = scrollbarYEl ? Math.min(scrollbarYEl.offsetHeight, idealNextHeight) : idealNextHeight;\n        const clampedNextWidth = Math.max(MIN_THUMB_SIZE, maxNextWidth * ratioX);\n        const clampedNextHeight = Math.max(MIN_THUMB_SIZE, maxNextHeight * ratioY);\n        context.set(\"thumbSize\", prevSize => {\n          if (prevSize.height === clampedNextHeight && prevSize.width === clampedNextWidth) {\n            return prevSize;\n          }\n          return {\n            width: clampedNextWidth,\n            height: clampedNextHeight\n          };\n        });\n        if (scrollbarYEl && thumbYEl) {\n          const maxThumbOffsetY = scrollbarYEl.offsetHeight - clampedNextHeight - scrollbarYOffset - thumbYOffset;\n          const scrollRatioY = scrollTop / (scrollableContentHeight - viewportHeight);\n          const thumbOffsetY = Math.min(maxThumbOffsetY, Math.max(0, scrollRatioY * maxThumbOffsetY));\n          thumbYEl.style.transform = \"translate3d(0,\".concat(thumbOffsetY, \"px,0)\");\n        }\n        if (scrollbarXEl && thumbXEl) {\n          const maxThumbOffsetX = scrollbarXEl.offsetWidth - clampedNextWidth - scrollbarXOffset - thumbXOffset;\n          const scrollRatioX = scrollLeft / (scrollableContentWidth - viewportWidth);\n          const thumbOffsetX = prop(\"dir\") === \"rtl\" ? clampValue(scrollRatioX * maxThumbOffsetX, -maxThumbOffsetX, 0) : clampValue(scrollRatioX * maxThumbOffsetX, 0, maxThumbOffsetX);\n          thumbXEl.style.transform = \"translate3d(\".concat(thumbOffsetX, \"px,0,0)\");\n        }\n        const cornerEl = getCornerEl(scope);\n        if (cornerEl) {\n          if (scrollbarXHidden || scrollbarYHidden) {\n            context.set(\"cornerSize\", {\n              width: 0,\n              height: 0\n            });\n          } else if (!scrollbarXHidden && !scrollbarYHidden) {\n            const width = (scrollbarYEl === null || scrollbarYEl === void 0 ? void 0 : scrollbarYEl.offsetWidth) || 0;\n            const height = (scrollbarXEl === null || scrollbarXEl === void 0 ? void 0 : scrollbarXEl.offsetHeight) || 0;\n            context.set(\"cornerSize\", {\n              width,\n              height\n            });\n          }\n        }\n        context.set(\"hiddenState\", prevState => {\n          const cornerHidden = scrollbarYHidden || scrollbarXHidden;\n          if (prevState.scrollbarYHidden === scrollbarYHidden && prevState.scrollbarXHidden === scrollbarXHidden && prevState.cornerHidden === cornerHidden) {\n            return prevState;\n          }\n          return {\n            scrollbarYHidden,\n            scrollbarXHidden,\n            cornerHidden\n          };\n        });\n        context.set(\"atSides\", prev => {\n          const next = getScrollSides(viewportEl, prop(\"dir\"));\n          if (isEqual(prev, next)) return prev;\n          return next;\n        });\n      },\n      checkHovering(_ref1) {\n        let {\n          scope,\n          context\n        } = _ref1;\n        const viewportEl = getViewportEl(scope);\n        if (viewportEl !== null && viewportEl !== void 0 && viewportEl.matches(\":hover\")) {\n          context.set(\"hovering\", true);\n        }\n      },\n      setScrolling(_ref10) {\n        let {\n          event,\n          refs,\n          context,\n          prop\n        } = _ref10;\n        const scrollPosition = {\n          x: event.target.scrollLeft,\n          y: event.target.scrollTop\n        };\n        const scrollPositionRef = refs.get(\"scrollPosition\");\n        const offsetX = scrollPosition.x - scrollPositionRef.x;\n        const offsetY = scrollPosition.y - scrollPositionRef.y;\n        refs.set(\"scrollPosition\", scrollPosition);\n        context.set(\"atSides\", prev => {\n          const next = getScrollSides(event.target, prop(\"dir\"));\n          if (isEqual(prev, next)) return prev;\n          return next;\n        });\n        if (offsetY !== 0) {\n          context.set(\"scrollingY\", true);\n          refs.get(\"scrollYTimeout\").start(SCROLL_TIMEOUT, () => {\n            context.set(\"scrollingY\", false);\n          });\n        }\n        if (offsetX !== 0) {\n          context.set(\"scrollingX\", true);\n          refs.get(\"scrollXTimeout\").start(SCROLL_TIMEOUT, () => {\n            context.set(\"scrollingX\", false);\n          });\n        }\n      },\n      scrollToPointer(_ref11) {\n        let {\n          event,\n          scope,\n          prop\n        } = _ref11;\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        const thumbYRef = getThumbYEl(scope);\n        const scrollbarYRef = getScrollbarYEl(scope);\n        const thumbXRef = getThumbXEl(scope);\n        const scrollbarXRef = getScrollbarXEl(scope);\n        const client = event.point;\n        if (thumbYRef && scrollbarYRef && event.orientation === \"vertical\") {\n          const thumbYOffset = getScrollOffset(thumbYRef, \"margin\", \"y\");\n          const scrollbarYOffset = getScrollOffset(scrollbarYRef, \"padding\", \"y\");\n          const thumbHeight = thumbYRef.offsetHeight;\n          const trackRectY = scrollbarYRef.getBoundingClientRect();\n          const clickY = client.y - trackRectY.top - thumbHeight / 2 - scrollbarYOffset + thumbYOffset / 2;\n          const scrollableContentHeight = viewportEl.scrollHeight;\n          const viewportHeight = viewportEl.clientHeight;\n          const maxThumbOffsetY = scrollbarYRef.offsetHeight - thumbHeight - scrollbarYOffset - thumbYOffset;\n          const scrollRatioY = clickY / maxThumbOffsetY;\n          const newScrollTop = scrollRatioY * (scrollableContentHeight - viewportHeight);\n          viewportEl.scrollTop = newScrollTop;\n        }\n        if (thumbXRef && scrollbarXRef && event.orientation === \"horizontal\") {\n          const thumbXOffset = getScrollOffset(thumbXRef, \"margin\", \"x\");\n          const scrollbarXOffset = getScrollOffset(scrollbarXRef, \"padding\", \"x\");\n          const thumbWidth = thumbXRef.offsetWidth;\n          const trackRectX = scrollbarXRef.getBoundingClientRect();\n          const clickX = client.x - trackRectX.left - thumbWidth / 2 - scrollbarXOffset + thumbXOffset / 2;\n          const scrollableContentWidth = viewportEl.scrollWidth;\n          const viewportWidth = viewportEl.clientWidth;\n          const maxThumbOffsetX = scrollbarXRef.offsetWidth - thumbWidth - scrollbarXOffset - thumbXOffset;\n          const scrollRatioX = clickX / maxThumbOffsetX;\n          let newScrollLeft;\n          if (prop(\"dir\") === \"rtl\") {\n            newScrollLeft = (1 - scrollRatioX) * (scrollableContentWidth - viewportWidth);\n            if (viewportEl.scrollLeft <= 0) {\n              newScrollLeft = -newScrollLeft;\n            }\n          } else {\n            newScrollLeft = scrollRatioX * (scrollableContentWidth - viewportWidth);\n          }\n          viewportEl.scrollLeft = newScrollLeft;\n        }\n      },\n      startDragging(_ref12) {\n        let {\n          event,\n          refs,\n          scope\n        } = _ref12;\n        refs.set(\"startX\", event.point.x);\n        refs.set(\"startY\", event.point.y);\n        refs.set(\"orientation\", event.orientation);\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        refs.set(\"startScrollTop\", viewportEl.scrollTop);\n        refs.set(\"startScrollLeft\", viewportEl.scrollLeft);\n      },\n      setDraggingScroll(_ref13) {\n        let {\n          event,\n          refs,\n          scope,\n          context\n        } = _ref13;\n        const startY = refs.get(\"startY\");\n        const startX = refs.get(\"startX\");\n        const startScrollTop = refs.get(\"startScrollTop\");\n        const startScrollLeft = refs.get(\"startScrollLeft\");\n        const client = event.point;\n        const deltaY = client.y - startY;\n        const deltaX = client.x - startX;\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        const scrollableContentHeight = viewportEl.scrollHeight;\n        const viewportHeight = viewportEl.clientHeight;\n        const scrollableContentWidth = viewportEl.scrollWidth;\n        const viewportWidth = viewportEl.clientWidth;\n        const orientation = refs.get(\"orientation\");\n        const thumbYEl = getThumbYEl(scope);\n        const scrollbarYEl = getScrollbarYEl(scope);\n        if (thumbYEl && scrollbarYEl && orientation === \"vertical\") {\n          const scrollbarYOffset = getScrollOffset(scrollbarYEl, \"padding\", \"y\");\n          const thumbYOffset = getScrollOffset(thumbYEl, \"margin\", \"y\");\n          const thumbHeight = thumbYEl.offsetHeight;\n          const maxThumbOffsetY = scrollbarYEl.offsetHeight - thumbHeight - scrollbarYOffset - thumbYOffset;\n          const scrollRatioY = deltaY / maxThumbOffsetY;\n          viewportEl.scrollTop = startScrollTop + scrollRatioY * (scrollableContentHeight - viewportHeight);\n          context.set(\"scrollingY\", true);\n          refs.get(\"scrollYTimeout\").start(SCROLL_TIMEOUT, () => {\n            context.set(\"scrollingY\", false);\n          });\n        }\n        const thumbXEl = getThumbXEl(scope);\n        const scrollbarXEl = getScrollbarXEl(scope);\n        if (thumbXEl && scrollbarXEl && orientation === \"horizontal\") {\n          const scrollbarXOffset = getScrollOffset(scrollbarXEl, \"padding\", \"x\");\n          const thumbXOffset = getScrollOffset(thumbXEl, \"margin\", \"x\");\n          const thumbWidth = thumbXEl.offsetWidth;\n          const maxThumbOffsetX = scrollbarXEl.offsetWidth - thumbWidth - scrollbarXOffset - thumbXOffset;\n          const scrollRatioX = deltaX / maxThumbOffsetX;\n          viewportEl.scrollLeft = startScrollLeft + scrollRatioX * (scrollableContentWidth - viewportWidth);\n          context.set(\"scrollingX\", true);\n          refs.get(\"scrollXTimeout\").start(SCROLL_TIMEOUT, () => {\n            context.set(\"scrollingX\", false);\n          });\n        }\n      },\n      stopDragging(_ref14) {\n        let {\n          refs\n        } = _ref14;\n        refs.set(\"orientation\", null);\n      },\n      clearTimeouts(_ref15) {\n        let {\n          refs\n        } = _ref15;\n        refs.get(\"scrollYTimeout\").clear();\n        refs.get(\"scrollXTimeout\").clear();\n        refs.get(\"scrollEndTimeout\").clear();\n      }\n    },\n    effects: {\n      trackContentResize(_ref16) {\n        let {\n          scope,\n          send\n        } = _ref16;\n        const contentEl = getContentEl(scope);\n        const rootEl = getRootEl(scope);\n        if (!contentEl || !rootEl) return;\n        const win = scope.getWin();\n        const obs = new win.ResizeObserver(() => {\n          setTimeout(() => {\n            send({\n              type: \"thumb.measure\"\n            });\n          }, 1);\n        });\n        obs.observe(contentEl);\n        obs.observe(rootEl);\n        return () => {\n          obs.disconnect();\n        };\n      },\n      trackViewportVisibility(_ref17) {\n        let {\n          scope,\n          send\n        } = _ref17;\n        const win = scope.getWin();\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        const observer = new win.IntersectionObserver(entries => {\n          entries.forEach(entry => {\n            if (entry.intersectionRatio > 0) {\n              send({\n                type: \"thumb.measure\"\n              });\n              observer.disconnect();\n            }\n          });\n        });\n        observer.observe(viewportEl);\n        return () => {\n          observer.disconnect();\n        };\n      },\n      trackWheelEvent(_ref18) {\n        let {\n          scope\n        } = _ref18;\n        const scrollbarYEl = getScrollbarYEl(scope);\n        const scrollbarXEl = getScrollbarXEl(scope);\n        if (!scrollbarYEl && !scrollbarXEl) return;\n        const onWheel = event => {\n          const viewportEl = getViewportEl(scope);\n          if (!viewportEl || event.ctrlKey) return;\n          const orientation = event.currentTarget.dataset.orientation;\n          if (orientation === \"vertical\") {\n            const canScrollY = viewportEl.scrollHeight > viewportEl.clientHeight;\n            const atTop = viewportEl.scrollTop === 0 && event.deltaY < 0;\n            const atBottom = viewportEl.scrollTop === viewportEl.scrollHeight - viewportEl.clientHeight && event.deltaY > 0;\n            const shouldScroll = canScrollY && event.deltaY !== 0 && !(atTop || atBottom);\n            if (!shouldScroll) return;\n            event.preventDefault();\n            viewportEl.scrollTop += event.deltaY;\n          } else if (orientation === \"horizontal\") {\n            const canScrollX = viewportEl.scrollWidth > viewportEl.clientWidth;\n            const atLeft = viewportEl.scrollLeft === 0 && event.deltaX < 0;\n            const atRight = viewportEl.scrollLeft === viewportEl.scrollWidth - viewportEl.clientWidth && event.deltaX > 0;\n            const shouldScroll = canScrollX && event.deltaX !== 0 && !(atLeft || atRight);\n            if (!shouldScroll) return;\n            event.preventDefault();\n            viewportEl.scrollLeft += event.deltaX;\n          }\n        };\n        return callAll(scrollbarYEl && addDomEvent(scrollbarYEl, \"wheel\", onWheel, {\n          passive: false\n        }), scrollbarXEl && addDomEvent(scrollbarXEl, \"wheel\", onWheel, {\n          passive: false\n        }));\n      },\n      trackPointerMove(_ref19) {\n        let {\n          scope,\n          send,\n          refs\n        } = _ref19;\n        const doc = scope.getDoc();\n        const orientation = refs.get(\"orientation\");\n        return trackPointerMove(doc, {\n          onPointerMove(_ref20) {\n            let {\n              point\n            } = _ref20;\n            send({\n              type: \"thumb.pointermove\",\n              orientation,\n              point\n            });\n          },\n          onPointerUp() {\n            send({\n              type: \"thumb.pointerup\",\n              orientation\n            });\n          }\n        });\n      }\n    }\n  }\n});\nvar props = createProps()([\"dir\", \"getRootNode\", \"ids\", \"id\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, props, splitProps };","map":{"version":3,"names":["createAnatomy","trackPointerMove","query","addDomEvent","getComputedStyle","dataAttr","getEventPoint","contains","getEventTarget","callAll","isEqual","clampValue","createSplitProps","toPx","compact","createMachine","createProps","__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","anatomy","parts","build","getRootId","ctx","_ctx$ids$root","_ctx$ids","ids","root","concat","id","getViewportId","_ctx$ids$viewport","_ctx$ids2","viewport","getContentId","_ctx$ids$content","_ctx$ids3","content","getRootEl","getById","getViewportEl","getContentEl","getScrollbarXEl","getScrollbarYEl","getThumbXEl","getThumbYEl","getCornerEl","getScrollProgress","element","scrollThreshold","EMPTY_SCROLL_PROGRESS","progressX","progressY","maxScrollX","scrollWidth","clientWidth","Math","min","max","scrollLeft","maxScrollY","scrollHeight","clientHeight","scrollTop","x","y","DURATION","EASE_OUT_QUAD","t","smoothScroll","node","options","arguments","length","undefined","top","left","duration","easing","onComplete","state","startTime","startScrollTop","startScrollLeft","targetScrollTop","targetScrollLeft","cancelled","cleanup","rafId","cancelAnimationFrame","animate","currentTime","elapsed","progress","easedProgress","deltaTop","deltaLeft","requestAnimationFrame","scrollTo","behavior","scrollOptions","scrollToEdge","edge","dir","maxLeft","maxTop","isRtl","negative","connect","service","normalize","send","context","prop","scope","dragging","matches","hovering","get","cornerSize","thumbSize","hiddenState","atSides","isAtTop","isAtBottom","bottom","isAtLeft","isAtRight","right","hasOverflowX","scrollbarXHidden","hasOverflowY","scrollbarYHidden","details","getScrollbarState","props2","horizontal","orientation","scrolling","hidden","getRootProps","_objectSpread","attrs","role","onPointerEnter","event","target","currentTarget","type","pointerType","onPointerMove","onPointerDown","_ref","onPointerLeave","relatedTarget","style","position","width","height","getViewportProps","handleUserInteraction","tabIndex","overflow","onScroll","onWheel","onTouchMove","onKeyDown","getContentProps","minWidth","getScrollbarProps","scrollbar","onPointerUp","button","point","stopPropagation","touchAction","WebkitUserSelect","userSelect","insetInlineEnd","insetInlineStart","getThumbProps","thumb","getCornerProps","corner","cornerHidden","getScrollOffset","axis","styles","start","end","parseFloat","getScrollSides","threshold","hasVerticalScroll","hasHorizontalScroll","maxScrollLeft","maxScrollTop","atLeft","atRight","atTop","atBottom","abs","EMPTY","Timeout","constructor","currentId","clearTimeout","clear","delay","fn","setTimeout","isStarted","MIN_THUMB_SIZE","SCROLL_TIMEOUT","machine","props","_ref2","_ref3","bindable","scrollingX","defaultValue","scrollingY","touchModality","hash","a","refs","scrollPosition","scrollYTimeout","scrollXTimeout","scrollEndTimeout","startX","startY","programmaticScroll","initialState","watch","_ref4","track","effects","entry","exit","on","actions","states","idle","implementations","setTouchModality","_ref5","set","setHovering","_ref6","clearHovering","_ref7","setProgrammaticScroll","_ref8","clearScrolling","_ref9","setThumbSize","_ref0","viewportEl","scrollableContentHeight","scrollableContentWidth","scrollbarYEl","scrollbarXEl","thumbYEl","thumbXEl","viewportHeight","viewportWidth","ratioX","ratioY","nextWidth","nextHeight","scrollbarXOffset","scrollbarYOffset","thumbXOffset","thumbYOffset","idealNextWidth","idealNextHeight","maxNextWidth","offsetWidth","maxNextHeight","offsetHeight","clampedNextWidth","clampedNextHeight","prevSize","maxThumbOffsetY","scrollRatioY","thumbOffsetY","transform","maxThumbOffsetX","scrollRatioX","thumbOffsetX","cornerEl","prevState","prev","next","checkHovering","_ref1","setScrolling","_ref10","scrollPositionRef","offsetX","offsetY","scrollToPointer","_ref11","thumbYRef","scrollbarYRef","thumbXRef","scrollbarXRef","client","thumbHeight","trackRectY","getBoundingClientRect","clickY","newScrollTop","thumbWidth","trackRectX","clickX","newScrollLeft","startDragging","_ref12","setDraggingScroll","_ref13","deltaY","deltaX","stopDragging","_ref14","clearTimeouts","_ref15","trackContentResize","_ref16","contentEl","rootEl","win","getWin","obs","ResizeObserver","observe","disconnect","trackViewportVisibility","_ref17","observer","IntersectionObserver","entries","forEach","intersectionRatio","trackWheelEvent","_ref18","ctrlKey","dataset","canScrollY","shouldScroll","preventDefault","canScrollX","passive","_ref19","doc","getDoc","_ref20","splitProps"],"sources":["C:/Users/JAMES/cerebras-1/CerebrasApp/frontend/node_modules/@zag-js/scroll-area/dist/index.mjs"],"sourcesContent":["import { createAnatomy } from '@zag-js/anatomy';\nimport { trackPointerMove, query, addDomEvent, getComputedStyle, dataAttr, getEventPoint, contains, getEventTarget } from '@zag-js/dom-query';\nimport { callAll, isEqual, clampValue, createSplitProps, toPx, compact } from '@zag-js/utils';\nimport { createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar anatomy = createAnatomy(\"scroll-area\").parts(\"root\", \"viewport\", \"content\", \"scrollbar\", \"thumb\", \"corner\");\nvar parts = anatomy.build();\nvar getRootId = (ctx) => ctx.ids?.root ?? `scroll-area-${ctx.id}`;\nvar getViewportId = (ctx) => ctx.ids?.viewport ?? `scroll-area-${ctx.id}:viewport`;\nvar getContentId = (ctx) => ctx.ids?.content ?? `scroll-area-${ctx.id}:content`;\nvar getRootEl = (ctx) => ctx.getById(getRootId(ctx));\nvar getViewportEl = (ctx) => ctx.getById(getViewportId(ctx));\nvar getContentEl = (ctx) => ctx.getById(getContentId(ctx));\nvar getScrollbarXEl = (ctx) => query(getRootEl(ctx), `[data-part=scrollbar][data-orientation=horizontal][data-ownedby=\"${getRootId(ctx)}\"]`);\nvar getScrollbarYEl = (ctx) => query(getRootEl(ctx), `[data-part=scrollbar][data-orientation=vertical][data-ownedby=\"${getRootId(ctx)}\"]`);\nvar getThumbXEl = (ctx) => query(getScrollbarXEl(ctx), `[data-part=thumb][data-orientation=horizontal][data-ownedby=\"${getRootId(ctx)}\"]`);\nvar getThumbYEl = (ctx) => query(getScrollbarYEl(ctx), `[data-part=thumb][data-orientation=vertical][data-ownedby=\"${getRootId(ctx)}\"]`);\nvar getCornerEl = (ctx) => query(getRootEl(ctx), `[data-part=corner][data-ownedby=\"${getRootId(ctx)}\"]`);\n\n// src/utils/scroll-progress.ts\nfunction getScrollProgress(element, scrollThreshold) {\n  if (!element) return EMPTY_SCROLL_PROGRESS;\n  let progressX = 0;\n  let progressY = 0;\n  const maxScrollX = element.scrollWidth - element.clientWidth;\n  if (maxScrollX > scrollThreshold) {\n    progressX = Math.min(1, Math.max(0, element.scrollLeft / maxScrollX));\n  }\n  const maxScrollY = element.scrollHeight - element.clientHeight;\n  if (maxScrollY > scrollThreshold) {\n    progressY = Math.min(1, Math.max(0, element.scrollTop / maxScrollY));\n  }\n  return { x: progressX, y: progressY };\n}\nvar EMPTY_SCROLL_PROGRESS = { x: 0, y: 0 };\n\n// src/utils/smooth-scroll.ts\nvar DURATION = 300;\nvar EASE_OUT_QUAD = (t) => t * (2 - t);\nfunction smoothScroll(node, options = {}) {\n  const { top, left, duration = DURATION, easing = EASE_OUT_QUAD, onComplete } = options;\n  if (!node) return;\n  const state = {\n    startTime: 0,\n    startScrollTop: node.scrollTop,\n    startScrollLeft: node.scrollLeft,\n    targetScrollTop: top ?? node.scrollTop,\n    targetScrollLeft: left ?? node.scrollLeft\n  };\n  let cancelled = false;\n  const cleanup = () => {\n    if (state.rafId) {\n      cancelAnimationFrame(state.rafId);\n      state.rafId = void 0;\n    }\n    cancelled = true;\n  };\n  const animate = (currentTime) => {\n    if (cancelled) return;\n    if (state.startTime === 0) {\n      state.startTime = currentTime;\n    }\n    const elapsed = currentTime - state.startTime;\n    const progress = Math.min(elapsed / duration, 1);\n    const easedProgress = easing(progress);\n    const deltaTop = state.targetScrollTop - state.startScrollTop;\n    const deltaLeft = state.targetScrollLeft - state.startScrollLeft;\n    node.scrollTop = state.startScrollTop + deltaTop * easedProgress;\n    node.scrollLeft = state.startScrollLeft + deltaLeft * easedProgress;\n    if (progress < 1) {\n      state.rafId = requestAnimationFrame(animate);\n    } else {\n      onComplete?.();\n    }\n  };\n  state.rafId = requestAnimationFrame(animate);\n  return cleanup;\n}\n\n// src/utils/scroll-to.ts\nfunction scrollTo(node, options = {}) {\n  if (!node) return;\n  const { top, left, behavior = \"smooth\", easing, duration } = options;\n  if (behavior === \"smooth\") {\n    smoothScroll(node, { top, left, easing, duration });\n  } else {\n    const scrollOptions = compact({ behavior, top, left });\n    node.scrollTo(scrollOptions);\n  }\n}\nfunction scrollToEdge(node, edge, dir, behavior = \"smooth\", easing, duration) {\n  if (!node) return;\n  const maxLeft = node.scrollWidth - node.clientWidth;\n  const maxTop = node.scrollHeight - node.clientHeight;\n  const isRtl = dir === \"rtl\";\n  let targetScrollTop;\n  let targetScrollLeft;\n  switch (edge) {\n    case \"top\":\n      targetScrollTop = 0;\n      break;\n    case \"bottom\":\n      targetScrollTop = maxTop;\n      break;\n    case \"left\":\n      if (isRtl) {\n        const negative = node.scrollLeft <= 0;\n        targetScrollLeft = negative ? -maxLeft : 0;\n      } else {\n        targetScrollLeft = 0;\n      }\n      break;\n    case \"right\":\n      if (isRtl) {\n        const negative = node.scrollLeft <= 0;\n        targetScrollLeft = negative ? 0 : maxLeft;\n      } else {\n        targetScrollLeft = maxLeft;\n      }\n      break;\n  }\n  if (behavior === \"smooth\") {\n    smoothScroll(node, { top: targetScrollTop, left: targetScrollLeft, easing, duration });\n  } else {\n    const options = compact({ left: targetScrollLeft, top: targetScrollTop, behavior });\n    node.scrollTo(options);\n  }\n}\n\n// src/scroll-area.connect.ts\nfunction connect(service, normalize) {\n  const { state, send, context, prop, scope } = service;\n  const dragging = state.matches(\"dragging\");\n  const hovering = context.get(\"hovering\");\n  const cornerSize = context.get(\"cornerSize\");\n  const thumbSize = context.get(\"thumbSize\");\n  const hiddenState = context.get(\"hiddenState\");\n  const atSides = context.get(\"atSides\");\n  return {\n    isAtTop: atSides.top,\n    isAtBottom: atSides.bottom,\n    isAtLeft: atSides.left,\n    isAtRight: atSides.right,\n    hasOverflowX: !hiddenState.scrollbarXHidden,\n    hasOverflowY: !hiddenState.scrollbarYHidden,\n    getScrollProgress() {\n      return getScrollProgress(getViewportEl(scope), 0);\n    },\n    scrollToEdge(details) {\n      const { edge, behavior } = details;\n      return scrollToEdge(getViewportEl(scope), edge, prop(\"dir\"), behavior);\n    },\n    scrollTo(details) {\n      return scrollTo(getViewportEl(scope), details);\n    },\n    getScrollbarState(props2) {\n      const horizontal = props2.orientation === \"horizontal\";\n      return {\n        hovering,\n        dragging,\n        scrolling: context.get(horizontal ? \"scrollingX\" : \"scrollingY\"),\n        hidden: horizontal ? hiddenState.scrollbarXHidden : hiddenState.scrollbarYHidden\n      };\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        id: getRootId(scope),\n        dir: prop(\"dir\"),\n        role: \"presentation\",\n        \"data-overflow-x\": dataAttr(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": dataAttr(!hiddenState.scrollbarYHidden),\n        onPointerEnter(event) {\n          const target = getEventTarget(event);\n          if (!contains(event.currentTarget, target)) return;\n          send({ type: \"root.pointerenter\", pointerType: event.pointerType });\n        },\n        onPointerMove(event) {\n          const target = getEventTarget(event);\n          if (!contains(event.currentTarget, target)) return;\n          send({ type: \"root.pointerenter\", pointerType: event.pointerType });\n        },\n        onPointerDown({ pointerType }) {\n          send({ type: \"root.pointerdown\", pointerType });\n        },\n        onPointerLeave(event) {\n          if (contains(event.currentTarget, event.relatedTarget)) return;\n          send({ type: \"root.pointerleave\" });\n        },\n        style: {\n          position: \"relative\",\n          \"--corner-width\": toPx(cornerSize?.width),\n          \"--corner-height\": toPx(cornerSize?.height),\n          \"--thumb-width\": toPx(thumbSize?.width),\n          \"--thumb-height\": toPx(thumbSize?.height)\n        }\n      });\n    },\n    getViewportProps() {\n      const handleUserInteraction = () => {\n        send({ type: \"user.scroll\" });\n      };\n      return normalize.element({\n        ...parts.viewport.attrs,\n        role: \"presentation\",\n        \"data-ownedby\": getRootId(scope),\n        id: getViewportId(scope),\n        \"data-at-top\": dataAttr(atSides.top),\n        \"data-at-bottom\": dataAttr(atSides.bottom),\n        \"data-at-left\": dataAttr(atSides.left),\n        \"data-at-right\": dataAttr(atSides.right),\n        \"data-overflow-x\": dataAttr(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": dataAttr(!hiddenState.scrollbarYHidden),\n        tabIndex: hiddenState.scrollbarXHidden || hiddenState.scrollbarYHidden ? void 0 : 0,\n        style: {\n          overflow: \"auto\"\n        },\n        onScroll(event) {\n          send({ type: \"viewport.scroll\", target: event.currentTarget });\n        },\n        onWheel: handleUserInteraction,\n        onTouchMove: handleUserInteraction,\n        onPointerMove: handleUserInteraction,\n        onPointerEnter: handleUserInteraction,\n        onKeyDown: handleUserInteraction\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        id: getContentId(scope),\n        role: \"presentation\",\n        \"data-overflow-x\": dataAttr(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": dataAttr(!hiddenState.scrollbarYHidden),\n        style: {\n          minWidth: \"fit-content\"\n        }\n      });\n    },\n    getScrollbarProps(props2 = {}) {\n      const { orientation = \"vertical\" } = props2;\n      return normalize.element({\n        ...parts.scrollbar.attrs,\n        \"data-ownedby\": getRootId(scope),\n        \"data-orientation\": orientation,\n        \"data-scrolling\": dataAttr(context.get(orientation === \"horizontal\" ? \"scrollingX\" : \"scrollingY\")),\n        \"data-hover\": dataAttr(hovering),\n        \"data-dragging\": dataAttr(dragging),\n        \"data-overflow-x\": dataAttr(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": dataAttr(!hiddenState.scrollbarYHidden),\n        onPointerUp() {\n          send({ type: \"scrollbar.pointerup\", orientation });\n        },\n        onPointerDown(event) {\n          if (event.button !== 0) {\n            return;\n          }\n          if (event.currentTarget !== event.target) {\n            return;\n          }\n          const point = getEventPoint(event);\n          send({ type: \"scrollbar.pointerdown\", orientation, point });\n          event.stopPropagation();\n        },\n        style: {\n          position: \"absolute\",\n          touchAction: \"none\",\n          WebkitUserSelect: \"none\",\n          userSelect: \"none\",\n          ...orientation === \"vertical\" && {\n            top: 0,\n            bottom: `var(--corner-height)`,\n            insetInlineEnd: 0\n          },\n          ...orientation === \"horizontal\" && {\n            insetInlineStart: 0,\n            insetInlineEnd: `var(--corner-width)`,\n            bottom: 0\n          }\n        }\n      });\n    },\n    getThumbProps(props2 = {}) {\n      const { orientation = \"vertical\" } = props2;\n      return normalize.element({\n        ...parts.thumb.attrs,\n        \"data-ownedby\": getRootId(scope),\n        \"data-orientation\": orientation,\n        \"data-hover\": dataAttr(hovering),\n        \"data-dragging\": dataAttr(dragging),\n        onPointerDown(event) {\n          if (event.button !== 0) return;\n          const point = getEventPoint(event);\n          send({ type: \"thumb.pointerdown\", orientation, point });\n        },\n        style: {\n          ...orientation === \"vertical\" && {\n            height: \"var(--thumb-height)\"\n          },\n          ...orientation === \"horizontal\" && {\n            width: \"var(--thumb-width)\"\n          }\n        }\n      });\n    },\n    getCornerProps() {\n      return normalize.element({\n        ...parts.corner.attrs,\n        \"data-ownedby\": getRootId(scope),\n        \"data-hover\": dataAttr(hovering),\n        \"data-state\": hiddenState.cornerHidden ? \"hidden\" : \"visible\",\n        \"data-overflow-x\": dataAttr(!hiddenState.scrollbarXHidden),\n        \"data-overflow-y\": dataAttr(!hiddenState.scrollbarYHidden),\n        style: {\n          position: \"absolute\",\n          bottom: 0,\n          insetInlineEnd: 0,\n          width: \"var(--corner-width)\",\n          height: \"var(--corner-height)\"\n        }\n      });\n    }\n  };\n}\nfunction getScrollOffset(element, prop, axis) {\n  if (!element) return 0;\n  const styles = getComputedStyle(element);\n  const start = axis === \"x\" ? \"Left\" : \"Top\";\n  const end = axis === \"x\" ? \"Right\" : \"Bottom\";\n  return parseFloat(styles[`${prop}${start}`]) + parseFloat(styles[`${prop}${end}`]);\n}\n\n// src/utils/scroll-sides.ts\nfunction getScrollSides(node, dir) {\n  const scrollTop = node.scrollTop;\n  const scrollLeft = node.scrollLeft;\n  const isRtl = dir === \"rtl\";\n  const threshold = 1;\n  const hasVerticalScroll = node.scrollHeight - node.clientHeight > threshold;\n  const hasHorizontalScroll = node.scrollWidth - node.clientWidth > threshold;\n  const maxScrollLeft = node.scrollWidth - node.clientWidth;\n  const maxScrollTop = node.scrollHeight - node.clientHeight;\n  let atLeft = false;\n  let atRight = false;\n  let atTop = false;\n  let atBottom = false;\n  if (hasHorizontalScroll) {\n    if (isRtl) {\n      if (scrollLeft <= 0) {\n        atLeft = Math.abs(scrollLeft) >= maxScrollLeft - threshold;\n        atRight = Math.abs(scrollLeft) <= threshold;\n      } else {\n        atLeft = scrollLeft <= threshold;\n        atRight = scrollLeft >= maxScrollLeft - threshold;\n      }\n    } else {\n      atLeft = scrollLeft <= threshold;\n      atRight = scrollLeft >= maxScrollLeft - threshold;\n    }\n  }\n  if (hasVerticalScroll) {\n    atTop = scrollTop <= threshold;\n    atBottom = scrollTop >= maxScrollTop - threshold;\n  }\n  return {\n    top: atTop,\n    right: atRight,\n    bottom: atBottom,\n    left: atLeft\n  };\n}\n\n// src/utils/timeout.ts\nvar EMPTY = 0;\nvar Timeout = class {\n  constructor() {\n    __publicField(this, \"currentId\", EMPTY);\n    __publicField(this, \"clear\", () => {\n      if (this.currentId !== EMPTY) {\n        clearTimeout(this.currentId);\n        this.currentId = EMPTY;\n      }\n    });\n    __publicField(this, \"disposeEffect\", () => {\n      return this.clear;\n    });\n  }\n  start(delay, fn) {\n    this.clear();\n    this.currentId = setTimeout(() => {\n      this.currentId = EMPTY;\n      fn();\n    }, delay);\n  }\n  isStarted() {\n    return this.currentId !== EMPTY;\n  }\n};\n\n// src/scroll-area.machine.ts\nvar MIN_THUMB_SIZE = 20;\nvar SCROLL_TIMEOUT = 1e3;\nvar machine = createMachine({\n  props({ props: props2 }) {\n    return {\n      id: \"sv\",\n      ...props2\n    };\n  },\n  context({ bindable }) {\n    return {\n      scrollingX: bindable(() => ({ defaultValue: false })),\n      scrollingY: bindable(() => ({ defaultValue: false })),\n      hovering: bindable(() => ({ defaultValue: false })),\n      dragging: bindable(() => ({ defaultValue: false })),\n      touchModality: bindable(() => ({ defaultValue: false })),\n      atSides: bindable(() => ({\n        defaultValue: { top: true, right: false, bottom: false, left: true }\n      })),\n      cornerSize: bindable(() => ({\n        defaultValue: { width: 0, height: 0 }\n      })),\n      thumbSize: bindable(() => ({\n        defaultValue: { width: 0, height: 0 }\n      })),\n      hiddenState: bindable(() => ({\n        defaultValue: {\n          scrollbarYHidden: false,\n          scrollbarXHidden: false,\n          cornerHidden: false\n        },\n        hash(a) {\n          return `Y:${a.scrollbarYHidden} X:${a.scrollbarXHidden} C:${a.cornerHidden}`;\n        }\n      }))\n    };\n  },\n  refs() {\n    return {\n      orientation: \"vertical\",\n      scrollPosition: { x: 0, y: 0 },\n      scrollYTimeout: new Timeout(),\n      scrollXTimeout: new Timeout(),\n      scrollEndTimeout: new Timeout(),\n      startX: 0,\n      startY: 0,\n      startScrollTop: 0,\n      startScrollLeft: 0,\n      programmaticScroll: true\n    };\n  },\n  initialState() {\n    return \"idle\";\n  },\n  watch({ track, prop, context, send }) {\n    track([() => prop(\"dir\"), () => context.hash(\"hiddenState\")], () => {\n      send({ type: \"thumb.measure\" });\n    });\n  },\n  effects: [\"trackContentResize\", \"trackViewportVisibility\", \"trackWheelEvent\"],\n  entry: [\"checkHovering\"],\n  exit: [\"clearTimeouts\"],\n  on: {\n    \"thumb.measure\": {\n      actions: [\"setThumbSize\"]\n    },\n    \"viewport.scroll\": {\n      actions: [\"setThumbSize\", \"setScrolling\", \"setProgrammaticScroll\"]\n    },\n    \"root.pointerenter\": {\n      actions: [\"setTouchModality\", \"setHovering\"]\n    },\n    \"root.pointerdown\": {\n      actions: [\"setTouchModality\"]\n    },\n    \"root.pointerleave\": {\n      actions: [\"clearHovering\"]\n    }\n  },\n  states: {\n    idle: {\n      on: {\n        \"scrollbar.pointerdown\": {\n          target: \"dragging\",\n          actions: [\"scrollToPointer\", \"startDragging\"]\n        },\n        \"thumb.pointerdown\": {\n          target: \"dragging\",\n          actions: [\"startDragging\"]\n        }\n      }\n    },\n    dragging: {\n      effects: [\"trackPointerMove\"],\n      on: {\n        \"thumb.pointermove\": {\n          actions: [\"setDraggingScroll\"]\n        },\n        \"scrollbar.pointerup\": {\n          target: \"idle\",\n          actions: [\"stopDragging\"]\n        },\n        \"thumb.pointerup\": {\n          target: \"idle\",\n          actions: [\"clearScrolling\", \"stopDragging\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    actions: {\n      setTouchModality({ context, event }) {\n        context.set(\"touchModality\", event.pointerType === \"touch\");\n      },\n      setHovering({ context }) {\n        context.set(\"hovering\", true);\n      },\n      clearHovering({ context }) {\n        context.set(\"hovering\", false);\n      },\n      setProgrammaticScroll({ refs }) {\n        const scrollEndTimeout = refs.get(\"scrollEndTimeout\");\n        scrollEndTimeout.start(100, () => {\n          refs.set(\"programmaticScroll\", true);\n        });\n      },\n      clearScrolling({ context, event }) {\n        context.set(event.orientation === \"vertical\" ? \"scrollingY\" : \"scrollingX\", false);\n      },\n      setThumbSize({ context, scope, prop }) {\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        const scrollableContentHeight = viewportEl.scrollHeight;\n        const scrollableContentWidth = viewportEl.scrollWidth;\n        if (scrollableContentHeight === 0 || scrollableContentWidth === 0) return;\n        const scrollbarYEl = getScrollbarYEl(scope);\n        const scrollbarXEl = getScrollbarXEl(scope);\n        const thumbYEl = getThumbYEl(scope);\n        const thumbXEl = getThumbXEl(scope);\n        const viewportHeight = viewportEl.clientHeight;\n        const viewportWidth = viewportEl.clientWidth;\n        const scrollTop = viewportEl.scrollTop;\n        const scrollLeft = viewportEl.scrollLeft;\n        const scrollbarYHidden = viewportHeight >= scrollableContentHeight;\n        const scrollbarXHidden = viewportWidth >= scrollableContentWidth;\n        const ratioX = viewportWidth / scrollableContentWidth;\n        const ratioY = viewportHeight / scrollableContentHeight;\n        const nextWidth = scrollbarXHidden ? 0 : viewportWidth;\n        const nextHeight = scrollbarYHidden ? 0 : viewportHeight;\n        const scrollbarXOffset = getScrollOffset(scrollbarXEl, \"padding\", \"x\");\n        const scrollbarYOffset = getScrollOffset(scrollbarYEl, \"padding\", \"y\");\n        const thumbXOffset = getScrollOffset(thumbXEl, \"margin\", \"x\");\n        const thumbYOffset = getScrollOffset(thumbYEl, \"margin\", \"y\");\n        const idealNextWidth = nextWidth - scrollbarXOffset - thumbXOffset;\n        const idealNextHeight = nextHeight - scrollbarYOffset - thumbYOffset;\n        const maxNextWidth = scrollbarXEl ? Math.min(scrollbarXEl.offsetWidth, idealNextWidth) : idealNextWidth;\n        const maxNextHeight = scrollbarYEl ? Math.min(scrollbarYEl.offsetHeight, idealNextHeight) : idealNextHeight;\n        const clampedNextWidth = Math.max(MIN_THUMB_SIZE, maxNextWidth * ratioX);\n        const clampedNextHeight = Math.max(MIN_THUMB_SIZE, maxNextHeight * ratioY);\n        context.set(\"thumbSize\", (prevSize) => {\n          if (prevSize.height === clampedNextHeight && prevSize.width === clampedNextWidth) {\n            return prevSize;\n          }\n          return {\n            width: clampedNextWidth,\n            height: clampedNextHeight\n          };\n        });\n        if (scrollbarYEl && thumbYEl) {\n          const maxThumbOffsetY = scrollbarYEl.offsetHeight - clampedNextHeight - scrollbarYOffset - thumbYOffset;\n          const scrollRatioY = scrollTop / (scrollableContentHeight - viewportHeight);\n          const thumbOffsetY = Math.min(maxThumbOffsetY, Math.max(0, scrollRatioY * maxThumbOffsetY));\n          thumbYEl.style.transform = `translate3d(0,${thumbOffsetY}px,0)`;\n        }\n        if (scrollbarXEl && thumbXEl) {\n          const maxThumbOffsetX = scrollbarXEl.offsetWidth - clampedNextWidth - scrollbarXOffset - thumbXOffset;\n          const scrollRatioX = scrollLeft / (scrollableContentWidth - viewportWidth);\n          const thumbOffsetX = prop(\"dir\") === \"rtl\" ? clampValue(scrollRatioX * maxThumbOffsetX, -maxThumbOffsetX, 0) : clampValue(scrollRatioX * maxThumbOffsetX, 0, maxThumbOffsetX);\n          thumbXEl.style.transform = `translate3d(${thumbOffsetX}px,0,0)`;\n        }\n        const cornerEl = getCornerEl(scope);\n        if (cornerEl) {\n          if (scrollbarXHidden || scrollbarYHidden) {\n            context.set(\"cornerSize\", { width: 0, height: 0 });\n          } else if (!scrollbarXHidden && !scrollbarYHidden) {\n            const width = scrollbarYEl?.offsetWidth || 0;\n            const height = scrollbarXEl?.offsetHeight || 0;\n            context.set(\"cornerSize\", { width, height });\n          }\n        }\n        context.set(\"hiddenState\", (prevState) => {\n          const cornerHidden = scrollbarYHidden || scrollbarXHidden;\n          if (prevState.scrollbarYHidden === scrollbarYHidden && prevState.scrollbarXHidden === scrollbarXHidden && prevState.cornerHidden === cornerHidden) {\n            return prevState;\n          }\n          return {\n            scrollbarYHidden,\n            scrollbarXHidden,\n            cornerHidden\n          };\n        });\n        context.set(\"atSides\", (prev) => {\n          const next = getScrollSides(viewportEl, prop(\"dir\"));\n          if (isEqual(prev, next)) return prev;\n          return next;\n        });\n      },\n      checkHovering({ scope, context }) {\n        const viewportEl = getViewportEl(scope);\n        if (viewportEl?.matches(\":hover\")) {\n          context.set(\"hovering\", true);\n        }\n      },\n      setScrolling({ event, refs, context, prop }) {\n        const scrollPosition = {\n          x: event.target.scrollLeft,\n          y: event.target.scrollTop\n        };\n        const scrollPositionRef = refs.get(\"scrollPosition\");\n        const offsetX = scrollPosition.x - scrollPositionRef.x;\n        const offsetY = scrollPosition.y - scrollPositionRef.y;\n        refs.set(\"scrollPosition\", scrollPosition);\n        context.set(\"atSides\", (prev) => {\n          const next = getScrollSides(event.target, prop(\"dir\"));\n          if (isEqual(prev, next)) return prev;\n          return next;\n        });\n        if (offsetY !== 0) {\n          context.set(\"scrollingY\", true);\n          refs.get(\"scrollYTimeout\").start(SCROLL_TIMEOUT, () => {\n            context.set(\"scrollingY\", false);\n          });\n        }\n        if (offsetX !== 0) {\n          context.set(\"scrollingX\", true);\n          refs.get(\"scrollXTimeout\").start(SCROLL_TIMEOUT, () => {\n            context.set(\"scrollingX\", false);\n          });\n        }\n      },\n      scrollToPointer({ event, scope, prop }) {\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        const thumbYRef = getThumbYEl(scope);\n        const scrollbarYRef = getScrollbarYEl(scope);\n        const thumbXRef = getThumbXEl(scope);\n        const scrollbarXRef = getScrollbarXEl(scope);\n        const client = event.point;\n        if (thumbYRef && scrollbarYRef && event.orientation === \"vertical\") {\n          const thumbYOffset = getScrollOffset(thumbYRef, \"margin\", \"y\");\n          const scrollbarYOffset = getScrollOffset(scrollbarYRef, \"padding\", \"y\");\n          const thumbHeight = thumbYRef.offsetHeight;\n          const trackRectY = scrollbarYRef.getBoundingClientRect();\n          const clickY = client.y - trackRectY.top - thumbHeight / 2 - scrollbarYOffset + thumbYOffset / 2;\n          const scrollableContentHeight = viewportEl.scrollHeight;\n          const viewportHeight = viewportEl.clientHeight;\n          const maxThumbOffsetY = scrollbarYRef.offsetHeight - thumbHeight - scrollbarYOffset - thumbYOffset;\n          const scrollRatioY = clickY / maxThumbOffsetY;\n          const newScrollTop = scrollRatioY * (scrollableContentHeight - viewportHeight);\n          viewportEl.scrollTop = newScrollTop;\n        }\n        if (thumbXRef && scrollbarXRef && event.orientation === \"horizontal\") {\n          const thumbXOffset = getScrollOffset(thumbXRef, \"margin\", \"x\");\n          const scrollbarXOffset = getScrollOffset(scrollbarXRef, \"padding\", \"x\");\n          const thumbWidth = thumbXRef.offsetWidth;\n          const trackRectX = scrollbarXRef.getBoundingClientRect();\n          const clickX = client.x - trackRectX.left - thumbWidth / 2 - scrollbarXOffset + thumbXOffset / 2;\n          const scrollableContentWidth = viewportEl.scrollWidth;\n          const viewportWidth = viewportEl.clientWidth;\n          const maxThumbOffsetX = scrollbarXRef.offsetWidth - thumbWidth - scrollbarXOffset - thumbXOffset;\n          const scrollRatioX = clickX / maxThumbOffsetX;\n          let newScrollLeft;\n          if (prop(\"dir\") === \"rtl\") {\n            newScrollLeft = (1 - scrollRatioX) * (scrollableContentWidth - viewportWidth);\n            if (viewportEl.scrollLeft <= 0) {\n              newScrollLeft = -newScrollLeft;\n            }\n          } else {\n            newScrollLeft = scrollRatioX * (scrollableContentWidth - viewportWidth);\n          }\n          viewportEl.scrollLeft = newScrollLeft;\n        }\n      },\n      startDragging({ event, refs, scope }) {\n        refs.set(\"startX\", event.point.x);\n        refs.set(\"startY\", event.point.y);\n        refs.set(\"orientation\", event.orientation);\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        refs.set(\"startScrollTop\", viewportEl.scrollTop);\n        refs.set(\"startScrollLeft\", viewportEl.scrollLeft);\n      },\n      setDraggingScroll({ event, refs, scope, context }) {\n        const startY = refs.get(\"startY\");\n        const startX = refs.get(\"startX\");\n        const startScrollTop = refs.get(\"startScrollTop\");\n        const startScrollLeft = refs.get(\"startScrollLeft\");\n        const client = event.point;\n        const deltaY = client.y - startY;\n        const deltaX = client.x - startX;\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        const scrollableContentHeight = viewportEl.scrollHeight;\n        const viewportHeight = viewportEl.clientHeight;\n        const scrollableContentWidth = viewportEl.scrollWidth;\n        const viewportWidth = viewportEl.clientWidth;\n        const orientation = refs.get(\"orientation\");\n        const thumbYEl = getThumbYEl(scope);\n        const scrollbarYEl = getScrollbarYEl(scope);\n        if (thumbYEl && scrollbarYEl && orientation === \"vertical\") {\n          const scrollbarYOffset = getScrollOffset(scrollbarYEl, \"padding\", \"y\");\n          const thumbYOffset = getScrollOffset(thumbYEl, \"margin\", \"y\");\n          const thumbHeight = thumbYEl.offsetHeight;\n          const maxThumbOffsetY = scrollbarYEl.offsetHeight - thumbHeight - scrollbarYOffset - thumbYOffset;\n          const scrollRatioY = deltaY / maxThumbOffsetY;\n          viewportEl.scrollTop = startScrollTop + scrollRatioY * (scrollableContentHeight - viewportHeight);\n          context.set(\"scrollingY\", true);\n          refs.get(\"scrollYTimeout\").start(SCROLL_TIMEOUT, () => {\n            context.set(\"scrollingY\", false);\n          });\n        }\n        const thumbXEl = getThumbXEl(scope);\n        const scrollbarXEl = getScrollbarXEl(scope);\n        if (thumbXEl && scrollbarXEl && orientation === \"horizontal\") {\n          const scrollbarXOffset = getScrollOffset(scrollbarXEl, \"padding\", \"x\");\n          const thumbXOffset = getScrollOffset(thumbXEl, \"margin\", \"x\");\n          const thumbWidth = thumbXEl.offsetWidth;\n          const maxThumbOffsetX = scrollbarXEl.offsetWidth - thumbWidth - scrollbarXOffset - thumbXOffset;\n          const scrollRatioX = deltaX / maxThumbOffsetX;\n          viewportEl.scrollLeft = startScrollLeft + scrollRatioX * (scrollableContentWidth - viewportWidth);\n          context.set(\"scrollingX\", true);\n          refs.get(\"scrollXTimeout\").start(SCROLL_TIMEOUT, () => {\n            context.set(\"scrollingX\", false);\n          });\n        }\n      },\n      stopDragging({ refs }) {\n        refs.set(\"orientation\", null);\n      },\n      clearTimeouts({ refs }) {\n        refs.get(\"scrollYTimeout\").clear();\n        refs.get(\"scrollXTimeout\").clear();\n        refs.get(\"scrollEndTimeout\").clear();\n      }\n    },\n    effects: {\n      trackContentResize({ scope, send }) {\n        const contentEl = getContentEl(scope);\n        const rootEl = getRootEl(scope);\n        if (!contentEl || !rootEl) return;\n        const win = scope.getWin();\n        const obs = new win.ResizeObserver(() => {\n          setTimeout(() => {\n            send({ type: \"thumb.measure\" });\n          }, 1);\n        });\n        obs.observe(contentEl);\n        obs.observe(rootEl);\n        return () => {\n          obs.disconnect();\n        };\n      },\n      trackViewportVisibility({ scope, send }) {\n        const win = scope.getWin();\n        const viewportEl = getViewportEl(scope);\n        if (!viewportEl) return;\n        const observer = new win.IntersectionObserver((entries) => {\n          entries.forEach((entry) => {\n            if (entry.intersectionRatio > 0) {\n              send({ type: \"thumb.measure\" });\n              observer.disconnect();\n            }\n          });\n        });\n        observer.observe(viewportEl);\n        return () => {\n          observer.disconnect();\n        };\n      },\n      trackWheelEvent({ scope }) {\n        const scrollbarYEl = getScrollbarYEl(scope);\n        const scrollbarXEl = getScrollbarXEl(scope);\n        if (!scrollbarYEl && !scrollbarXEl) return;\n        const onWheel = (event) => {\n          const viewportEl = getViewportEl(scope);\n          if (!viewportEl || event.ctrlKey) return;\n          const orientation = event.currentTarget.dataset.orientation;\n          if (orientation === \"vertical\") {\n            const canScrollY = viewportEl.scrollHeight > viewportEl.clientHeight;\n            const atTop = viewportEl.scrollTop === 0 && event.deltaY < 0;\n            const atBottom = viewportEl.scrollTop === viewportEl.scrollHeight - viewportEl.clientHeight && event.deltaY > 0;\n            const shouldScroll = canScrollY && event.deltaY !== 0 && !(atTop || atBottom);\n            if (!shouldScroll) return;\n            event.preventDefault();\n            viewportEl.scrollTop += event.deltaY;\n          } else if (orientation === \"horizontal\") {\n            const canScrollX = viewportEl.scrollWidth > viewportEl.clientWidth;\n            const atLeft = viewportEl.scrollLeft === 0 && event.deltaX < 0;\n            const atRight = viewportEl.scrollLeft === viewportEl.scrollWidth - viewportEl.clientWidth && event.deltaX > 0;\n            const shouldScroll = canScrollX && event.deltaX !== 0 && !(atLeft || atRight);\n            if (!shouldScroll) return;\n            event.preventDefault();\n            viewportEl.scrollLeft += event.deltaX;\n          }\n        };\n        return callAll(\n          scrollbarYEl && addDomEvent(scrollbarYEl, \"wheel\", onWheel, { passive: false }),\n          scrollbarXEl && addDomEvent(scrollbarXEl, \"wheel\", onWheel, { passive: false })\n        );\n      },\n      trackPointerMove({ scope, send, refs }) {\n        const doc = scope.getDoc();\n        const orientation = refs.get(\"orientation\");\n        return trackPointerMove(doc, {\n          onPointerMove({ point }) {\n            send({ type: \"thumb.pointermove\", orientation, point });\n          },\n          onPointerUp() {\n            send({ type: \"thumb.pointerup\", orientation });\n          }\n        });\n      }\n    }\n  }\n});\nvar props = createProps()([\"dir\", \"getRootNode\", \"ids\", \"id\"]);\nvar splitProps = createSplitProps(props);\n\nexport { anatomy, connect, machine, props, splitProps };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}