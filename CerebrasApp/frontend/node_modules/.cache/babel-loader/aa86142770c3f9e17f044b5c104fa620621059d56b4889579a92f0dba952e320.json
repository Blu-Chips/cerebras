{"ast":null,"code":"import _objectSpread from \"C:/Users/JAMES/cerebras-1/CerebrasApp/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { createAnatomy } from '@zag-js/anatomy';\nimport { addDomEvent, getOverflowAncestors, isComposingEvent, dataAttr, isLeftClick } from '@zag-js/dom-query';\nimport { trackFocusVisible, isFocusVisible } from '@zag-js/focus-visible';\nimport { getPlacement, getPlacementStyles } from '@zag-js/popper';\nimport { createStore, createSplitProps } from '@zag-js/utils';\nimport { createGuards, createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/tooltip.anatomy.ts\nvar anatomy = createAnatomy(\"tooltip\").parts(\"trigger\", \"arrow\", \"arrowTip\", \"positioner\", \"content\");\nvar parts = anatomy.build();\n\n// src/tooltip.dom.ts\nvar getTriggerId = scope => {\n  var _scope$ids$trigger, _scope$ids;\n  return (_scope$ids$trigger = (_scope$ids = scope.ids) === null || _scope$ids === void 0 ? void 0 : _scope$ids.trigger) !== null && _scope$ids$trigger !== void 0 ? _scope$ids$trigger : \"tooltip:\".concat(scope.id, \":trigger\");\n};\nvar getContentId = scope => {\n  var _scope$ids$content, _scope$ids2;\n  return (_scope$ids$content = (_scope$ids2 = scope.ids) === null || _scope$ids2 === void 0 ? void 0 : _scope$ids2.content) !== null && _scope$ids$content !== void 0 ? _scope$ids$content : \"tooltip:\".concat(scope.id, \":content\");\n};\nvar getArrowId = scope => {\n  var _scope$ids$arrow, _scope$ids3;\n  return (_scope$ids$arrow = (_scope$ids3 = scope.ids) === null || _scope$ids3 === void 0 ? void 0 : _scope$ids3.arrow) !== null && _scope$ids$arrow !== void 0 ? _scope$ids$arrow : \"tooltip:\".concat(scope.id, \":arrow\");\n};\nvar getPositionerId = scope => {\n  var _scope$ids$positioner, _scope$ids4;\n  return (_scope$ids$positioner = (_scope$ids4 = scope.ids) === null || _scope$ids4 === void 0 ? void 0 : _scope$ids4.positioner) !== null && _scope$ids$positioner !== void 0 ? _scope$ids$positioner : \"tooltip:\".concat(scope.id, \":popper\");\n};\nvar getTriggerEl = scope => scope.getById(getTriggerId(scope));\nvar getPositionerEl = scope => scope.getById(getPositionerId(scope));\nvar store = createStore({\n  id: null\n});\n\n// src/tooltip.connect.ts\nfunction connect(service, normalize) {\n  const {\n    state,\n    context,\n    send,\n    scope,\n    prop,\n    event: _event\n  } = service;\n  const id = prop(\"id\");\n  const hasAriaLabel = !!prop(\"aria-label\");\n  const open = state.matches(\"open\", \"closing\");\n  const triggerId = getTriggerId(scope);\n  const contentId = getContentId(scope);\n  const disabled = prop(\"disabled\");\n  const popperStyles = getPlacementStyles(_objectSpread(_objectSpread({}, prop(\"positioning\")), {}, {\n    placement: context.get(\"currentPlacement\")\n  }));\n  return {\n    open,\n    setOpen(nextOpen) {\n      const open2 = state.matches(\"open\", \"closing\");\n      if (open2 === nextOpen) return;\n      send({\n        type: nextOpen ? \"open\" : \"close\"\n      });\n    },\n    reposition() {\n      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      send({\n        type: \"positioning.set\",\n        options\n      });\n    },\n    getTriggerProps() {\n      return normalize.button(_objectSpread(_objectSpread({}, parts.trigger.attrs), {}, {\n        id: triggerId,\n        dir: prop(\"dir\"),\n        \"data-expanded\": dataAttr(open),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"aria-describedby\": open ? contentId : void 0,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (!prop(\"closeOnClick\")) return;\n          send({\n            type: \"close\",\n            src: \"trigger.click\"\n          });\n        },\n        onFocus(event) {\n          queueMicrotask(() => {\n            if (event.defaultPrevented) return;\n            if (disabled) return;\n            if (_event.src === \"trigger.pointerdown\") return;\n            if (!isFocusVisible()) return;\n            send({\n              type: \"open\",\n              src: \"trigger.focus\"\n            });\n          });\n        },\n        onBlur(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (id === store.get(\"id\")) {\n            send({\n              type: \"close\",\n              src: \"trigger.blur\"\n            });\n          }\n        },\n        onPointerDown(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (!isLeftClick(event)) return;\n          if (!prop(\"closeOnPointerDown\")) return;\n          if (id === store.get(\"id\")) {\n            send({\n              type: \"close\",\n              src: \"trigger.pointerdown\"\n            });\n          }\n        },\n        onPointerMove(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (event.pointerType === \"touch\") return;\n          send({\n            type: \"pointer.move\"\n          });\n        },\n        onPointerLeave() {\n          if (disabled) return;\n          send({\n            type: \"pointer.leave\"\n          });\n        },\n        onPointerCancel() {\n          if (disabled) return;\n          send({\n            type: \"pointer.leave\"\n          });\n        }\n      }));\n    },\n    getArrowProps() {\n      return normalize.element(_objectSpread(_objectSpread({\n        id: getArrowId(scope)\n      }, parts.arrow.attrs), {}, {\n        dir: prop(\"dir\"),\n        style: popperStyles.arrow\n      }));\n    },\n    getArrowTipProps() {\n      return normalize.element(_objectSpread(_objectSpread({}, parts.arrowTip.attrs), {}, {\n        dir: prop(\"dir\"),\n        style: popperStyles.arrowTip\n      }));\n    },\n    getPositionerProps() {\n      return normalize.element(_objectSpread(_objectSpread({\n        id: getPositionerId(scope)\n      }, parts.positioner.attrs), {}, {\n        dir: prop(\"dir\"),\n        style: popperStyles.floating\n      }));\n    },\n    getContentProps() {\n      return normalize.element(_objectSpread(_objectSpread({}, parts.content.attrs), {}, {\n        dir: prop(\"dir\"),\n        hidden: !open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        role: hasAriaLabel ? void 0 : \"tooltip\",\n        id: hasAriaLabel ? void 0 : contentId,\n        \"data-placement\": context.get(\"currentPlacement\"),\n        onPointerEnter() {\n          send({\n            type: \"content.pointer.move\"\n          });\n        },\n        onPointerLeave() {\n          send({\n            type: \"content.pointer.leave\"\n          });\n        },\n        style: {\n          pointerEvents: prop(\"interactive\") ? \"auto\" : \"none\"\n        }\n      }));\n    }\n  };\n}\nvar {\n  and,\n  not\n} = createGuards();\nvar machine = createMachine({\n  initialState: _ref => {\n    let {\n      prop\n    } = _ref;\n    const open = prop(\"open\") || prop(\"defaultOpen\");\n    return open ? \"open\" : \"closed\";\n  },\n  props(_ref2) {\n    var _props2$closeOnClick, _props2$closeOnPointe;\n    let {\n      props: props2\n    } = _ref2;\n    const closeOnClick = (_props2$closeOnClick = props2.closeOnClick) !== null && _props2$closeOnClick !== void 0 ? _props2$closeOnClick : true;\n    const closeOnPointerDown = (_props2$closeOnPointe = props2.closeOnPointerDown) !== null && _props2$closeOnPointe !== void 0 ? _props2$closeOnPointe : closeOnClick;\n    return _objectSpread(_objectSpread({\n      id: \"x\",\n      openDelay: 400,\n      closeDelay: 150,\n      closeOnEscape: true,\n      interactive: false,\n      closeOnScroll: true,\n      disabled: false\n    }, props2), {}, {\n      closeOnPointerDown,\n      closeOnClick,\n      positioning: _objectSpread({\n        placement: \"bottom\"\n      }, props2.positioning)\n    });\n  },\n  effects: [\"trackFocusVisible\", \"trackStore\"],\n  context: _ref3 => {\n    let {\n      bindable\n    } = _ref3;\n    return {\n      currentPlacement: bindable(() => ({\n        defaultValue: void 0\n      })),\n      hasPointerMoveOpened: bindable(() => ({\n        defaultValue: false\n      }))\n    };\n  },\n  watch(_ref4) {\n    let {\n      track,\n      action,\n      prop\n    } = _ref4;\n    track([() => prop(\"disabled\")], () => {\n      action([\"closeIfDisabled\"]);\n    });\n    track([() => prop(\"open\")], () => {\n      action([\"toggleVisibility\"]);\n    });\n  },\n  states: {\n    closed: {\n      entry: [\"clearGlobalId\"],\n      on: {\n        \"controlled.open\": {\n          target: \"open\"\n        },\n        open: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"invokeOnOpen\"]\n        }],\n        \"pointer.leave\": {\n          actions: [\"clearPointerMoveOpened\"]\n        },\n        \"pointer.move\": [{\n          guard: and(\"noVisibleTooltip\", not(\"hasPointerMoveOpened\")),\n          target: \"opening\"\n        }, {\n          guard: not(\"hasPointerMoveOpened\"),\n          target: \"open\",\n          actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n        }]\n      }\n    },\n    opening: {\n      effects: [\"trackScroll\", \"trackPointerlockChange\", \"waitForOpenDelay\"],\n      on: {\n        \"after.openDelay\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n        }],\n        \"controlled.open\": {\n          target: \"open\"\n        },\n        \"controlled.close\": {\n          target: \"closed\"\n        },\n        open: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"invokeOnOpen\"]\n        }],\n        \"pointer.leave\": [{\n          guard: \"isOpenControlled\",\n          // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)\n          actions: [\"clearPointerMoveOpened\", \"invokeOnClose\", \"toggleVisibility\"]\n        }, {\n          target: \"closed\",\n          actions: [\"clearPointerMoveOpened\", \"invokeOnClose\"]\n        }],\n        close: [{\n          guard: \"isOpenControlled\",\n          // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)\n          actions: [\"invokeOnClose\", \"toggleVisibility\"]\n        }, {\n          target: \"closed\",\n          actions: [\"invokeOnClose\"]\n        }]\n      }\n    },\n    open: {\n      effects: [\"trackEscapeKey\", \"trackScroll\", \"trackPointerlockChange\", \"trackPositioning\"],\n      entry: [\"setGlobalId\"],\n      on: {\n        \"controlled.close\": {\n          target: \"closed\"\n        },\n        close: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"closed\",\n          actions: [\"invokeOnClose\"]\n        }],\n        \"pointer.leave\": [{\n          guard: \"isVisible\",\n          target: \"closing\",\n          actions: [\"clearPointerMoveOpened\"]\n        },\n        // == group ==\n        {\n          guard: \"isOpenControlled\",\n          actions: [\"clearPointerMoveOpened\", \"invokeOnClose\"]\n        }, {\n          target: \"closed\",\n          actions: [\"clearPointerMoveOpened\", \"invokeOnClose\"]\n        }],\n        \"content.pointer.leave\": {\n          guard: \"isInteractive\",\n          target: \"closing\"\n        },\n        \"positioning.set\": {\n          actions: [\"reposition\"]\n        }\n      }\n    },\n    closing: {\n      effects: [\"trackPositioning\", \"waitForCloseDelay\"],\n      on: {\n        \"after.closeDelay\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"closed\",\n          actions: [\"invokeOnClose\"]\n        }],\n        \"controlled.close\": {\n          target: \"closed\"\n        },\n        \"controlled.open\": {\n          target: \"open\"\n        },\n        close: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"closed\",\n          actions: [\"invokeOnClose\"]\n        }],\n        \"pointer.move\": [{\n          guard: \"isOpenControlled\",\n          // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)\n          actions: [\"setPointerMoveOpened\", \"invokeOnOpen\", \"toggleVisibility\"]\n        }, {\n          target: \"open\",\n          actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n        }],\n        \"content.pointer.move\": {\n          guard: \"isInteractive\",\n          target: \"open\"\n        },\n        \"positioning.set\": {\n          actions: [\"reposition\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      noVisibleTooltip: () => store.get(\"id\") === null,\n      isVisible: _ref5 => {\n        let {\n          prop\n        } = _ref5;\n        return prop(\"id\") === store.get(\"id\");\n      },\n      isInteractive: _ref6 => {\n        let {\n          prop\n        } = _ref6;\n        return !!prop(\"interactive\");\n      },\n      hasPointerMoveOpened: _ref7 => {\n        let {\n          context\n        } = _ref7;\n        return context.get(\"hasPointerMoveOpened\");\n      },\n      isOpenControlled: _ref8 => {\n        let {\n          prop\n        } = _ref8;\n        return prop(\"open\") !== void 0;\n      }\n    },\n    actions: {\n      setGlobalId: _ref9 => {\n        let {\n          prop\n        } = _ref9;\n        store.set(\"id\", prop(\"id\"));\n      },\n      clearGlobalId: _ref0 => {\n        let {\n          prop\n        } = _ref0;\n        if (prop(\"id\") === store.get(\"id\")) {\n          store.set(\"id\", null);\n        }\n      },\n      invokeOnOpen: _ref1 => {\n        var _prop;\n        let {\n          prop\n        } = _ref1;\n        (_prop = prop(\"onOpenChange\")) === null || _prop === void 0 || _prop({\n          open: true\n        });\n      },\n      invokeOnClose: _ref10 => {\n        var _prop2;\n        let {\n          prop\n        } = _ref10;\n        (_prop2 = prop(\"onOpenChange\")) === null || _prop2 === void 0 || _prop2({\n          open: false\n        });\n      },\n      closeIfDisabled: _ref11 => {\n        let {\n          prop,\n          send\n        } = _ref11;\n        if (!prop(\"disabled\")) return;\n        send({\n          type: \"close\",\n          src: \"disabled.change\"\n        });\n      },\n      reposition: _ref12 => {\n        let {\n          context,\n          event,\n          prop,\n          scope\n        } = _ref12;\n        if (event.type !== \"positioning.set\") return;\n        const getPositionerEl2 = () => getPositionerEl(scope);\n        return getPlacement(getTriggerEl(scope), getPositionerEl2, _objectSpread(_objectSpread(_objectSpread({}, prop(\"positioning\")), event.options), {}, {\n          defer: true,\n          listeners: false,\n          onComplete(data) {\n            context.set(\"currentPlacement\", data.placement);\n          }\n        }));\n      },\n      toggleVisibility: _ref13 => {\n        let {\n          prop,\n          event,\n          send\n        } = _ref13;\n        queueMicrotask(() => {\n          send({\n            type: prop(\"open\") ? \"controlled.open\" : \"controlled.close\",\n            previousEvent: event\n          });\n        });\n      },\n      setPointerMoveOpened: _ref14 => {\n        let {\n          context\n        } = _ref14;\n        context.set(\"hasPointerMoveOpened\", true);\n      },\n      clearPointerMoveOpened: _ref15 => {\n        let {\n          context\n        } = _ref15;\n        context.set(\"hasPointerMoveOpened\", false);\n      }\n    },\n    effects: {\n      trackFocusVisible: _ref16 => {\n        var _scope$getRootNode;\n        let {\n          scope\n        } = _ref16;\n        return trackFocusVisible({\n          root: (_scope$getRootNode = scope.getRootNode) === null || _scope$getRootNode === void 0 ? void 0 : _scope$getRootNode.call(scope)\n        });\n      },\n      trackPositioning: _ref17 => {\n        let {\n          context,\n          prop,\n          scope\n        } = _ref17;\n        if (!context.get(\"currentPlacement\")) {\n          context.set(\"currentPlacement\", prop(\"positioning\").placement);\n        }\n        const getPositionerEl2 = () => getPositionerEl(scope);\n        return getPlacement(getTriggerEl(scope), getPositionerEl2, _objectSpread(_objectSpread({}, prop(\"positioning\")), {}, {\n          defer: true,\n          onComplete(data) {\n            context.set(\"currentPlacement\", data.placement);\n          }\n        }));\n      },\n      trackPointerlockChange: _ref18 => {\n        let {\n          send,\n          scope\n        } = _ref18;\n        const doc = scope.getDoc();\n        const onChange = () => send({\n          type: \"close\",\n          src: \"pointerlock:change\"\n        });\n        return addDomEvent(doc, \"pointerlockchange\", onChange, false);\n      },\n      trackScroll: _ref19 => {\n        let {\n          send,\n          prop,\n          scope\n        } = _ref19;\n        if (!prop(\"closeOnScroll\")) return;\n        const triggerEl = getTriggerEl(scope);\n        if (!triggerEl) return;\n        const overflowParents = getOverflowAncestors(triggerEl);\n        const cleanups = overflowParents.map(overflowParent => {\n          const onScroll = () => {\n            send({\n              type: \"close\",\n              src: \"scroll\"\n            });\n          };\n          return addDomEvent(overflowParent, \"scroll\", onScroll, {\n            passive: true,\n            capture: true\n          });\n        });\n        return () => {\n          cleanups.forEach(fn => fn === null || fn === void 0 ? void 0 : fn());\n        };\n      },\n      trackStore: _ref20 => {\n        let {\n          prop,\n          send\n        } = _ref20;\n        let cleanup;\n        queueMicrotask(() => {\n          cleanup = store.subscribe(() => {\n            if (store.get(\"id\") !== prop(\"id\")) {\n              send({\n                type: \"close\",\n                src: \"id.change\"\n              });\n            }\n          });\n        });\n        return () => {\n          var _cleanup;\n          return (_cleanup = cleanup) === null || _cleanup === void 0 ? void 0 : _cleanup();\n        };\n      },\n      trackEscapeKey: _ref21 => {\n        let {\n          send,\n          prop\n        } = _ref21;\n        if (!prop(\"closeOnEscape\")) return;\n        const onKeyDown = event => {\n          if (isComposingEvent(event)) return;\n          if (event.key !== \"Escape\") return;\n          event.stopPropagation();\n          send({\n            type: \"close\",\n            src: \"keydown.escape\"\n          });\n        };\n        return addDomEvent(document, \"keydown\", onKeyDown, true);\n      },\n      waitForOpenDelay: _ref22 => {\n        let {\n          send,\n          prop\n        } = _ref22;\n        const id = setTimeout(() => {\n          send({\n            type: \"after.openDelay\"\n          });\n        }, prop(\"openDelay\"));\n        return () => clearTimeout(id);\n      },\n      waitForCloseDelay: _ref23 => {\n        let {\n          send,\n          prop\n        } = _ref23;\n        const id = setTimeout(() => {\n          send({\n            type: \"after.closeDelay\"\n          });\n        }, prop(\"closeDelay\"));\n        return () => clearTimeout(id);\n      }\n    }\n  }\n});\nvar props = createProps()([\"aria-label\", \"closeDelay\", \"closeOnEscape\", \"closeOnPointerDown\", \"closeOnScroll\", \"closeOnClick\", \"dir\", \"disabled\", \"getRootNode\", \"id\", \"ids\", \"interactive\", \"onOpenChange\", \"defaultOpen\", \"open\", \"openDelay\", \"positioning\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, props, splitProps };","map":{"version":3,"names":["createAnatomy","addDomEvent","getOverflowAncestors","isComposingEvent","dataAttr","isLeftClick","trackFocusVisible","isFocusVisible","getPlacement","getPlacementStyles","createStore","createSplitProps","createGuards","createMachine","createProps","anatomy","parts","build","getTriggerId","scope","_scope$ids$trigger","_scope$ids","ids","trigger","concat","id","getContentId","_scope$ids$content","_scope$ids2","content","getArrowId","_scope$ids$arrow","_scope$ids3","arrow","getPositionerId","_scope$ids$positioner","_scope$ids4","positioner","getTriggerEl","getById","getPositionerEl","store","connect","service","normalize","state","context","send","prop","event","_event","hasAriaLabel","open","matches","triggerId","contentId","disabled","popperStyles","_objectSpread","placement","get","setOpen","nextOpen","open2","type","reposition","options","arguments","length","undefined","getTriggerProps","button","attrs","dir","onClick","defaultPrevented","src","onFocus","queueMicrotask","onBlur","onPointerDown","onPointerMove","pointerType","onPointerLeave","onPointerCancel","getArrowProps","element","style","getArrowTipProps","arrowTip","getPositionerProps","floating","getContentProps","hidden","role","onPointerEnter","pointerEvents","and","not","machine","initialState","_ref","props","_ref2","_props2$closeOnClick","_props2$closeOnPointe","props2","closeOnClick","closeOnPointerDown","openDelay","closeDelay","closeOnEscape","interactive","closeOnScroll","positioning","effects","_ref3","bindable","currentPlacement","defaultValue","hasPointerMoveOpened","watch","_ref4","track","action","states","closed","entry","on","target","guard","actions","opening","close","closing","implementations","guards","noVisibleTooltip","isVisible","_ref5","isInteractive","_ref6","_ref7","isOpenControlled","_ref8","setGlobalId","_ref9","set","clearGlobalId","_ref0","invokeOnOpen","_ref1","_prop","invokeOnClose","_ref10","_prop2","closeIfDisabled","_ref11","_ref12","getPositionerEl2","defer","listeners","onComplete","data","toggleVisibility","_ref13","previousEvent","setPointerMoveOpened","_ref14","clearPointerMoveOpened","_ref15","_ref16","_scope$getRootNode","root","getRootNode","call","trackPositioning","_ref17","trackPointerlockChange","_ref18","doc","getDoc","onChange","trackScroll","_ref19","triggerEl","overflowParents","cleanups","map","overflowParent","onScroll","passive","capture","forEach","fn","trackStore","_ref20","cleanup","subscribe","_cleanup","trackEscapeKey","_ref21","onKeyDown","key","stopPropagation","document","waitForOpenDelay","_ref22","setTimeout","clearTimeout","waitForCloseDelay","_ref23","splitProps"],"sources":["C:/Users/JAMES/cerebras-1/CerebrasApp/frontend/node_modules/@zag-js/tooltip/dist/index.mjs"],"sourcesContent":["import { createAnatomy } from '@zag-js/anatomy';\nimport { addDomEvent, getOverflowAncestors, isComposingEvent, dataAttr, isLeftClick } from '@zag-js/dom-query';\nimport { trackFocusVisible, isFocusVisible } from '@zag-js/focus-visible';\nimport { getPlacement, getPlacementStyles } from '@zag-js/popper';\nimport { createStore, createSplitProps } from '@zag-js/utils';\nimport { createGuards, createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/tooltip.anatomy.ts\nvar anatomy = createAnatomy(\"tooltip\").parts(\"trigger\", \"arrow\", \"arrowTip\", \"positioner\", \"content\");\nvar parts = anatomy.build();\n\n// src/tooltip.dom.ts\nvar getTriggerId = (scope) => scope.ids?.trigger ?? `tooltip:${scope.id}:trigger`;\nvar getContentId = (scope) => scope.ids?.content ?? `tooltip:${scope.id}:content`;\nvar getArrowId = (scope) => scope.ids?.arrow ?? `tooltip:${scope.id}:arrow`;\nvar getPositionerId = (scope) => scope.ids?.positioner ?? `tooltip:${scope.id}:popper`;\nvar getTriggerEl = (scope) => scope.getById(getTriggerId(scope));\nvar getPositionerEl = (scope) => scope.getById(getPositionerId(scope));\nvar store = createStore({ id: null });\n\n// src/tooltip.connect.ts\nfunction connect(service, normalize) {\n  const { state, context, send, scope, prop, event: _event } = service;\n  const id = prop(\"id\");\n  const hasAriaLabel = !!prop(\"aria-label\");\n  const open = state.matches(\"open\", \"closing\");\n  const triggerId = getTriggerId(scope);\n  const contentId = getContentId(scope);\n  const disabled = prop(\"disabled\");\n  const popperStyles = getPlacementStyles({\n    ...prop(\"positioning\"),\n    placement: context.get(\"currentPlacement\")\n  });\n  return {\n    open,\n    setOpen(nextOpen) {\n      const open2 = state.matches(\"open\", \"closing\");\n      if (open2 === nextOpen) return;\n      send({ type: nextOpen ? \"open\" : \"close\" });\n    },\n    reposition(options = {}) {\n      send({ type: \"positioning.set\", options });\n    },\n    getTriggerProps() {\n      return normalize.button({\n        ...parts.trigger.attrs,\n        id: triggerId,\n        dir: prop(\"dir\"),\n        \"data-expanded\": dataAttr(open),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"aria-describedby\": open ? contentId : void 0,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (!prop(\"closeOnClick\")) return;\n          send({ type: \"close\", src: \"trigger.click\" });\n        },\n        onFocus(event) {\n          queueMicrotask(() => {\n            if (event.defaultPrevented) return;\n            if (disabled) return;\n            if (_event.src === \"trigger.pointerdown\") return;\n            if (!isFocusVisible()) return;\n            send({ type: \"open\", src: \"trigger.focus\" });\n          });\n        },\n        onBlur(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (id === store.get(\"id\")) {\n            send({ type: \"close\", src: \"trigger.blur\" });\n          }\n        },\n        onPointerDown(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (!isLeftClick(event)) return;\n          if (!prop(\"closeOnPointerDown\")) return;\n          if (id === store.get(\"id\")) {\n            send({ type: \"close\", src: \"trigger.pointerdown\" });\n          }\n        },\n        onPointerMove(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (event.pointerType === \"touch\") return;\n          send({ type: \"pointer.move\" });\n        },\n        onPointerLeave() {\n          if (disabled) return;\n          send({ type: \"pointer.leave\" });\n        },\n        onPointerCancel() {\n          if (disabled) return;\n          send({ type: \"pointer.leave\" });\n        }\n      });\n    },\n    getArrowProps() {\n      return normalize.element({\n        id: getArrowId(scope),\n        ...parts.arrow.attrs,\n        dir: prop(\"dir\"),\n        style: popperStyles.arrow\n      });\n    },\n    getArrowTipProps() {\n      return normalize.element({\n        ...parts.arrowTip.attrs,\n        dir: prop(\"dir\"),\n        style: popperStyles.arrowTip\n      });\n    },\n    getPositionerProps() {\n      return normalize.element({\n        id: getPositionerId(scope),\n        ...parts.positioner.attrs,\n        dir: prop(\"dir\"),\n        style: popperStyles.floating\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        dir: prop(\"dir\"),\n        hidden: !open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        role: hasAriaLabel ? void 0 : \"tooltip\",\n        id: hasAriaLabel ? void 0 : contentId,\n        \"data-placement\": context.get(\"currentPlacement\"),\n        onPointerEnter() {\n          send({ type: \"content.pointer.move\" });\n        },\n        onPointerLeave() {\n          send({ type: \"content.pointer.leave\" });\n        },\n        style: {\n          pointerEvents: prop(\"interactive\") ? \"auto\" : \"none\"\n        }\n      });\n    }\n  };\n}\nvar { and, not } = createGuards();\nvar machine = createMachine({\n  initialState: ({ prop }) => {\n    const open = prop(\"open\") || prop(\"defaultOpen\");\n    return open ? \"open\" : \"closed\";\n  },\n  props({ props: props2 }) {\n    const closeOnClick = props2.closeOnClick ?? true;\n    const closeOnPointerDown = props2.closeOnPointerDown ?? closeOnClick;\n    return {\n      id: \"x\",\n      openDelay: 400,\n      closeDelay: 150,\n      closeOnEscape: true,\n      interactive: false,\n      closeOnScroll: true,\n      disabled: false,\n      ...props2,\n      closeOnPointerDown,\n      closeOnClick,\n      positioning: {\n        placement: \"bottom\",\n        ...props2.positioning\n      }\n    };\n  },\n  effects: [\"trackFocusVisible\", \"trackStore\"],\n  context: ({ bindable }) => ({\n    currentPlacement: bindable(() => ({ defaultValue: void 0 })),\n    hasPointerMoveOpened: bindable(() => ({ defaultValue: false }))\n  }),\n  watch({ track, action, prop }) {\n    track([() => prop(\"disabled\")], () => {\n      action([\"closeIfDisabled\"]);\n    });\n    track([() => prop(\"open\")], () => {\n      action([\"toggleVisibility\"]);\n    });\n  },\n  states: {\n    closed: {\n      entry: [\"clearGlobalId\"],\n      on: {\n        \"controlled.open\": {\n          target: \"open\"\n        },\n        open: [\n          {\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          },\n          {\n            target: \"open\",\n            actions: [\"invokeOnOpen\"]\n          }\n        ],\n        \"pointer.leave\": {\n          actions: [\"clearPointerMoveOpened\"]\n        },\n        \"pointer.move\": [\n          {\n            guard: and(\"noVisibleTooltip\", not(\"hasPointerMoveOpened\")),\n            target: \"opening\"\n          },\n          {\n            guard: not(\"hasPointerMoveOpened\"),\n            target: \"open\",\n            actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n          }\n        ]\n      }\n    },\n    opening: {\n      effects: [\"trackScroll\", \"trackPointerlockChange\", \"waitForOpenDelay\"],\n      on: {\n        \"after.openDelay\": [\n          {\n            guard: \"isOpenControlled\",\n            actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n          },\n          {\n            target: \"open\",\n            actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n          }\n        ],\n        \"controlled.open\": {\n          target: \"open\"\n        },\n        \"controlled.close\": {\n          target: \"closed\"\n        },\n        open: [\n          {\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          },\n          {\n            target: \"open\",\n            actions: [\"invokeOnOpen\"]\n          }\n        ],\n        \"pointer.leave\": [\n          {\n            guard: \"isOpenControlled\",\n            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)\n            actions: [\"clearPointerMoveOpened\", \"invokeOnClose\", \"toggleVisibility\"]\n          },\n          {\n            target: \"closed\",\n            actions: [\"clearPointerMoveOpened\", \"invokeOnClose\"]\n          }\n        ],\n        close: [\n          {\n            guard: \"isOpenControlled\",\n            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)\n            actions: [\"invokeOnClose\", \"toggleVisibility\"]\n          },\n          {\n            target: \"closed\",\n            actions: [\"invokeOnClose\"]\n          }\n        ]\n      }\n    },\n    open: {\n      effects: [\"trackEscapeKey\", \"trackScroll\", \"trackPointerlockChange\", \"trackPositioning\"],\n      entry: [\"setGlobalId\"],\n      on: {\n        \"controlled.close\": {\n          target: \"closed\"\n        },\n        close: [\n          {\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          },\n          {\n            target: \"closed\",\n            actions: [\"invokeOnClose\"]\n          }\n        ],\n        \"pointer.leave\": [\n          {\n            guard: \"isVisible\",\n            target: \"closing\",\n            actions: [\"clearPointerMoveOpened\"]\n          },\n          // == group ==\n          {\n            guard: \"isOpenControlled\",\n            actions: [\"clearPointerMoveOpened\", \"invokeOnClose\"]\n          },\n          {\n            target: \"closed\",\n            actions: [\"clearPointerMoveOpened\", \"invokeOnClose\"]\n          }\n        ],\n        \"content.pointer.leave\": {\n          guard: \"isInteractive\",\n          target: \"closing\"\n        },\n        \"positioning.set\": {\n          actions: [\"reposition\"]\n        }\n      }\n    },\n    closing: {\n      effects: [\"trackPositioning\", \"waitForCloseDelay\"],\n      on: {\n        \"after.closeDelay\": [\n          {\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          },\n          {\n            target: \"closed\",\n            actions: [\"invokeOnClose\"]\n          }\n        ],\n        \"controlled.close\": {\n          target: \"closed\"\n        },\n        \"controlled.open\": {\n          target: \"open\"\n        },\n        close: [\n          {\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          },\n          {\n            target: \"closed\",\n            actions: [\"invokeOnClose\"]\n          }\n        ],\n        \"pointer.move\": [\n          {\n            guard: \"isOpenControlled\",\n            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)\n            actions: [\"setPointerMoveOpened\", \"invokeOnOpen\", \"toggleVisibility\"]\n          },\n          {\n            target: \"open\",\n            actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n          }\n        ],\n        \"content.pointer.move\": {\n          guard: \"isInteractive\",\n          target: \"open\"\n        },\n        \"positioning.set\": {\n          actions: [\"reposition\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      noVisibleTooltip: () => store.get(\"id\") === null,\n      isVisible: ({ prop }) => prop(\"id\") === store.get(\"id\"),\n      isInteractive: ({ prop }) => !!prop(\"interactive\"),\n      hasPointerMoveOpened: ({ context }) => context.get(\"hasPointerMoveOpened\"),\n      isOpenControlled: ({ prop }) => prop(\"open\") !== void 0\n    },\n    actions: {\n      setGlobalId: ({ prop }) => {\n        store.set(\"id\", prop(\"id\"));\n      },\n      clearGlobalId: ({ prop }) => {\n        if (prop(\"id\") === store.get(\"id\")) {\n          store.set(\"id\", null);\n        }\n      },\n      invokeOnOpen: ({ prop }) => {\n        prop(\"onOpenChange\")?.({ open: true });\n      },\n      invokeOnClose: ({ prop }) => {\n        prop(\"onOpenChange\")?.({ open: false });\n      },\n      closeIfDisabled: ({ prop, send }) => {\n        if (!prop(\"disabled\")) return;\n        send({ type: \"close\", src: \"disabled.change\" });\n      },\n      reposition: ({ context, event, prop, scope }) => {\n        if (event.type !== \"positioning.set\") return;\n        const getPositionerEl2 = () => getPositionerEl(scope);\n        return getPlacement(getTriggerEl(scope), getPositionerEl2, {\n          ...prop(\"positioning\"),\n          ...event.options,\n          defer: true,\n          listeners: false,\n          onComplete(data) {\n            context.set(\"currentPlacement\", data.placement);\n          }\n        });\n      },\n      toggleVisibility: ({ prop, event, send }) => {\n        queueMicrotask(() => {\n          send({\n            type: prop(\"open\") ? \"controlled.open\" : \"controlled.close\",\n            previousEvent: event\n          });\n        });\n      },\n      setPointerMoveOpened: ({ context }) => {\n        context.set(\"hasPointerMoveOpened\", true);\n      },\n      clearPointerMoveOpened: ({ context }) => {\n        context.set(\"hasPointerMoveOpened\", false);\n      }\n    },\n    effects: {\n      trackFocusVisible: ({ scope }) => {\n        return trackFocusVisible({ root: scope.getRootNode?.() });\n      },\n      trackPositioning: ({ context, prop, scope }) => {\n        if (!context.get(\"currentPlacement\")) {\n          context.set(\"currentPlacement\", prop(\"positioning\").placement);\n        }\n        const getPositionerEl2 = () => getPositionerEl(scope);\n        return getPlacement(getTriggerEl(scope), getPositionerEl2, {\n          ...prop(\"positioning\"),\n          defer: true,\n          onComplete(data) {\n            context.set(\"currentPlacement\", data.placement);\n          }\n        });\n      },\n      trackPointerlockChange: ({ send, scope }) => {\n        const doc = scope.getDoc();\n        const onChange = () => send({ type: \"close\", src: \"pointerlock:change\" });\n        return addDomEvent(doc, \"pointerlockchange\", onChange, false);\n      },\n      trackScroll: ({ send, prop, scope }) => {\n        if (!prop(\"closeOnScroll\")) return;\n        const triggerEl = getTriggerEl(scope);\n        if (!triggerEl) return;\n        const overflowParents = getOverflowAncestors(triggerEl);\n        const cleanups = overflowParents.map((overflowParent) => {\n          const onScroll = () => {\n            send({ type: \"close\", src: \"scroll\" });\n          };\n          return addDomEvent(overflowParent, \"scroll\", onScroll, {\n            passive: true,\n            capture: true\n          });\n        });\n        return () => {\n          cleanups.forEach((fn) => fn?.());\n        };\n      },\n      trackStore: ({ prop, send }) => {\n        let cleanup;\n        queueMicrotask(() => {\n          cleanup = store.subscribe(() => {\n            if (store.get(\"id\") !== prop(\"id\")) {\n              send({ type: \"close\", src: \"id.change\" });\n            }\n          });\n        });\n        return () => cleanup?.();\n      },\n      trackEscapeKey: ({ send, prop }) => {\n        if (!prop(\"closeOnEscape\")) return;\n        const onKeyDown = (event) => {\n          if (isComposingEvent(event)) return;\n          if (event.key !== \"Escape\") return;\n          event.stopPropagation();\n          send({ type: \"close\", src: \"keydown.escape\" });\n        };\n        return addDomEvent(document, \"keydown\", onKeyDown, true);\n      },\n      waitForOpenDelay: ({ send, prop }) => {\n        const id = setTimeout(() => {\n          send({ type: \"after.openDelay\" });\n        }, prop(\"openDelay\"));\n        return () => clearTimeout(id);\n      },\n      waitForCloseDelay: ({ send, prop }) => {\n        const id = setTimeout(() => {\n          send({ type: \"after.closeDelay\" });\n        }, prop(\"closeDelay\"));\n        return () => clearTimeout(id);\n      }\n    }\n  }\n});\nvar props = createProps()([\n  \"aria-label\",\n  \"closeDelay\",\n  \"closeOnEscape\",\n  \"closeOnPointerDown\",\n  \"closeOnScroll\",\n  \"closeOnClick\",\n  \"dir\",\n  \"disabled\",\n  \"getRootNode\",\n  \"id\",\n  \"ids\",\n  \"interactive\",\n  \"onOpenChange\",\n  \"defaultOpen\",\n  \"open\",\n  \"openDelay\",\n  \"positioning\"\n]);\nvar splitProps = createSplitProps(props);\n\nexport { anatomy, connect, machine, props, splitProps };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}