{"ast":null,"code":"\"use strict\";\n\nimport { getReferences } from './references.js';\nconst addCssVariables = {\n  type: \"extensions\",\n  enforce: \"pre\",\n  name: \"tokens/css-var\",\n  transform(token, dictionary) {\n    const {\n      prefix,\n      formatCssVar\n    } = dictionary;\n    const {\n      negative,\n      originalPath\n    } = token.extensions;\n    const path = negative ? originalPath : token.path;\n    return {\n      cssVar: formatCssVar(path.filter(Boolean), prefix)\n    };\n  }\n};\nconst addConditionalCssVariables = {\n  enforce: \"post\",\n  type: \"value\",\n  name: \"tokens/conditionals\",\n  transform(token, dictionary) {\n    const {\n      prefix,\n      formatCssVar\n    } = dictionary;\n    const refs = getReferences(token.value);\n    if (!refs.length) return token.value;\n    refs.forEach(ref => {\n      const variable = formatCssVar(ref.split(\".\"), prefix);\n      token.value = token.value.replace(\"{\".concat(variable.ref, \"}\"), variable);\n    });\n    return token.value;\n  }\n};\nconst addColorPalette = {\n  type: \"extensions\",\n  enforce: \"pre\",\n  name: \"tokens/colors/colorPalette\",\n  match(token) {\n    return token.extensions.category === \"colors\" && !token.extensions.virtual;\n  },\n  transform(token, dict) {\n    let path = token.path.slice();\n    path.pop();\n    path.shift();\n    if (path.length === 0) {\n      const newPath = [...token.path];\n      newPath.shift();\n      path = newPath;\n    }\n    if (path.length === 0) {\n      return {};\n    }\n    const roots = path.reduce((acc, _, i, arr) => {\n      const next = arr.slice(0, i + 1);\n      acc.push(next);\n      return acc;\n    }, []);\n    const root = path[0];\n    const value = dict.formatTokenName(path);\n    const keys = token.path.slice(token.path.indexOf(root) + 1).reduce((acc, _, i, arr) => {\n      acc.push(arr.slice(i));\n      return acc;\n    }, []);\n    if (keys.length === 0) {\n      keys.push([\"\"]);\n    }\n    return {\n      colorPalette: {\n        value,\n        roots,\n        keys\n      }\n    };\n  }\n};\nconst tokenTransforms = [addCssVariables, addConditionalCssVariables, addColorPalette];\nexport { addColorPalette, addConditionalCssVariables, addCssVariables, tokenTransforms };","map":{"version":3,"names":["getReferences","addCssVariables","type","enforce","name","transform","token","dictionary","prefix","formatCssVar","negative","originalPath","extensions","path","cssVar","filter","Boolean","addConditionalCssVariables","refs","value","length","forEach","ref","variable","split","replace","concat","addColorPalette","match","category","virtual","dict","slice","pop","shift","newPath","roots","reduce","acc","_","i","arr","next","push","root","formatTokenName","keys","indexOf","colorPalette","tokenTransforms"],"sources":["C:/Users/JAMES/cerebras-1/CerebrasApp/frontend/node_modules/@chakra-ui/react/dist/esm/styled-system/token-transforms.js"],"sourcesContent":["\"use strict\";\nimport { getReferences } from './references.js';\n\nconst addCssVariables = {\n  type: \"extensions\",\n  enforce: \"pre\",\n  name: \"tokens/css-var\",\n  transform(token, dictionary) {\n    const { prefix, formatCssVar } = dictionary;\n    const { negative, originalPath } = token.extensions;\n    const path = negative ? originalPath : token.path;\n    return {\n      cssVar: formatCssVar(path.filter(Boolean), prefix)\n    };\n  }\n};\nconst addConditionalCssVariables = {\n  enforce: \"post\",\n  type: \"value\",\n  name: \"tokens/conditionals\",\n  transform(token, dictionary) {\n    const { prefix, formatCssVar } = dictionary;\n    const refs = getReferences(token.value);\n    if (!refs.length) return token.value;\n    refs.forEach((ref) => {\n      const variable = formatCssVar(ref.split(\".\"), prefix);\n      token.value = token.value.replace(`{${variable.ref}}`, variable);\n    });\n    return token.value;\n  }\n};\nconst addColorPalette = {\n  type: \"extensions\",\n  enforce: \"pre\",\n  name: \"tokens/colors/colorPalette\",\n  match(token) {\n    return token.extensions.category === \"colors\" && !token.extensions.virtual;\n  },\n  transform(token, dict) {\n    let path = token.path.slice();\n    path.pop();\n    path.shift();\n    if (path.length === 0) {\n      const newPath = [...token.path];\n      newPath.shift();\n      path = newPath;\n    }\n    if (path.length === 0) {\n      return {};\n    }\n    const roots = path.reduce((acc, _, i, arr) => {\n      const next = arr.slice(0, i + 1);\n      acc.push(next);\n      return acc;\n    }, []);\n    const root = path[0];\n    const value = dict.formatTokenName(path);\n    const keys = token.path.slice(token.path.indexOf(root) + 1).reduce((acc, _, i, arr) => {\n      acc.push(arr.slice(i));\n      return acc;\n    }, []);\n    if (keys.length === 0) {\n      keys.push([\"\"]);\n    }\n    return {\n      colorPalette: { value, roots, keys }\n    };\n  }\n};\nconst tokenTransforms = [\n  addCssVariables,\n  addConditionalCssVariables,\n  addColorPalette\n];\n\nexport { addColorPalette, addConditionalCssVariables, addCssVariables, tokenTransforms };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}