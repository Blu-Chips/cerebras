{"ast":null,"code":"\"use strict\";\n\nimport _objectSpread from \"C:/Users/JAMES/cerebras-1/CerebrasApp/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { compact } from '../utils/compact.js';\nimport { createProps } from '../utils/create-props.js';\nimport { isString, isObject, isFunction } from '../utils/is.js';\nimport { memo } from '../utils/memo.js';\nimport { mapObject, walkObject } from '../utils/walk-object.js';\nimport { cssVar } from './css-var.js';\nimport { esc } from './esc.js';\nimport { expandTokenReferences } from './expand-reference.js';\nimport { mapToJson } from './map-to-json.js';\nimport { hasReference, expandReferences, getReferences, TOKEN_PATH_REGEX } from './references.js';\nimport { tokenMiddlewares } from './token-middleware.js';\nimport { tokenTransforms } from './token-transforms.js';\nconst isToken = value => {\n  return isObject(value) && Object.prototype.hasOwnProperty.call(value, \"value\");\n};\nfunction expandBreakpoints(breakpoints) {\n  if (!breakpoints) return {\n    breakpoints: {},\n    sizes: {}\n  };\n  return {\n    breakpoints: mapObject(breakpoints, value => ({\n      value\n    })),\n    sizes: Object.fromEntries(Object.entries(breakpoints).map(_ref => {\n      let [key, value] = _ref;\n      return [\"breakpoint-\".concat(key), {\n        value\n      }];\n    }))\n  };\n}\nfunction createTokenDictionary(options) {\n  const {\n    prefix = \"\",\n    tokens = {},\n    semanticTokens = {},\n    breakpoints = {}\n  } = options;\n  const formatTokenName = path => path.join(\".\");\n  const formatCssVar = (path, prefix2) => cssVar(path.join(\"-\"), {\n    prefix: prefix2\n  });\n  const allTokens = [];\n  const tokenNameMap = /* @__PURE__ */new Map();\n  const conditionMap = /* @__PURE__ */new Map();\n  const cssVarMap = /* @__PURE__ */new Map();\n  const colorPaletteMap = /* @__PURE__ */new Map();\n  const flatMap = /* @__PURE__ */new Map();\n  const byCategory = /* @__PURE__ */new Map();\n  const categoryMap = /* @__PURE__ */new Map();\n  const transforms = /* @__PURE__ */new Map();\n  const middlewares = [];\n  function registerToken(token, phase) {\n    allTokens.push(token);\n    tokenNameMap.set(token.name, token);\n    if (phase) {\n      transforms.forEach(fn => {\n        if (fn.enforce === phase) transformToken(fn, token);\n      });\n    }\n  }\n  const breakpointTokens = expandBreakpoints(breakpoints);\n  const computedTokens = compact(_objectSpread(_objectSpread({}, tokens), {}, {\n    breakpoints: breakpointTokens.breakpoints,\n    sizes: _objectSpread(_objectSpread({}, tokens.sizes), breakpointTokens.sizes)\n  }));\n  function registerTokens() {\n    walkObject(computedTokens, (entry, path) => {\n      const isDefault = path.includes(\"DEFAULT\");\n      path = filterDefault(path);\n      const category = path[0];\n      const name = formatTokenName(path);\n      const t = isString(entry) ? {\n        value: entry\n      } : entry;\n      const token = {\n        value: t.value,\n        originalValue: t.value,\n        name,\n        path,\n        extensions: {\n          condition: \"base\",\n          originalPath: path,\n          category,\n          prop: formatTokenName(path.slice(1))\n        }\n      };\n      if (isDefault) {\n        token.extensions.default = true;\n      }\n      registerToken(token);\n    }, {\n      stop: isToken\n    });\n    walkObject(semanticTokens, (entry, path) => {\n      const isDefault = path.includes(\"DEFAULT\");\n      path = filterBaseCondition(filterDefault(path));\n      const category = path[0];\n      const name = formatTokenName(path);\n      const t = isString(entry.value) ? {\n        value: {\n          base: entry.value\n        }\n      } : entry;\n      const token = {\n        value: t.value.base || \"\",\n        originalValue: t.value.base || \"\",\n        name,\n        path,\n        extensions: {\n          originalPath: path,\n          category,\n          conditions: t.value,\n          condition: \"base\",\n          prop: formatTokenName(path.slice(1))\n        }\n      };\n      if (isDefault) {\n        token.extensions.default = true;\n      }\n      registerToken(token);\n    }, {\n      stop: isToken\n    });\n  }\n  function getByName(name) {\n    return tokenNameMap.get(name);\n  }\n  function buildConditionMap(token) {\n    const {\n      condition\n    } = token.extensions;\n    if (!condition) return;\n    if (!conditionMap.has(condition)) {\n      conditionMap.set(condition, /* @__PURE__ */new Set());\n    }\n    conditionMap.get(condition).add(token);\n  }\n  function buildCategoryMap(token) {\n    const {\n      category,\n      prop\n    } = token.extensions;\n    if (!category) return;\n    if (!categoryMap.has(category)) {\n      categoryMap.set(category, /* @__PURE__ */new Map());\n    }\n    categoryMap.get(category).set(prop, token);\n  }\n  function buildCssVars(token) {\n    const {\n      condition,\n      negative,\n      virtual,\n      cssVar: cssVar2\n    } = token.extensions;\n    if (negative || virtual || !condition || !cssVar2) return;\n    if (!cssVarMap.has(condition)) {\n      cssVarMap.set(condition, /* @__PURE__ */new Map());\n    }\n    cssVarMap.get(condition).set(cssVar2.var, token.value);\n  }\n  function buildFlatMap(token) {\n    const {\n      category,\n      prop,\n      cssVar: cssVar2,\n      negative\n    } = token.extensions;\n    if (!category) return;\n    if (!byCategory.has(category)) {\n      byCategory.set(category, /* @__PURE__ */new Map());\n    }\n    const value = negative ? token.extensions.conditions ? token.originalValue : token.value : cssVar2.ref;\n    byCategory.get(category).set(prop, value);\n    flatMap.set([category, prop].join(\".\"), value);\n  }\n  function buildColorPalette(token) {\n    const {\n      colorPalette,\n      virtual,\n      default: isDefault\n    } = token.extensions;\n    if (!colorPalette || virtual) return;\n    colorPalette.roots.forEach(root => {\n      const name = formatTokenName(root);\n      if (!colorPaletteMap.has(name)) {\n        colorPaletteMap.set(name, /* @__PURE__ */new Map());\n      }\n      const virtualPath = replaceRootWithColorPalette([...token.path], [...root]);\n      const virtualName = formatTokenName(virtualPath);\n      const virtualToken = getByName(virtualName);\n      if (!virtualToken || !virtualToken.extensions.cssVar) return;\n      const {\n        var: virtualVar\n      } = virtualToken.extensions.cssVar;\n      colorPaletteMap.get(name).set(virtualVar, token.extensions.cssVar.ref);\n      if (isDefault && root.length === 1) {\n        var _colorPalette$keys$;\n        const colorPaletteName = formatTokenName([\"colors\", \"colorPalette\"]);\n        const colorPaletteToken = getByName(colorPaletteName);\n        if (!colorPaletteToken) return;\n        const name2 = formatTokenName(token.path);\n        const virtualToken2 = getByName(name2);\n        if (!virtualToken2) return;\n        const keyPath = (_colorPalette$keys$ = colorPalette.keys[0]) === null || _colorPalette$keys$ === void 0 ? void 0 : _colorPalette$keys$.filter(Boolean);\n        if (!keyPath.length) return;\n        const computedName = formatTokenName(root.concat(keyPath));\n        if (!colorPaletteMap.has(computedName)) {\n          colorPaletteMap.set(computedName, /* @__PURE__ */new Map());\n        }\n        colorPaletteMap.get(computedName).set(colorPaletteToken.extensions.cssVar.var, virtualToken2.extensions.cssVar.ref);\n      }\n    });\n  }\n  let byCategoryJson = {};\n  function setupViews() {\n    allTokens.forEach(token => {\n      buildConditionMap(token);\n      buildCategoryMap(token);\n      buildCssVars(token);\n      buildFlatMap(token);\n      buildColorPalette(token);\n    });\n    byCategoryJson = mapToJson(byCategory);\n  }\n  const colorMix = (value, tokenFn) => {\n    var _getByName;\n    if (!value || typeof value !== \"string\") return {\n      invalid: true,\n      value\n    };\n    const [colorPath, rawOpacity] = value.split(\"/\");\n    if (!colorPath || !rawOpacity) {\n      return {\n        invalid: true,\n        value: colorPath\n      };\n    }\n    const colorToken = tokenFn(colorPath);\n    const opacityToken = (_getByName = getByName(\"opacity.\".concat(rawOpacity))) === null || _getByName === void 0 ? void 0 : _getByName.value;\n    if (!opacityToken && isNaN(Number(rawOpacity))) {\n      return {\n        invalid: true,\n        value: colorPath\n      };\n    }\n    const percent = opacityToken ? Number(opacityToken) * 100 + \"%\" : \"\".concat(rawOpacity, \"%\");\n    const color = colorToken !== null && colorToken !== void 0 ? colorToken : colorPath;\n    return {\n      invalid: false,\n      color,\n      value: \"color-mix(in srgb, \".concat(color, \" \").concat(percent, \", transparent)\")\n    };\n  };\n  const getVar = memo((value, fallback) => {\n    var _flatMap$get;\n    return (_flatMap$get = flatMap.get(value)) !== null && _flatMap$get !== void 0 ? _flatMap$get : fallback;\n  });\n  const getCategoryValues = memo(category => {\n    return byCategoryJson[category] || null;\n  });\n  const expandReferenceInValue = memo(value => {\n    return expandTokenReferences(value, path => {\n      if (!path) return;\n      if (path.includes(\"/\")) {\n        const mix = colorMix(path, v => getVar(v));\n        if (mix.invalid) {\n          throw new Error(\"Invalid color mix at \" + path + \": \" + mix.value);\n        }\n        return mix.value;\n      }\n      const resolved = getVar(path);\n      if (resolved) return resolved;\n      return TOKEN_PATH_REGEX.test(path) ? esc(path) : path;\n    });\n  });\n  const dictionary = {\n    prefix,\n    allTokens,\n    tokenMap: tokenNameMap,\n    registerToken,\n    getByName,\n    formatTokenName,\n    formatCssVar,\n    flatMap,\n    cssVarMap,\n    categoryMap,\n    colorPaletteMap,\n    getVar,\n    getCategoryValues,\n    expandReferenceInValue\n  };\n  function registerTransform() {\n    for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n      fns[_key] = arguments[_key];\n    }\n    fns.forEach(fn => {\n      transforms.set(fn.name, fn);\n    });\n  }\n  function registerMiddleware() {\n    middlewares.push(...arguments);\n  }\n  function transformToken(transform, token) {\n    if (token.extensions.references) return;\n    if (isFunction(transform.match) && !transform.match(token)) return;\n    const fn = v => transform.transform(v, dictionary);\n    const transformed = fn(token);\n    switch (true) {\n      case transform.type === \"extensions\":\n        Object.assign(token.extensions, transformed);\n        break;\n      case transform.type === \"value\":\n        token.value = transformed;\n        break;\n      default:\n        token[transform.type] = transformed;\n        break;\n    }\n  }\n  function applyMiddlewares(enforce) {\n    middlewares.forEach(middleware => {\n      if (middleware.enforce === enforce) {\n        middleware.transform(dictionary);\n      }\n    });\n  }\n  function applyTransforms(enforce) {\n    transforms.forEach(transform => {\n      if (transform.enforce === enforce) {\n        allTokens.forEach(token => {\n          transformToken(transform, token);\n        });\n      }\n    });\n  }\n  function addConditionalTokens() {\n    allTokens.forEach(token => {\n      const tokens2 = getConditionalTokens(token);\n      if (!tokens2 || tokens2.length === 0) return;\n      tokens2.forEach(token2 => {\n        registerToken(token2);\n      });\n    });\n  }\n  function getTokenReferences(value) {\n    const refs = getReferences(value);\n    return refs.map(ref => getByName(ref)).filter(Boolean);\n  }\n  function addReferences() {\n    allTokens.forEach(token => {\n      if (!hasReference(token.value)) return;\n      const references = getTokenReferences(token.value);\n      token.extensions.references = references.reduce((acc, ref) => {\n        acc[ref.name] = ref;\n        return acc;\n      }, {});\n    });\n  }\n  function expandTokenReferences$1() {\n    allTokens.forEach(token => {\n      expandReferences(token);\n    });\n  }\n  function build() {\n    applyMiddlewares(\"pre\");\n    applyTransforms(\"pre\");\n    addConditionalTokens();\n    addReferences();\n    expandTokenReferences$1();\n    applyMiddlewares(\"post\");\n    applyTransforms(\"post\");\n    setupViews();\n  }\n  registerTokens();\n  registerTransform(...tokenTransforms);\n  registerMiddleware(...tokenMiddlewares);\n  build();\n  return dictionary;\n}\nfunction filterDefault(path) {\n  if (path[0] === \"DEFAULT\") return path;\n  return path.filter(item => item !== \"DEFAULT\");\n}\nfunction filterBaseCondition(path) {\n  return path.filter(item => item !== \"base\");\n}\nfunction getConditionalTokens(token) {\n  if (!token.extensions.conditions) return;\n  const {\n    conditions\n  } = token.extensions;\n  const tokens = [];\n  walkObject(conditions, (value, path) => {\n    const nextPath = filterBaseCondition(path);\n    if (!nextPath.length) return;\n    const nextToken = structuredClone(token);\n    nextToken.value = value;\n    nextToken.extensions.condition = nextPath.join(\":\");\n    tokens.push(nextToken);\n  });\n  return tokens;\n}\nfunction replaceRootWithColorPalette(path, roots) {\n  const startIndex = path.findIndex((_, index) => roots.every((rootElement, rootIndex) => path[index + rootIndex] === rootElement));\n  if (startIndex === -1) {\n    return path;\n  }\n  path.splice(startIndex, roots.length);\n  path.splice(startIndex, 0, \"colorPalette\");\n  return path;\n}\nconst tokenCategories = createProps()([\"aspectRatios\", \"zIndex\", \"opacity\", \"colors\", \"fonts\", \"fontSizes\", \"fontWeights\", \"lineHeights\", \"letterSpacings\", \"sizes\", \"shadows\", \"spacing\", \"radii\", \"cursor\", \"borders\", \"borderWidths\", \"borderStyles\", \"durations\", \"easings\", \"animations\", \"blurs\", \"gradients\", \"breakpoints\", \"assets\"]);\nexport { createTokenDictionary, tokenCategories };","map":{"version":3,"names":["_objectSpread","compact","createProps","isString","isObject","isFunction","memo","mapObject","walkObject","cssVar","esc","expandTokenReferences","mapToJson","hasReference","expandReferences","getReferences","TOKEN_PATH_REGEX","tokenMiddlewares","tokenTransforms","isToken","value","Object","prototype","hasOwnProperty","call","expandBreakpoints","breakpoints","sizes","fromEntries","entries","map","_ref","key","concat","createTokenDictionary","options","prefix","tokens","semanticTokens","formatTokenName","path","join","formatCssVar","prefix2","allTokens","tokenNameMap","Map","conditionMap","cssVarMap","colorPaletteMap","flatMap","byCategory","categoryMap","transforms","middlewares","registerToken","token","phase","push","set","name","forEach","fn","enforce","transformToken","breakpointTokens","computedTokens","registerTokens","entry","isDefault","includes","filterDefault","category","t","originalValue","extensions","condition","originalPath","prop","slice","default","stop","filterBaseCondition","base","conditions","getByName","get","buildConditionMap","has","Set","add","buildCategoryMap","buildCssVars","negative","virtual","cssVar2","var","buildFlatMap","ref","buildColorPalette","colorPalette","roots","root","virtualPath","replaceRootWithColorPalette","virtualName","virtualToken","virtualVar","length","_colorPalette$keys$","colorPaletteName","colorPaletteToken","name2","virtualToken2","keyPath","keys","filter","Boolean","computedName","byCategoryJson","setupViews","colorMix","tokenFn","_getByName","invalid","colorPath","rawOpacity","split","colorToken","opacityToken","isNaN","Number","percent","color","getVar","fallback","_flatMap$get","getCategoryValues","expandReferenceInValue","mix","v","Error","resolved","test","dictionary","tokenMap","registerTransform","_len","arguments","fns","Array","_key","registerMiddleware","transform","references","match","transformed","type","assign","applyMiddlewares","middleware","applyTransforms","addConditionalTokens","tokens2","getConditionalTokens","token2","getTokenReferences","refs","addReferences","reduce","acc","expandTokenReferences$1","build","item","nextPath","nextToken","structuredClone","startIndex","findIndex","_","index","every","rootElement","rootIndex","splice","tokenCategories"],"sources":["C:/Users/JAMES/cerebras-1/CerebrasApp/frontend/node_modules/@chakra-ui/react/dist/esm/styled-system/token-dictionary.js"],"sourcesContent":["\"use strict\";\nimport { compact } from '../utils/compact.js';\nimport { createProps } from '../utils/create-props.js';\nimport { isString, isObject, isFunction } from '../utils/is.js';\nimport { memo } from '../utils/memo.js';\nimport { mapObject, walkObject } from '../utils/walk-object.js';\nimport { cssVar } from './css-var.js';\nimport { esc } from './esc.js';\nimport { expandTokenReferences } from './expand-reference.js';\nimport { mapToJson } from './map-to-json.js';\nimport { hasReference, expandReferences, getReferences, TOKEN_PATH_REGEX } from './references.js';\nimport { tokenMiddlewares } from './token-middleware.js';\nimport { tokenTransforms } from './token-transforms.js';\n\nconst isToken = (value) => {\n  return isObject(value) && Object.prototype.hasOwnProperty.call(value, \"value\");\n};\nfunction expandBreakpoints(breakpoints) {\n  if (!breakpoints) return { breakpoints: {}, sizes: {} };\n  return {\n    breakpoints: mapObject(breakpoints, (value) => ({ value })),\n    sizes: Object.fromEntries(\n      Object.entries(breakpoints).map(([key, value]) => [\n        `breakpoint-${key}`,\n        { value }\n      ])\n    )\n  };\n}\nfunction createTokenDictionary(options) {\n  const {\n    prefix = \"\",\n    tokens = {},\n    semanticTokens = {},\n    breakpoints = {}\n  } = options;\n  const formatTokenName = (path) => path.join(\".\");\n  const formatCssVar = (path, prefix2) => cssVar(path.join(\"-\"), { prefix: prefix2 });\n  const allTokens = [];\n  const tokenNameMap = /* @__PURE__ */ new Map();\n  const conditionMap = /* @__PURE__ */ new Map();\n  const cssVarMap = /* @__PURE__ */ new Map();\n  const colorPaletteMap = /* @__PURE__ */ new Map();\n  const flatMap = /* @__PURE__ */ new Map();\n  const byCategory = /* @__PURE__ */ new Map();\n  const categoryMap = /* @__PURE__ */ new Map();\n  const transforms = /* @__PURE__ */ new Map();\n  const middlewares = [];\n  function registerToken(token, phase) {\n    allTokens.push(token);\n    tokenNameMap.set(token.name, token);\n    if (phase) {\n      transforms.forEach((fn) => {\n        if (fn.enforce === phase) transformToken(fn, token);\n      });\n    }\n  }\n  const breakpointTokens = expandBreakpoints(breakpoints);\n  const computedTokens = compact({\n    ...tokens,\n    breakpoints: breakpointTokens.breakpoints,\n    sizes: {\n      ...tokens.sizes,\n      ...breakpointTokens.sizes\n    }\n  });\n  function registerTokens() {\n    walkObject(\n      computedTokens,\n      (entry, path) => {\n        const isDefault = path.includes(\"DEFAULT\");\n        path = filterDefault(path);\n        const category = path[0];\n        const name = formatTokenName(path);\n        const t = isString(entry) ? { value: entry } : entry;\n        const token = {\n          value: t.value,\n          originalValue: t.value,\n          name,\n          path,\n          extensions: {\n            condition: \"base\",\n            originalPath: path,\n            category,\n            prop: formatTokenName(path.slice(1))\n          }\n        };\n        if (isDefault) {\n          token.extensions.default = true;\n        }\n        registerToken(token);\n      },\n      { stop: isToken }\n    );\n    walkObject(\n      semanticTokens,\n      (entry, path) => {\n        const isDefault = path.includes(\"DEFAULT\");\n        path = filterBaseCondition(filterDefault(path));\n        const category = path[0];\n        const name = formatTokenName(path);\n        const t = isString(entry.value) ? { value: { base: entry.value } } : entry;\n        const token = {\n          value: t.value.base || \"\",\n          originalValue: t.value.base || \"\",\n          name,\n          path,\n          extensions: {\n            originalPath: path,\n            category,\n            conditions: t.value,\n            condition: \"base\",\n            prop: formatTokenName(path.slice(1))\n          }\n        };\n        if (isDefault) {\n          token.extensions.default = true;\n        }\n        registerToken(token);\n      },\n      { stop: isToken }\n    );\n  }\n  function getByName(name) {\n    return tokenNameMap.get(name);\n  }\n  function buildConditionMap(token) {\n    const { condition } = token.extensions;\n    if (!condition) return;\n    if (!conditionMap.has(condition)) {\n      conditionMap.set(condition, /* @__PURE__ */ new Set());\n    }\n    conditionMap.get(condition).add(token);\n  }\n  function buildCategoryMap(token) {\n    const { category, prop } = token.extensions;\n    if (!category) return;\n    if (!categoryMap.has(category)) {\n      categoryMap.set(category, /* @__PURE__ */ new Map());\n    }\n    categoryMap.get(category).set(prop, token);\n  }\n  function buildCssVars(token) {\n    const { condition, negative, virtual, cssVar: cssVar2 } = token.extensions;\n    if (negative || virtual || !condition || !cssVar2) return;\n    if (!cssVarMap.has(condition)) {\n      cssVarMap.set(condition, /* @__PURE__ */ new Map());\n    }\n    cssVarMap.get(condition).set(cssVar2.var, token.value);\n  }\n  function buildFlatMap(token) {\n    const { category, prop, cssVar: cssVar2, negative } = token.extensions;\n    if (!category) return;\n    if (!byCategory.has(category)) {\n      byCategory.set(category, /* @__PURE__ */ new Map());\n    }\n    const value = negative ? token.extensions.conditions ? token.originalValue : token.value : cssVar2.ref;\n    byCategory.get(category).set(prop, value);\n    flatMap.set([category, prop].join(\".\"), value);\n  }\n  function buildColorPalette(token) {\n    const { colorPalette, virtual, default: isDefault } = token.extensions;\n    if (!colorPalette || virtual) return;\n    colorPalette.roots.forEach((root) => {\n      const name = formatTokenName(root);\n      if (!colorPaletteMap.has(name)) {\n        colorPaletteMap.set(name, /* @__PURE__ */ new Map());\n      }\n      const virtualPath = replaceRootWithColorPalette(\n        [...token.path],\n        [...root]\n      );\n      const virtualName = formatTokenName(virtualPath);\n      const virtualToken = getByName(virtualName);\n      if (!virtualToken || !virtualToken.extensions.cssVar) return;\n      const { var: virtualVar } = virtualToken.extensions.cssVar;\n      colorPaletteMap.get(name).set(virtualVar, token.extensions.cssVar.ref);\n      if (isDefault && root.length === 1) {\n        const colorPaletteName = formatTokenName([\"colors\", \"colorPalette\"]);\n        const colorPaletteToken = getByName(colorPaletteName);\n        if (!colorPaletteToken) return;\n        const name2 = formatTokenName(token.path);\n        const virtualToken2 = getByName(name2);\n        if (!virtualToken2) return;\n        const keyPath = colorPalette.keys[0]?.filter(Boolean);\n        if (!keyPath.length) return;\n        const computedName = formatTokenName(root.concat(keyPath));\n        if (!colorPaletteMap.has(computedName)) {\n          colorPaletteMap.set(computedName, /* @__PURE__ */ new Map());\n        }\n        colorPaletteMap.get(computedName).set(\n          colorPaletteToken.extensions.cssVar.var,\n          virtualToken2.extensions.cssVar.ref\n        );\n      }\n    });\n  }\n  let byCategoryJson = {};\n  function setupViews() {\n    allTokens.forEach((token) => {\n      buildConditionMap(token);\n      buildCategoryMap(token);\n      buildCssVars(token);\n      buildFlatMap(token);\n      buildColorPalette(token);\n    });\n    byCategoryJson = mapToJson(byCategory);\n  }\n  const colorMix = (value, tokenFn) => {\n    if (!value || typeof value !== \"string\") return { invalid: true, value };\n    const [colorPath, rawOpacity] = value.split(\"/\");\n    if (!colorPath || !rawOpacity) {\n      return { invalid: true, value: colorPath };\n    }\n    const colorToken = tokenFn(colorPath);\n    const opacityToken = getByName(`opacity.${rawOpacity}`)?.value;\n    if (!opacityToken && isNaN(Number(rawOpacity))) {\n      return { invalid: true, value: colorPath };\n    }\n    const percent = opacityToken ? Number(opacityToken) * 100 + \"%\" : `${rawOpacity}%`;\n    const color = colorToken ?? colorPath;\n    return {\n      invalid: false,\n      color,\n      value: `color-mix(in srgb, ${color} ${percent}, transparent)`\n    };\n  };\n  const getVar = memo((value, fallback) => {\n    return flatMap.get(value) ?? fallback;\n  });\n  const getCategoryValues = memo((category) => {\n    return byCategoryJson[category] || null;\n  });\n  const expandReferenceInValue = memo((value) => {\n    return expandTokenReferences(value, (path) => {\n      if (!path) return;\n      if (path.includes(\"/\")) {\n        const mix = colorMix(path, (v) => getVar(v));\n        if (mix.invalid) {\n          throw new Error(\"Invalid color mix at \" + path + \": \" + mix.value);\n        }\n        return mix.value;\n      }\n      const resolved = getVar(path);\n      if (resolved) return resolved;\n      return TOKEN_PATH_REGEX.test(path) ? esc(path) : path;\n    });\n  });\n  const dictionary = {\n    prefix,\n    allTokens,\n    tokenMap: tokenNameMap,\n    registerToken,\n    getByName,\n    formatTokenName,\n    formatCssVar,\n    flatMap,\n    cssVarMap,\n    categoryMap,\n    colorPaletteMap,\n    getVar,\n    getCategoryValues,\n    expandReferenceInValue\n  };\n  function registerTransform(...fns) {\n    fns.forEach((fn) => {\n      transforms.set(fn.name, fn);\n    });\n  }\n  function registerMiddleware(...fns) {\n    middlewares.push(...fns);\n  }\n  function transformToken(transform, token) {\n    if (token.extensions.references) return;\n    if (isFunction(transform.match) && !transform.match(token)) return;\n    const fn = (v) => transform.transform(v, dictionary);\n    const transformed = fn(token);\n    switch (true) {\n      case transform.type === \"extensions\":\n        Object.assign(token.extensions, transformed);\n        break;\n      case transform.type === \"value\":\n        token.value = transformed;\n        break;\n      default:\n        token[transform.type] = transformed;\n        break;\n    }\n  }\n  function applyMiddlewares(enforce) {\n    middlewares.forEach((middleware) => {\n      if (middleware.enforce === enforce) {\n        middleware.transform(dictionary);\n      }\n    });\n  }\n  function applyTransforms(enforce) {\n    transforms.forEach((transform) => {\n      if (transform.enforce === enforce) {\n        allTokens.forEach((token) => {\n          transformToken(transform, token);\n        });\n      }\n    });\n  }\n  function addConditionalTokens() {\n    allTokens.forEach((token) => {\n      const tokens2 = getConditionalTokens(token);\n      if (!tokens2 || tokens2.length === 0) return;\n      tokens2.forEach((token2) => {\n        registerToken(token2);\n      });\n    });\n  }\n  function getTokenReferences(value) {\n    const refs = getReferences(value);\n    return refs.map((ref) => getByName(ref)).filter(Boolean);\n  }\n  function addReferences() {\n    allTokens.forEach((token) => {\n      if (!hasReference(token.value)) return;\n      const references = getTokenReferences(token.value);\n      token.extensions.references = references.reduce((acc, ref) => {\n        acc[ref.name] = ref;\n        return acc;\n      }, {});\n    });\n  }\n  function expandTokenReferences$1() {\n    allTokens.forEach((token) => {\n      expandReferences(token);\n    });\n  }\n  function build() {\n    applyMiddlewares(\"pre\");\n    applyTransforms(\"pre\");\n    addConditionalTokens();\n    addReferences();\n    expandTokenReferences$1();\n    applyMiddlewares(\"post\");\n    applyTransforms(\"post\");\n    setupViews();\n  }\n  registerTokens();\n  registerTransform(...tokenTransforms);\n  registerMiddleware(...tokenMiddlewares);\n  build();\n  return dictionary;\n}\nfunction filterDefault(path) {\n  if (path[0] === \"DEFAULT\") return path;\n  return path.filter((item) => item !== \"DEFAULT\");\n}\nfunction filterBaseCondition(path) {\n  return path.filter((item) => item !== \"base\");\n}\nfunction getConditionalTokens(token) {\n  if (!token.extensions.conditions) return;\n  const { conditions } = token.extensions;\n  const tokens = [];\n  walkObject(conditions, (value, path) => {\n    const nextPath = filterBaseCondition(path);\n    if (!nextPath.length) return;\n    const nextToken = structuredClone(token);\n    nextToken.value = value;\n    nextToken.extensions.condition = nextPath.join(\":\");\n    tokens.push(nextToken);\n  });\n  return tokens;\n}\nfunction replaceRootWithColorPalette(path, roots) {\n  const startIndex = path.findIndex(\n    (_, index) => roots.every(\n      (rootElement, rootIndex) => path[index + rootIndex] === rootElement\n    )\n  );\n  if (startIndex === -1) {\n    return path;\n  }\n  path.splice(startIndex, roots.length);\n  path.splice(startIndex, 0, \"colorPalette\");\n  return path;\n}\nconst tokenCategories = createProps()([\n  \"aspectRatios\",\n  \"zIndex\",\n  \"opacity\",\n  \"colors\",\n  \"fonts\",\n  \"fontSizes\",\n  \"fontWeights\",\n  \"lineHeights\",\n  \"letterSpacings\",\n  \"sizes\",\n  \"shadows\",\n  \"spacing\",\n  \"radii\",\n  \"cursor\",\n  \"borders\",\n  \"borderWidths\",\n  \"borderStyles\",\n  \"durations\",\n  \"easings\",\n  \"animations\",\n  \"blurs\",\n  \"gradients\",\n  \"breakpoints\",\n  \"assets\"\n]);\n\nexport { createTokenDictionary, tokenCategories };\n"],"mappings":"AAAA,YAAY;;AAAC,OAAAA,aAAA;AACb,SAASC,OAAO,QAAQ,qBAAqB;AAC7C,SAASC,WAAW,QAAQ,0BAA0B;AACtD,SAASC,QAAQ,EAAEC,QAAQ,EAAEC,UAAU,QAAQ,gBAAgB;AAC/D,SAASC,IAAI,QAAQ,kBAAkB;AACvC,SAASC,SAAS,EAAEC,UAAU,QAAQ,yBAAyB;AAC/D,SAASC,MAAM,QAAQ,cAAc;AACrC,SAASC,GAAG,QAAQ,UAAU;AAC9B,SAASC,qBAAqB,QAAQ,uBAAuB;AAC7D,SAASC,SAAS,QAAQ,kBAAkB;AAC5C,SAASC,YAAY,EAAEC,gBAAgB,EAAEC,aAAa,EAAEC,gBAAgB,QAAQ,iBAAiB;AACjG,SAASC,gBAAgB,QAAQ,uBAAuB;AACxD,SAASC,eAAe,QAAQ,uBAAuB;AAEvD,MAAMC,OAAO,GAAIC,KAAK,IAAK;EACzB,OAAOhB,QAAQ,CAACgB,KAAK,CAAC,IAAIC,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACJ,KAAK,EAAE,OAAO,CAAC;AAChF,CAAC;AACD,SAASK,iBAAiBA,CAACC,WAAW,EAAE;EACtC,IAAI,CAACA,WAAW,EAAE,OAAO;IAAEA,WAAW,EAAE,CAAC,CAAC;IAAEC,KAAK,EAAE,CAAC;EAAE,CAAC;EACvD,OAAO;IACLD,WAAW,EAAEnB,SAAS,CAACmB,WAAW,EAAGN,KAAK,KAAM;MAAEA;IAAM,CAAC,CAAC,CAAC;IAC3DO,KAAK,EAAEN,MAAM,CAACO,WAAW,CACvBP,MAAM,CAACQ,OAAO,CAACH,WAAW,CAAC,CAACI,GAAG,CAACC,IAAA;MAAA,IAAC,CAACC,GAAG,EAAEZ,KAAK,CAAC,GAAAW,IAAA;MAAA,OAAK,eAAAE,MAAA,CAClCD,GAAG,GACjB;QAAEZ;MAAM,CAAC,CACV;IAAA,EACH;EACF,CAAC;AACH;AACA,SAASc,qBAAqBA,CAACC,OAAO,EAAE;EACtC,MAAM;IACJC,MAAM,GAAG,EAAE;IACXC,MAAM,GAAG,CAAC,CAAC;IACXC,cAAc,GAAG,CAAC,CAAC;IACnBZ,WAAW,GAAG,CAAC;EACjB,CAAC,GAAGS,OAAO;EACX,MAAMI,eAAe,GAAIC,IAAI,IAAKA,IAAI,CAACC,IAAI,CAAC,GAAG,CAAC;EAChD,MAAMC,YAAY,GAAGA,CAACF,IAAI,EAAEG,OAAO,KAAKlC,MAAM,CAAC+B,IAAI,CAACC,IAAI,CAAC,GAAG,CAAC,EAAE;IAAEL,MAAM,EAAEO;EAAQ,CAAC,CAAC;EACnF,MAAMC,SAAS,GAAG,EAAE;EACpB,MAAMC,YAAY,GAAG,eAAgB,IAAIC,GAAG,CAAC,CAAC;EAC9C,MAAMC,YAAY,GAAG,eAAgB,IAAID,GAAG,CAAC,CAAC;EAC9C,MAAME,SAAS,GAAG,eAAgB,IAAIF,GAAG,CAAC,CAAC;EAC3C,MAAMG,eAAe,GAAG,eAAgB,IAAIH,GAAG,CAAC,CAAC;EACjD,MAAMI,OAAO,GAAG,eAAgB,IAAIJ,GAAG,CAAC,CAAC;EACzC,MAAMK,UAAU,GAAG,eAAgB,IAAIL,GAAG,CAAC,CAAC;EAC5C,MAAMM,WAAW,GAAG,eAAgB,IAAIN,GAAG,CAAC,CAAC;EAC7C,MAAMO,UAAU,GAAG,eAAgB,IAAIP,GAAG,CAAC,CAAC;EAC5C,MAAMQ,WAAW,GAAG,EAAE;EACtB,SAASC,aAAaA,CAACC,KAAK,EAAEC,KAAK,EAAE;IACnCb,SAAS,CAACc,IAAI,CAACF,KAAK,CAAC;IACrBX,YAAY,CAACc,GAAG,CAACH,KAAK,CAACI,IAAI,EAAEJ,KAAK,CAAC;IACnC,IAAIC,KAAK,EAAE;MACTJ,UAAU,CAACQ,OAAO,CAAEC,EAAE,IAAK;QACzB,IAAIA,EAAE,CAACC,OAAO,KAAKN,KAAK,EAAEO,cAAc,CAACF,EAAE,EAAEN,KAAK,CAAC;MACrD,CAAC,CAAC;IACJ;EACF;EACA,MAAMS,gBAAgB,GAAGxC,iBAAiB,CAACC,WAAW,CAAC;EACvD,MAAMwC,cAAc,GAAGjE,OAAO,CAAAD,aAAA,CAAAA,aAAA,KACzBqC,MAAM;IACTX,WAAW,EAAEuC,gBAAgB,CAACvC,WAAW;IACzCC,KAAK,EAAA3B,aAAA,CAAAA,aAAA,KACAqC,MAAM,CAACV,KAAK,GACZsC,gBAAgB,CAACtC,KAAK;EAC1B,EACF,CAAC;EACF,SAASwC,cAAcA,CAAA,EAAG;IACxB3D,UAAU,CACR0D,cAAc,EACd,CAACE,KAAK,EAAE5B,IAAI,KAAK;MACf,MAAM6B,SAAS,GAAG7B,IAAI,CAAC8B,QAAQ,CAAC,SAAS,CAAC;MAC1C9B,IAAI,GAAG+B,aAAa,CAAC/B,IAAI,CAAC;MAC1B,MAAMgC,QAAQ,GAAGhC,IAAI,CAAC,CAAC,CAAC;MACxB,MAAMoB,IAAI,GAAGrB,eAAe,CAACC,IAAI,CAAC;MAClC,MAAMiC,CAAC,GAAGtE,QAAQ,CAACiE,KAAK,CAAC,GAAG;QAAEhD,KAAK,EAAEgD;MAAM,CAAC,GAAGA,KAAK;MACpD,MAAMZ,KAAK,GAAG;QACZpC,KAAK,EAAEqD,CAAC,CAACrD,KAAK;QACdsD,aAAa,EAAED,CAAC,CAACrD,KAAK;QACtBwC,IAAI;QACJpB,IAAI;QACJmC,UAAU,EAAE;UACVC,SAAS,EAAE,MAAM;UACjBC,YAAY,EAAErC,IAAI;UAClBgC,QAAQ;UACRM,IAAI,EAAEvC,eAAe,CAACC,IAAI,CAACuC,KAAK,CAAC,CAAC,CAAC;QACrC;MACF,CAAC;MACD,IAAIV,SAAS,EAAE;QACbb,KAAK,CAACmB,UAAU,CAACK,OAAO,GAAG,IAAI;MACjC;MACAzB,aAAa,CAACC,KAAK,CAAC;IACtB,CAAC,EACD;MAAEyB,IAAI,EAAE9D;IAAQ,CAClB,CAAC;IACDX,UAAU,CACR8B,cAAc,EACd,CAAC8B,KAAK,EAAE5B,IAAI,KAAK;MACf,MAAM6B,SAAS,GAAG7B,IAAI,CAAC8B,QAAQ,CAAC,SAAS,CAAC;MAC1C9B,IAAI,GAAG0C,mBAAmB,CAACX,aAAa,CAAC/B,IAAI,CAAC,CAAC;MAC/C,MAAMgC,QAAQ,GAAGhC,IAAI,CAAC,CAAC,CAAC;MACxB,MAAMoB,IAAI,GAAGrB,eAAe,CAACC,IAAI,CAAC;MAClC,MAAMiC,CAAC,GAAGtE,QAAQ,CAACiE,KAAK,CAAChD,KAAK,CAAC,GAAG;QAAEA,KAAK,EAAE;UAAE+D,IAAI,EAAEf,KAAK,CAAChD;QAAM;MAAE,CAAC,GAAGgD,KAAK;MAC1E,MAAMZ,KAAK,GAAG;QACZpC,KAAK,EAAEqD,CAAC,CAACrD,KAAK,CAAC+D,IAAI,IAAI,EAAE;QACzBT,aAAa,EAAED,CAAC,CAACrD,KAAK,CAAC+D,IAAI,IAAI,EAAE;QACjCvB,IAAI;QACJpB,IAAI;QACJmC,UAAU,EAAE;UACVE,YAAY,EAAErC,IAAI;UAClBgC,QAAQ;UACRY,UAAU,EAAEX,CAAC,CAACrD,KAAK;UACnBwD,SAAS,EAAE,MAAM;UACjBE,IAAI,EAAEvC,eAAe,CAACC,IAAI,CAACuC,KAAK,CAAC,CAAC,CAAC;QACrC;MACF,CAAC;MACD,IAAIV,SAAS,EAAE;QACbb,KAAK,CAACmB,UAAU,CAACK,OAAO,GAAG,IAAI;MACjC;MACAzB,aAAa,CAACC,KAAK,CAAC;IACtB,CAAC,EACD;MAAEyB,IAAI,EAAE9D;IAAQ,CAClB,CAAC;EACH;EACA,SAASkE,SAASA,CAACzB,IAAI,EAAE;IACvB,OAAOf,YAAY,CAACyC,GAAG,CAAC1B,IAAI,CAAC;EAC/B;EACA,SAAS2B,iBAAiBA,CAAC/B,KAAK,EAAE;IAChC,MAAM;MAAEoB;IAAU,CAAC,GAAGpB,KAAK,CAACmB,UAAU;IACtC,IAAI,CAACC,SAAS,EAAE;IAChB,IAAI,CAAC7B,YAAY,CAACyC,GAAG,CAACZ,SAAS,CAAC,EAAE;MAChC7B,YAAY,CAACY,GAAG,CAACiB,SAAS,EAAE,eAAgB,IAAIa,GAAG,CAAC,CAAC,CAAC;IACxD;IACA1C,YAAY,CAACuC,GAAG,CAACV,SAAS,CAAC,CAACc,GAAG,CAAClC,KAAK,CAAC;EACxC;EACA,SAASmC,gBAAgBA,CAACnC,KAAK,EAAE;IAC/B,MAAM;MAAEgB,QAAQ;MAAEM;IAAK,CAAC,GAAGtB,KAAK,CAACmB,UAAU;IAC3C,IAAI,CAACH,QAAQ,EAAE;IACf,IAAI,CAACpB,WAAW,CAACoC,GAAG,CAAChB,QAAQ,CAAC,EAAE;MAC9BpB,WAAW,CAACO,GAAG,CAACa,QAAQ,EAAE,eAAgB,IAAI1B,GAAG,CAAC,CAAC,CAAC;IACtD;IACAM,WAAW,CAACkC,GAAG,CAACd,QAAQ,CAAC,CAACb,GAAG,CAACmB,IAAI,EAAEtB,KAAK,CAAC;EAC5C;EACA,SAASoC,YAAYA,CAACpC,KAAK,EAAE;IAC3B,MAAM;MAAEoB,SAAS;MAAEiB,QAAQ;MAAEC,OAAO;MAAErF,MAAM,EAAEsF;IAAQ,CAAC,GAAGvC,KAAK,CAACmB,UAAU;IAC1E,IAAIkB,QAAQ,IAAIC,OAAO,IAAI,CAAClB,SAAS,IAAI,CAACmB,OAAO,EAAE;IACnD,IAAI,CAAC/C,SAAS,CAACwC,GAAG,CAACZ,SAAS,CAAC,EAAE;MAC7B5B,SAAS,CAACW,GAAG,CAACiB,SAAS,EAAE,eAAgB,IAAI9B,GAAG,CAAC,CAAC,CAAC;IACrD;IACAE,SAAS,CAACsC,GAAG,CAACV,SAAS,CAAC,CAACjB,GAAG,CAACoC,OAAO,CAACC,GAAG,EAAExC,KAAK,CAACpC,KAAK,CAAC;EACxD;EACA,SAAS6E,YAAYA,CAACzC,KAAK,EAAE;IAC3B,MAAM;MAAEgB,QAAQ;MAAEM,IAAI;MAAErE,MAAM,EAAEsF,OAAO;MAAEF;IAAS,CAAC,GAAGrC,KAAK,CAACmB,UAAU;IACtE,IAAI,CAACH,QAAQ,EAAE;IACf,IAAI,CAACrB,UAAU,CAACqC,GAAG,CAAChB,QAAQ,CAAC,EAAE;MAC7BrB,UAAU,CAACQ,GAAG,CAACa,QAAQ,EAAE,eAAgB,IAAI1B,GAAG,CAAC,CAAC,CAAC;IACrD;IACA,MAAM1B,KAAK,GAAGyE,QAAQ,GAAGrC,KAAK,CAACmB,UAAU,CAACS,UAAU,GAAG5B,KAAK,CAACkB,aAAa,GAAGlB,KAAK,CAACpC,KAAK,GAAG2E,OAAO,CAACG,GAAG;IACtG/C,UAAU,CAACmC,GAAG,CAACd,QAAQ,CAAC,CAACb,GAAG,CAACmB,IAAI,EAAE1D,KAAK,CAAC;IACzC8B,OAAO,CAACS,GAAG,CAAC,CAACa,QAAQ,EAAEM,IAAI,CAAC,CAACrC,IAAI,CAAC,GAAG,CAAC,EAAErB,KAAK,CAAC;EAChD;EACA,SAAS+E,iBAAiBA,CAAC3C,KAAK,EAAE;IAChC,MAAM;MAAE4C,YAAY;MAAEN,OAAO;MAAEd,OAAO,EAAEX;IAAU,CAAC,GAAGb,KAAK,CAACmB,UAAU;IACtE,IAAI,CAACyB,YAAY,IAAIN,OAAO,EAAE;IAC9BM,YAAY,CAACC,KAAK,CAACxC,OAAO,CAAEyC,IAAI,IAAK;MACnC,MAAM1C,IAAI,GAAGrB,eAAe,CAAC+D,IAAI,CAAC;MAClC,IAAI,CAACrD,eAAe,CAACuC,GAAG,CAAC5B,IAAI,CAAC,EAAE;QAC9BX,eAAe,CAACU,GAAG,CAACC,IAAI,EAAE,eAAgB,IAAId,GAAG,CAAC,CAAC,CAAC;MACtD;MACA,MAAMyD,WAAW,GAAGC,2BAA2B,CAC7C,CAAC,GAAGhD,KAAK,CAAChB,IAAI,CAAC,EACf,CAAC,GAAG8D,IAAI,CACV,CAAC;MACD,MAAMG,WAAW,GAAGlE,eAAe,CAACgE,WAAW,CAAC;MAChD,MAAMG,YAAY,GAAGrB,SAAS,CAACoB,WAAW,CAAC;MAC3C,IAAI,CAACC,YAAY,IAAI,CAACA,YAAY,CAAC/B,UAAU,CAAClE,MAAM,EAAE;MACtD,MAAM;QAAEuF,GAAG,EAAEW;MAAW,CAAC,GAAGD,YAAY,CAAC/B,UAAU,CAAClE,MAAM;MAC1DwC,eAAe,CAACqC,GAAG,CAAC1B,IAAI,CAAC,CAACD,GAAG,CAACgD,UAAU,EAAEnD,KAAK,CAACmB,UAAU,CAAClE,MAAM,CAACyF,GAAG,CAAC;MACtE,IAAI7B,SAAS,IAAIiC,IAAI,CAACM,MAAM,KAAK,CAAC,EAAE;QAAA,IAAAC,mBAAA;QAClC,MAAMC,gBAAgB,GAAGvE,eAAe,CAAC,CAAC,QAAQ,EAAE,cAAc,CAAC,CAAC;QACpE,MAAMwE,iBAAiB,GAAG1B,SAAS,CAACyB,gBAAgB,CAAC;QACrD,IAAI,CAACC,iBAAiB,EAAE;QACxB,MAAMC,KAAK,GAAGzE,eAAe,CAACiB,KAAK,CAAChB,IAAI,CAAC;QACzC,MAAMyE,aAAa,GAAG5B,SAAS,CAAC2B,KAAK,CAAC;QACtC,IAAI,CAACC,aAAa,EAAE;QACpB,MAAMC,OAAO,IAAAL,mBAAA,GAAGT,YAAY,CAACe,IAAI,CAAC,CAAC,CAAC,cAAAN,mBAAA,uBAApBA,mBAAA,CAAsBO,MAAM,CAACC,OAAO,CAAC;QACrD,IAAI,CAACH,OAAO,CAACN,MAAM,EAAE;QACrB,MAAMU,YAAY,GAAG/E,eAAe,CAAC+D,IAAI,CAACrE,MAAM,CAACiF,OAAO,CAAC,CAAC;QAC1D,IAAI,CAACjE,eAAe,CAACuC,GAAG,CAAC8B,YAAY,CAAC,EAAE;UACtCrE,eAAe,CAACU,GAAG,CAAC2D,YAAY,EAAE,eAAgB,IAAIxE,GAAG,CAAC,CAAC,CAAC;QAC9D;QACAG,eAAe,CAACqC,GAAG,CAACgC,YAAY,CAAC,CAAC3D,GAAG,CACnCoD,iBAAiB,CAACpC,UAAU,CAAClE,MAAM,CAACuF,GAAG,EACvCiB,aAAa,CAACtC,UAAU,CAAClE,MAAM,CAACyF,GAClC,CAAC;MACH;IACF,CAAC,CAAC;EACJ;EACA,IAAIqB,cAAc,GAAG,CAAC,CAAC;EACvB,SAASC,UAAUA,CAAA,EAAG;IACpB5E,SAAS,CAACiB,OAAO,CAAEL,KAAK,IAAK;MAC3B+B,iBAAiB,CAAC/B,KAAK,CAAC;MACxBmC,gBAAgB,CAACnC,KAAK,CAAC;MACvBoC,YAAY,CAACpC,KAAK,CAAC;MACnByC,YAAY,CAACzC,KAAK,CAAC;MACnB2C,iBAAiB,CAAC3C,KAAK,CAAC;IAC1B,CAAC,CAAC;IACF+D,cAAc,GAAG3G,SAAS,CAACuC,UAAU,CAAC;EACxC;EACA,MAAMsE,QAAQ,GAAGA,CAACrG,KAAK,EAAEsG,OAAO,KAAK;IAAA,IAAAC,UAAA;IACnC,IAAI,CAACvG,KAAK,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE,OAAO;MAAEwG,OAAO,EAAE,IAAI;MAAExG;IAAM,CAAC;IACxE,MAAM,CAACyG,SAAS,EAAEC,UAAU,CAAC,GAAG1G,KAAK,CAAC2G,KAAK,CAAC,GAAG,CAAC;IAChD,IAAI,CAACF,SAAS,IAAI,CAACC,UAAU,EAAE;MAC7B,OAAO;QAAEF,OAAO,EAAE,IAAI;QAAExG,KAAK,EAAEyG;MAAU,CAAC;IAC5C;IACA,MAAMG,UAAU,GAAGN,OAAO,CAACG,SAAS,CAAC;IACrC,MAAMI,YAAY,IAAAN,UAAA,GAAGtC,SAAS,YAAApD,MAAA,CAAY6F,UAAU,CAAE,CAAC,cAAAH,UAAA,uBAAlCA,UAAA,CAAoCvG,KAAK;IAC9D,IAAI,CAAC6G,YAAY,IAAIC,KAAK,CAACC,MAAM,CAACL,UAAU,CAAC,CAAC,EAAE;MAC9C,OAAO;QAAEF,OAAO,EAAE,IAAI;QAAExG,KAAK,EAAEyG;MAAU,CAAC;IAC5C;IACA,MAAMO,OAAO,GAAGH,YAAY,GAAGE,MAAM,CAACF,YAAY,CAAC,GAAG,GAAG,GAAG,GAAG,MAAAhG,MAAA,CAAM6F,UAAU,MAAG;IAClF,MAAMO,KAAK,GAAGL,UAAU,aAAVA,UAAU,cAAVA,UAAU,GAAIH,SAAS;IACrC,OAAO;MACLD,OAAO,EAAE,KAAK;MACdS,KAAK;MACLjH,KAAK,wBAAAa,MAAA,CAAwBoG,KAAK,OAAApG,MAAA,CAAImG,OAAO;IAC/C,CAAC;EACH,CAAC;EACD,MAAME,MAAM,GAAGhI,IAAI,CAAC,CAACc,KAAK,EAAEmH,QAAQ,KAAK;IAAA,IAAAC,YAAA;IACvC,QAAAA,YAAA,GAAOtF,OAAO,CAACoC,GAAG,CAAClE,KAAK,CAAC,cAAAoH,YAAA,cAAAA,YAAA,GAAID,QAAQ;EACvC,CAAC,CAAC;EACF,MAAME,iBAAiB,GAAGnI,IAAI,CAAEkE,QAAQ,IAAK;IAC3C,OAAO+C,cAAc,CAAC/C,QAAQ,CAAC,IAAI,IAAI;EACzC,CAAC,CAAC;EACF,MAAMkE,sBAAsB,GAAGpI,IAAI,CAAEc,KAAK,IAAK;IAC7C,OAAOT,qBAAqB,CAACS,KAAK,EAAGoB,IAAI,IAAK;MAC5C,IAAI,CAACA,IAAI,EAAE;MACX,IAAIA,IAAI,CAAC8B,QAAQ,CAAC,GAAG,CAAC,EAAE;QACtB,MAAMqE,GAAG,GAAGlB,QAAQ,CAACjF,IAAI,EAAGoG,CAAC,IAAKN,MAAM,CAACM,CAAC,CAAC,CAAC;QAC5C,IAAID,GAAG,CAACf,OAAO,EAAE;UACf,MAAM,IAAIiB,KAAK,CAAC,uBAAuB,GAAGrG,IAAI,GAAG,IAAI,GAAGmG,GAAG,CAACvH,KAAK,CAAC;QACpE;QACA,OAAOuH,GAAG,CAACvH,KAAK;MAClB;MACA,MAAM0H,QAAQ,GAAGR,MAAM,CAAC9F,IAAI,CAAC;MAC7B,IAAIsG,QAAQ,EAAE,OAAOA,QAAQ;MAC7B,OAAO9H,gBAAgB,CAAC+H,IAAI,CAACvG,IAAI,CAAC,GAAG9B,GAAG,CAAC8B,IAAI,CAAC,GAAGA,IAAI;IACvD,CAAC,CAAC;EACJ,CAAC,CAAC;EACF,MAAMwG,UAAU,GAAG;IACjB5G,MAAM;IACNQ,SAAS;IACTqG,QAAQ,EAAEpG,YAAY;IACtBU,aAAa;IACb8B,SAAS;IACT9C,eAAe;IACfG,YAAY;IACZQ,OAAO;IACPF,SAAS;IACTI,WAAW;IACXH,eAAe;IACfqF,MAAM;IACNG,iBAAiB;IACjBC;EACF,CAAC;EACD,SAASQ,iBAAiBA,CAAA,EAAS;IAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAxC,MAAA,EAALyC,GAAG,OAAAC,KAAA,CAAAH,IAAA,GAAAI,IAAA,MAAAA,IAAA,GAAAJ,IAAA,EAAAI,IAAA;MAAHF,GAAG,CAAAE,IAAA,IAAAH,SAAA,CAAAG,IAAA;IAAA;IAC/BF,GAAG,CAACxF,OAAO,CAAEC,EAAE,IAAK;MAClBT,UAAU,CAACM,GAAG,CAACG,EAAE,CAACF,IAAI,EAAEE,EAAE,CAAC;IAC7B,CAAC,CAAC;EACJ;EACA,SAAS0F,kBAAkBA,CAAA,EAAS;IAClClG,WAAW,CAACI,IAAI,CAAC,GAAA0F,SAAM,CAAC;EAC1B;EACA,SAASpF,cAAcA,CAACyF,SAAS,EAAEjG,KAAK,EAAE;IACxC,IAAIA,KAAK,CAACmB,UAAU,CAAC+E,UAAU,EAAE;IACjC,IAAIrJ,UAAU,CAACoJ,SAAS,CAACE,KAAK,CAAC,IAAI,CAACF,SAAS,CAACE,KAAK,CAACnG,KAAK,CAAC,EAAE;IAC5D,MAAMM,EAAE,GAAI8E,CAAC,IAAKa,SAAS,CAACA,SAAS,CAACb,CAAC,EAAEI,UAAU,CAAC;IACpD,MAAMY,WAAW,GAAG9F,EAAE,CAACN,KAAK,CAAC;IAC7B,QAAQ,IAAI;MACV,KAAKiG,SAAS,CAACI,IAAI,KAAK,YAAY;QAClCxI,MAAM,CAACyI,MAAM,CAACtG,KAAK,CAACmB,UAAU,EAAEiF,WAAW,CAAC;QAC5C;MACF,KAAKH,SAAS,CAACI,IAAI,KAAK,OAAO;QAC7BrG,KAAK,CAACpC,KAAK,GAAGwI,WAAW;QACzB;MACF;QACEpG,KAAK,CAACiG,SAAS,CAACI,IAAI,CAAC,GAAGD,WAAW;QACnC;IACJ;EACF;EACA,SAASG,gBAAgBA,CAAChG,OAAO,EAAE;IACjCT,WAAW,CAACO,OAAO,CAAEmG,UAAU,IAAK;MAClC,IAAIA,UAAU,CAACjG,OAAO,KAAKA,OAAO,EAAE;QAClCiG,UAAU,CAACP,SAAS,CAACT,UAAU,CAAC;MAClC;IACF,CAAC,CAAC;EACJ;EACA,SAASiB,eAAeA,CAAClG,OAAO,EAAE;IAChCV,UAAU,CAACQ,OAAO,CAAE4F,SAAS,IAAK;MAChC,IAAIA,SAAS,CAAC1F,OAAO,KAAKA,OAAO,EAAE;QACjCnB,SAAS,CAACiB,OAAO,CAAEL,KAAK,IAAK;UAC3BQ,cAAc,CAACyF,SAAS,EAAEjG,KAAK,CAAC;QAClC,CAAC,CAAC;MACJ;IACF,CAAC,CAAC;EACJ;EACA,SAAS0G,oBAAoBA,CAAA,EAAG;IAC9BtH,SAAS,CAACiB,OAAO,CAAEL,KAAK,IAAK;MAC3B,MAAM2G,OAAO,GAAGC,oBAAoB,CAAC5G,KAAK,CAAC;MAC3C,IAAI,CAAC2G,OAAO,IAAIA,OAAO,CAACvD,MAAM,KAAK,CAAC,EAAE;MACtCuD,OAAO,CAACtG,OAAO,CAAEwG,MAAM,IAAK;QAC1B9G,aAAa,CAAC8G,MAAM,CAAC;MACvB,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EACA,SAASC,kBAAkBA,CAAClJ,KAAK,EAAE;IACjC,MAAMmJ,IAAI,GAAGxJ,aAAa,CAACK,KAAK,CAAC;IACjC,OAAOmJ,IAAI,CAACzI,GAAG,CAAEoE,GAAG,IAAKb,SAAS,CAACa,GAAG,CAAC,CAAC,CAACkB,MAAM,CAACC,OAAO,CAAC;EAC1D;EACA,SAASmD,aAAaA,CAAA,EAAG;IACvB5H,SAAS,CAACiB,OAAO,CAAEL,KAAK,IAAK;MAC3B,IAAI,CAAC3C,YAAY,CAAC2C,KAAK,CAACpC,KAAK,CAAC,EAAE;MAChC,MAAMsI,UAAU,GAAGY,kBAAkB,CAAC9G,KAAK,CAACpC,KAAK,CAAC;MAClDoC,KAAK,CAACmB,UAAU,CAAC+E,UAAU,GAAGA,UAAU,CAACe,MAAM,CAAC,CAACC,GAAG,EAAExE,GAAG,KAAK;QAC5DwE,GAAG,CAACxE,GAAG,CAACtC,IAAI,CAAC,GAAGsC,GAAG;QACnB,OAAOwE,GAAG;MACZ,CAAC,EAAE,CAAC,CAAC,CAAC;IACR,CAAC,CAAC;EACJ;EACA,SAASC,uBAAuBA,CAAA,EAAG;IACjC/H,SAAS,CAACiB,OAAO,CAAEL,KAAK,IAAK;MAC3B1C,gBAAgB,CAAC0C,KAAK,CAAC;IACzB,CAAC,CAAC;EACJ;EACA,SAASoH,KAAKA,CAAA,EAAG;IACfb,gBAAgB,CAAC,KAAK,CAAC;IACvBE,eAAe,CAAC,KAAK,CAAC;IACtBC,oBAAoB,CAAC,CAAC;IACtBM,aAAa,CAAC,CAAC;IACfG,uBAAuB,CAAC,CAAC;IACzBZ,gBAAgB,CAAC,MAAM,CAAC;IACxBE,eAAe,CAAC,MAAM,CAAC;IACvBzC,UAAU,CAAC,CAAC;EACd;EACArD,cAAc,CAAC,CAAC;EAChB+E,iBAAiB,CAAC,GAAGhI,eAAe,CAAC;EACrCsI,kBAAkB,CAAC,GAAGvI,gBAAgB,CAAC;EACvC2J,KAAK,CAAC,CAAC;EACP,OAAO5B,UAAU;AACnB;AACA,SAASzE,aAAaA,CAAC/B,IAAI,EAAE;EAC3B,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAK,SAAS,EAAE,OAAOA,IAAI;EACtC,OAAOA,IAAI,CAAC4E,MAAM,CAAEyD,IAAI,IAAKA,IAAI,KAAK,SAAS,CAAC;AAClD;AACA,SAAS3F,mBAAmBA,CAAC1C,IAAI,EAAE;EACjC,OAAOA,IAAI,CAAC4E,MAAM,CAAEyD,IAAI,IAAKA,IAAI,KAAK,MAAM,CAAC;AAC/C;AACA,SAAST,oBAAoBA,CAAC5G,KAAK,EAAE;EACnC,IAAI,CAACA,KAAK,CAACmB,UAAU,CAACS,UAAU,EAAE;EAClC,MAAM;IAAEA;EAAW,CAAC,GAAG5B,KAAK,CAACmB,UAAU;EACvC,MAAMtC,MAAM,GAAG,EAAE;EACjB7B,UAAU,CAAC4E,UAAU,EAAE,CAAChE,KAAK,EAAEoB,IAAI,KAAK;IACtC,MAAMsI,QAAQ,GAAG5F,mBAAmB,CAAC1C,IAAI,CAAC;IAC1C,IAAI,CAACsI,QAAQ,CAAClE,MAAM,EAAE;IACtB,MAAMmE,SAAS,GAAGC,eAAe,CAACxH,KAAK,CAAC;IACxCuH,SAAS,CAAC3J,KAAK,GAAGA,KAAK;IACvB2J,SAAS,CAACpG,UAAU,CAACC,SAAS,GAAGkG,QAAQ,CAACrI,IAAI,CAAC,GAAG,CAAC;IACnDJ,MAAM,CAACqB,IAAI,CAACqH,SAAS,CAAC;EACxB,CAAC,CAAC;EACF,OAAO1I,MAAM;AACf;AACA,SAASmE,2BAA2BA,CAAChE,IAAI,EAAE6D,KAAK,EAAE;EAChD,MAAM4E,UAAU,GAAGzI,IAAI,CAAC0I,SAAS,CAC/B,CAACC,CAAC,EAAEC,KAAK,KAAK/E,KAAK,CAACgF,KAAK,CACvB,CAACC,WAAW,EAAEC,SAAS,KAAK/I,IAAI,CAAC4I,KAAK,GAAGG,SAAS,CAAC,KAAKD,WAC1D,CACF,CAAC;EACD,IAAIL,UAAU,KAAK,CAAC,CAAC,EAAE;IACrB,OAAOzI,IAAI;EACb;EACAA,IAAI,CAACgJ,MAAM,CAACP,UAAU,EAAE5E,KAAK,CAACO,MAAM,CAAC;EACrCpE,IAAI,CAACgJ,MAAM,CAACP,UAAU,EAAE,CAAC,EAAE,cAAc,CAAC;EAC1C,OAAOzI,IAAI;AACb;AACA,MAAMiJ,eAAe,GAAGvL,WAAW,CAAC,CAAC,CAAC,CACpC,cAAc,EACd,QAAQ,EACR,SAAS,EACT,QAAQ,EACR,OAAO,EACP,WAAW,EACX,aAAa,EACb,aAAa,EACb,gBAAgB,EAChB,OAAO,EACP,SAAS,EACT,SAAS,EACT,OAAO,EACP,QAAQ,EACR,SAAS,EACT,cAAc,EACd,cAAc,EACd,WAAW,EACX,SAAS,EACT,YAAY,EACZ,OAAO,EACP,WAAW,EACX,aAAa,EACb,QAAQ,CACT,CAAC;AAEF,SAASgC,qBAAqB,EAAEuJ,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}