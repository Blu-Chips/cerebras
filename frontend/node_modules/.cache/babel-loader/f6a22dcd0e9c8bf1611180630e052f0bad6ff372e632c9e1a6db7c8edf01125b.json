{"ast":null,"code":"import _objectSpread from \"C:/Users/JAMES/cerebras-1/CerebrasApp/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { createAnatomy } from '@zag-js/anatomy';\nimport { trackPointerMove, queryAll, dataAttr, getEventKey, isLeftClick, getEventPoint } from '@zag-js/dom-query';\nimport { prev, next, ensure, isEqual, setRafTimeout, ensureProps, createSplitProps } from '@zag-js/utils';\nimport { createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/splitter.anatomy.ts\nvar anatomy = createAnatomy(\"splitter\").parts(\"root\", \"panel\", \"resizeTrigger\");\nvar parts = anatomy.build();\nvar getRootId = ctx => {\n  var _ctx$ids$root, _ctx$ids;\n  return (_ctx$ids$root = (_ctx$ids = ctx.ids) === null || _ctx$ids === void 0 ? void 0 : _ctx$ids.root) !== null && _ctx$ids$root !== void 0 ? _ctx$ids$root : \"splitter:\".concat(ctx.id);\n};\nvar getResizeTriggerId = (ctx, id) => {\n  var _ctx$ids$resizeTrigge, _ctx$ids2, _ctx$ids2$resizeTrigg;\n  return (_ctx$ids$resizeTrigge = (_ctx$ids2 = ctx.ids) === null || _ctx$ids2 === void 0 || (_ctx$ids2$resizeTrigg = _ctx$ids2.resizeTrigger) === null || _ctx$ids2$resizeTrigg === void 0 ? void 0 : _ctx$ids2$resizeTrigg.call(_ctx$ids2, id)) !== null && _ctx$ids$resizeTrigge !== void 0 ? _ctx$ids$resizeTrigge : \"splitter:\".concat(ctx.id, \":splitter:\").concat(id);\n};\nvar getPanelId = (ctx, id) => {\n  var _ctx$ids$panel, _ctx$ids3, _ctx$ids3$panel;\n  return (_ctx$ids$panel = (_ctx$ids3 = ctx.ids) === null || _ctx$ids3 === void 0 || (_ctx$ids3$panel = _ctx$ids3.panel) === null || _ctx$ids3$panel === void 0 ? void 0 : _ctx$ids3$panel.call(_ctx$ids3, id)) !== null && _ctx$ids$panel !== void 0 ? _ctx$ids$panel : \"splitter:\".concat(ctx.id, \":panel:\").concat(id);\n};\nvar getGlobalCursorId = ctx => \"splitter:\".concat(ctx.id, \":global-cursor\");\nvar getRootEl = ctx => ctx.getById(getRootId(ctx));\nvar getResizeTriggerEl = (ctx, id) => ctx.getById(getResizeTriggerId(ctx, id));\nvar getCursor = (state, x) => {\n  let cursor = x ? \"col-resize\" : \"row-resize\";\n  if (state.isAtMin) cursor = x ? \"e-resize\" : \"s-resize\";\n  if (state.isAtMax) cursor = x ? \"w-resize\" : \"n-resize\";\n  return cursor;\n};\nvar getResizeTriggerEls = ctx => {\n  return queryAll(getRootEl(ctx), \"[role=separator][data-ownedby='\".concat(CSS.escape(getRootId(ctx)), \"']\"));\n};\nvar setupGlobalCursor = (ctx, state, x, nonce) => {\n  const styleEl = ctx.getById(getGlobalCursorId(ctx));\n  const textContent = \"* { cursor: \".concat(getCursor(state, x), \" !important; }\");\n  if (styleEl) {\n    styleEl.textContent = textContent;\n  } else {\n    const style = ctx.getDoc().createElement(\"style\");\n    if (nonce) style.nonce = nonce;\n    style.id = getGlobalCursorId(ctx);\n    style.textContent = textContent;\n    ctx.getDoc().head.appendChild(style);\n  }\n};\nvar removeGlobalCursor = ctx => {\n  const styleEl = ctx.getById(getGlobalCursorId(ctx));\n  styleEl === null || styleEl === void 0 || styleEl.remove();\n};\nfunction calculateAriaValues(_ref) {\n  let {\n    size,\n    panels,\n    pivotIndices\n  } = _ref;\n  let currentMinSize = 0;\n  let currentMaxSize = 100;\n  let totalMinSize = 0;\n  let totalMaxSize = 0;\n  const firstIndex = pivotIndices[0];\n  ensure(firstIndex, () => \"No pivot index found\");\n  panels.forEach((panel, index) => {\n    const {\n      maxSize = 100,\n      minSize = 0\n    } = panel;\n    if (index === firstIndex) {\n      currentMinSize = minSize;\n      currentMaxSize = maxSize;\n    } else {\n      totalMinSize += minSize;\n      totalMaxSize += maxSize;\n    }\n  });\n  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n  const valueNow = size[firstIndex];\n  return {\n    valueMax,\n    valueMin,\n    valueNow\n  };\n}\nfunction getAriaValue(size, panels, handleId) {\n  const [beforeId, afterId] = handleId.split(\":\");\n  const beforeIndex = panels.findIndex(panel => panel.id === beforeId);\n  const afterIndex = panels.findIndex(panel => panel.id === afterId);\n  const {\n    valueMax,\n    valueMin,\n    valueNow\n  } = calculateAriaValues({\n    size,\n    panels,\n    pivotIndices: [beforeIndex, afterIndex]\n  });\n  return {\n    beforeId,\n    afterId,\n    valueMax: Math.round(valueMax),\n    valueMin: Math.round(valueMin),\n    valueNow: valueNow != null ? Math.round(valueNow) : void 0\n  };\n}\n\n// src/utils/fuzzy.ts\nvar PRECISION = 10;\nfunction fuzzyCompareNumbers(actual, expected) {\n  let fractionDigits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PRECISION;\n  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {\n    return 0;\n  } else {\n    return actual > expected ? 1 : -1;\n  }\n}\nfunction fuzzyNumbersEqual(actual, expected) {\n  let fractionDigits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PRECISION;\n  if (actual == null || expected == null) return false;\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\nfunction fuzzySizeEqual(actual, expected, fractionDigits) {\n  if (actual.length !== expected.length) {\n    return false;\n  }\n  for (let index = 0; index < actual.length; index++) {\n    const actualSize = actual[index];\n    const expectedSize = expected[index];\n    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getPanelById(panels, id) {\n  const panel = panels.find(panel2 => panel2.id === id);\n  ensure(panel, () => \"Panel data not found for id \\\"\".concat(id, \"\\\"\"));\n  return panel;\n}\nfunction findPanelDataIndex(panels, panel) {\n  return panels.findIndex(prevPanel => prevPanel === panel || prevPanel.id === panel.id);\n}\nfunction findPanelIndex(panels, id) {\n  return panels.findIndex(panel => panel.id === id);\n}\nfunction panelDataHelper(panels, panel, sizes) {\n  const index = findPanelIndex(panels, panel.id);\n  const pivotIndices = index === panels.length - 1 ? [index - 1, index] : [index, index + 1];\n  const panelSize = sizes[index];\n  return _objectSpread(_objectSpread({}, panel), {}, {\n    panelSize,\n    pivotIndices\n  });\n}\nfunction sortPanels(panels) {\n  return panels.sort((panelA, panelB) => {\n    const orderA = panelA.order;\n    const orderB = panelB.order;\n    if (orderA == null && orderB == null) {\n      return 0;\n    } else if (orderA == null) {\n      return -1;\n    } else if (orderB == null) {\n      return 1;\n    } else {\n      return orderA - orderB;\n    }\n  });\n}\nfunction getPanelLayout(panels) {\n  return panels.map(panel => panel.id).sort().join(\":\");\n}\nfunction serializePanels(panels) {\n  const keys = panels.map(panel => panel.id);\n  const sortedKeys = keys.sort();\n  const serialized = sortedKeys.map(key => {\n    const panel = panels.find(panel2 => panel2.id === key);\n    return JSON.stringify(panel);\n  });\n  return serialized.join(\",\");\n}\nfunction getPanelFlexBoxStyle(_ref2) {\n  let {\n    defaultSize,\n    dragState,\n    sizes,\n    panels,\n    panelIndex,\n    precision = 3\n  } = _ref2;\n  const size = sizes[panelIndex];\n  let flexGrow;\n  if (size == null) {\n    flexGrow = defaultSize != void 0 ? defaultSize.toPrecision(precision) : \"1\";\n  } else if (panels.length === 1) {\n    flexGrow = \"1\";\n  } else {\n    flexGrow = size.toPrecision(precision);\n  }\n  return {\n    flexBasis: 0,\n    flexGrow,\n    flexShrink: 1,\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: \"hidden\",\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: dragState !== null ? \"none\" : void 0\n  };\n}\nfunction getUnsafeDefaultSize(_ref3) {\n  let {\n    panels,\n    size: sizes\n  } = _ref3;\n  const finalSizes = Array(panels.length);\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n  for (let index = 0; index < panels.length; index++) {\n    const panel = panels[index];\n    ensure(panel, () => \"Panel data not found for index \".concat(index));\n    const defaultSize = sizes[index];\n    if (defaultSize != null) {\n      numPanelsWithSizes++;\n      finalSizes[index] = defaultSize;\n      remainingSize -= defaultSize;\n    }\n  }\n  for (let index = 0; index < panels.length; index++) {\n    const panel = panels[index];\n    ensure(panel, () => \"Panel data not found for index \".concat(index));\n    const defaultSize = sizes[index];\n    if (defaultSize != null) {\n      continue;\n    }\n    const numRemainingPanels = panels.length - numPanelsWithSizes;\n    const size = remainingSize / numRemainingPanels;\n    numPanelsWithSizes++;\n    finalSizes[index] = size;\n    remainingSize -= size;\n  }\n  return finalSizes;\n}\n\n// src/splitter.connect.ts\nfunction connect(service, normalize) {\n  const {\n    state,\n    send,\n    prop,\n    computed,\n    context,\n    scope\n  } = service;\n  const horizontal = computed(\"horizontal\");\n  const dragging = state.matches(\"dragging\");\n  const getPanelStyle = id => {\n    const panels = prop(\"panels\");\n    const panelIndex = panels.findIndex(panel => panel.id === id);\n    const defaultSize = context.initial(\"size\")[panelIndex];\n    const dragState = context.get(\"dragState\");\n    return getPanelFlexBoxStyle({\n      defaultSize,\n      dragState,\n      sizes: context.get(\"size\"),\n      panels,\n      panelIndex\n    });\n  };\n  return {\n    dragging,\n    getItems() {\n      return prop(\"panels\").flatMap((panel, index, arr) => {\n        const nextPanel = arr[index + 1];\n        if (panel && nextPanel) {\n          return [{\n            type: \"panel\",\n            id: panel.id\n          }, {\n            type: \"handle\",\n            id: \"\".concat(panel.id, \":\").concat(nextPanel.id)\n          }];\n        }\n        return [{\n          type: \"panel\",\n          id: panel.id\n        }];\n      });\n    },\n    getSizes() {\n      return context.get(\"size\");\n    },\n    setSizes(size) {\n      send({\n        type: \"SIZE.SET\",\n        size\n      });\n    },\n    resetSizes() {\n      send({\n        type: \"SIZE.SET\",\n        size: context.initial(\"size\")\n      });\n    },\n    collapsePanel(id) {\n      send({\n        type: \"PANEL.COLLAPSE\",\n        id\n      });\n    },\n    expandPanel(id, minSize) {\n      send({\n        type: \"PANEL.EXPAND\",\n        id,\n        minSize\n      });\n    },\n    resizePanel(id, unsafePanelSize) {\n      send({\n        type: \"PANEL.RESIZE\",\n        id,\n        size: unsafePanelSize\n      });\n    },\n    getPanelSize(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const {\n        panelSize\n      } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => \"Panel size not found for panel \\\"\".concat(panelData.id, \"\\\"\"));\n      return panelSize;\n    },\n    isPanelCollapsed(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const {\n        collapsedSize = 0,\n        collapsible,\n        panelSize\n      } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => \"Panel size not found for panel \\\"\".concat(panelData.id, \"\\\"\"));\n      return collapsible === true && fuzzyNumbersEqual(panelSize, collapsedSize);\n    },\n    isPanelExpanded(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const {\n        collapsedSize = 0,\n        collapsible,\n        panelSize\n      } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => \"Panel size not found for panel \\\"\".concat(panelData.id, \"\\\"\"));\n      return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;\n    },\n    getLayout() {\n      return getPanelLayout(prop(\"panels\"));\n    },\n    getRootProps() {\n      return normalize.element(_objectSpread(_objectSpread({}, parts.root.attrs), {}, {\n        \"data-orientation\": prop(\"orientation\"),\n        id: getRootId(scope),\n        dir: prop(\"dir\"),\n        style: {\n          display: \"flex\",\n          flexDirection: horizontal ? \"row\" : \"column\",\n          height: \"100%\",\n          width: \"100%\",\n          overflow: \"hidden\"\n        }\n      }));\n    },\n    getPanelProps(props2) {\n      const {\n        id\n      } = props2;\n      return normalize.element(_objectSpread(_objectSpread({}, parts.panel.attrs), {}, {\n        \"data-orientation\": prop(\"orientation\"),\n        dir: prop(\"dir\"),\n        \"data-id\": id,\n        \"data-index\": findPanelIndex(prop(\"panels\"), id),\n        id: getPanelId(scope, id),\n        \"data-ownedby\": getRootId(scope),\n        style: getPanelStyle(id)\n      }));\n    },\n    getResizeTriggerProps(props2) {\n      var _context$get, _context$get2;\n      const {\n        id,\n        disabled\n      } = props2;\n      const aria = getAriaValue(context.get(\"size\"), prop(\"panels\"), id);\n      const dragging2 = ((_context$get = context.get(\"dragState\")) === null || _context$get === void 0 ? void 0 : _context$get.resizeTriggerId) === id;\n      const focused = dragging2 || ((_context$get2 = context.get(\"keyboardState\")) === null || _context$get2 === void 0 ? void 0 : _context$get2.resizeTriggerId) === id;\n      return normalize.element(_objectSpread(_objectSpread({}, parts.resizeTrigger.attrs), {}, {\n        dir: prop(\"dir\"),\n        id: getResizeTriggerId(scope, id),\n        role: \"separator\",\n        \"data-id\": id,\n        \"data-ownedby\": getRootId(scope),\n        tabIndex: disabled ? void 0 : 0,\n        \"aria-valuenow\": aria.valueNow,\n        \"aria-valuemin\": aria.valueMin,\n        \"aria-valuemax\": aria.valueMax,\n        \"data-orientation\": prop(\"orientation\"),\n        \"aria-orientation\": prop(\"orientation\"),\n        \"aria-controls\": \"\".concat(getPanelId(scope, aria.beforeId), \" \").concat(getPanelId(scope, aria.afterId)),\n        \"data-focus\": dataAttr(focused),\n        \"data-disabled\": dataAttr(disabled),\n        style: {\n          touchAction: \"none\",\n          userSelect: \"none\",\n          WebkitUserSelect: \"none\",\n          flex: \"0 0 auto\",\n          pointerEvents: dragging2 && !focused ? \"none\" : void 0,\n          cursor: horizontal ? \"col-resize\" : \"row-resize\",\n          [horizontal ? \"minHeight\" : \"minWidth\"]: \"0\"\n        },\n        onPointerDown(event) {\n          if (!isLeftClick(event)) return;\n          if (disabled) {\n            event.preventDefault();\n            return;\n          }\n          const point = getEventPoint(event);\n          send({\n            type: \"POINTER_DOWN\",\n            id,\n            point\n          });\n          event.currentTarget.setPointerCapture(event.pointerId);\n          event.preventDefault();\n          event.stopPropagation();\n        },\n        onPointerUp(event) {\n          if (disabled) return;\n          if (event.currentTarget.hasPointerCapture(event.pointerId)) {\n            event.currentTarget.releasePointerCapture(event.pointerId);\n          }\n        },\n        onPointerOver() {\n          if (disabled) return;\n          send({\n            type: \"POINTER_OVER\",\n            id\n          });\n        },\n        onPointerLeave() {\n          if (disabled) return;\n          send({\n            type: \"POINTER_LEAVE\",\n            id\n          });\n        },\n        onBlur() {\n          if (disabled) return;\n          send({\n            type: \"BLUR\"\n          });\n        },\n        onFocus() {\n          if (disabled) return;\n          send({\n            type: \"FOCUS\",\n            id\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          const keyboardResizeBy = prop(\"keyboardResizeBy\");\n          let delta = 0;\n          if (event.shiftKey) {\n            delta = 10;\n          } else if (keyboardResizeBy != null) {\n            delta = keyboardResizeBy;\n          } else {\n            delta = 1;\n          }\n          const keyMap = {\n            Enter() {\n              send({\n                type: \"ENTER\",\n                id\n              });\n            },\n            ArrowUp() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: horizontal ? 0 : -delta\n              });\n            },\n            ArrowDown() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: horizontal ? 0 : delta\n              });\n            },\n            ArrowLeft() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: horizontal ? -delta : 0\n              });\n            },\n            ArrowRight() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: horizontal ? delta : 0\n              });\n            },\n            Home() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: -100\n              });\n            },\n            End() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: 100\n              });\n            },\n            F6() {\n              send({\n                type: \"FOCUS.CYCLE\",\n                id,\n                shiftKey: event.shiftKey\n              });\n            }\n          };\n          const key = getEventKey(event, {\n            dir: prop(\"dir\"),\n            orientation: prop(\"orientation\")\n          });\n          const exec = keyMap[key];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n          }\n        }\n      }));\n    }\n  };\n}\nfunction resizePanel(_ref4) {\n  let {\n    panels,\n    index,\n    size\n  } = _ref4;\n  const panel = panels[index];\n  ensure(panel, () => \"Panel data not found for index \".concat(index));\n  let {\n    collapsedSize = 0,\n    collapsible,\n    maxSize = 100,\n    minSize = 0\n  } = panel;\n  if (fuzzyCompareNumbers(size, minSize) < 0) {\n    if (collapsible) {\n      const halfwayPoint = (collapsedSize + minSize) / 2;\n      if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n        size = collapsedSize;\n      } else {\n        size = minSize;\n      }\n    } else {\n      size = minSize;\n    }\n  }\n  size = Math.min(maxSize, size);\n  size = parseFloat(size.toFixed(PRECISION));\n  return size;\n}\n\n// src/utils/resize-by-delta.ts\nfunction resizeByDelta(props2) {\n  let {\n    delta,\n    initialSize,\n    panels,\n    pivotIndices,\n    prevSize,\n    trigger\n  } = props2;\n  if (fuzzyNumbersEqual(delta, 0)) {\n    return initialSize;\n  }\n  const nextSize = [...initialSize];\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n  ensure(firstPivotIndex, () => \"Invalid first pivot index\");\n  ensure(secondPivotIndex, () => \"Invalid second pivot index\");\n  let deltaApplied = 0;\n  {\n    if (trigger === \"keyboard\") {\n      {\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const panel = panels[index];\n        ensure(panel, () => \"Panel data not found for index \".concat(index));\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panel;\n        if (collapsible) {\n          const prevSize2 = initialSize[index];\n          ensure(prevSize2, () => \"Previous size not found for panel index \".concat(index));\n          if (fuzzyNumbersEqual(prevSize2, collapsedSize)) {\n            const localDelta = minSize - prevSize2;\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n            }\n          }\n        }\n      }\n      {\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        const panel = panels[index];\n        ensure(panel, () => \"No panel data found for index \".concat(index));\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panel;\n        if (collapsible) {\n          const prevSize2 = initialSize[index];\n          ensure(prevSize2, () => \"Previous size not found for panel index \".concat(index));\n          if (fuzzyNumbersEqual(prevSize2, minSize)) {\n            const localDelta = prevSize2 - collapsedSize;\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n            }\n          }\n        }\n      }\n    }\n  }\n  {\n    const increment = delta < 0 ? 1 : -1;\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    let maxAvailableDelta = 0;\n    while (true) {\n      const prevSize2 = initialSize[index];\n      ensure(prevSize2, () => \"Previous size not found for panel index \".concat(index));\n      const maxSafeSize = resizePanel({\n        panels,\n        index,\n        size: 100\n      });\n      const delta2 = maxSafeSize - prevSize2;\n      maxAvailableDelta += delta2;\n      index += increment;\n      if (index < 0 || index >= panels.length) {\n        break;\n      }\n    }\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n  }\n  {\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n    let index = pivotIndex;\n    while (index >= 0 && index < panels.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n      const prevSize2 = initialSize[index];\n      ensure(prevSize2, () => \"Previous size not found for panel index \".concat(index));\n      const unsafeSize = prevSize2 - deltaRemaining;\n      const safeSize = resizePanel({\n        panels,\n        index,\n        size: unsafeSize\n      });\n      if (!fuzzyNumbersEqual(prevSize2, safeSize)) {\n        deltaApplied += prevSize2 - safeSize;\n        nextSize[index] = safeSize;\n        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), void 0, {\n          numeric: true\n        }) >= 0) {\n          break;\n        }\n      }\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n  if (fuzzySizeEqual(prevSize, nextSize)) {\n    return prevSize;\n  }\n  {\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    const prevSize2 = initialSize[pivotIndex];\n    ensure(prevSize2, () => \"Previous size not found for panel index \".concat(pivotIndex));\n    const unsafeSize = prevSize2 + deltaApplied;\n    const safeSize = resizePanel({\n      panels,\n      index: pivotIndex,\n      size: unsafeSize\n    });\n    nextSize[pivotIndex] = safeSize;\n    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n      const pivotIndex2 = delta < 0 ? secondPivotIndex : firstPivotIndex;\n      let index = pivotIndex2;\n      while (index >= 0 && index < panels.length) {\n        const prevSize3 = nextSize[index];\n        ensure(prevSize3, () => \"Previous size not found for panel index \".concat(index));\n        const unsafeSize2 = prevSize3 + deltaRemaining;\n        const safeSize2 = resizePanel({\n          panels,\n          index,\n          size: unsafeSize2\n        });\n        if (!fuzzyNumbersEqual(prevSize3, safeSize2)) {\n          deltaRemaining -= safeSize2 - prevSize3;\n          nextSize[index] = safeSize2;\n        }\n        if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n          break;\n        }\n        if (delta > 0) {\n          index--;\n        } else {\n          index++;\n        }\n      }\n    }\n  }\n  const totalSize = nextSize.reduce((total, size) => size + total, 0);\n  if (!fuzzyNumbersEqual(totalSize, 100)) {\n    return prevSize;\n  }\n  return nextSize;\n}\nfunction validateSizes(_ref5) {\n  let {\n    size: prevSize,\n    panels\n  } = _ref5;\n  const nextSize = [...prevSize];\n  const nextSizeTotalSize = nextSize.reduce((accumulated, current) => accumulated + current, 0);\n  if (nextSize.length !== panels.length) {\n    throw Error(\"Invalid \".concat(panels.length, \" panel size: \").concat(nextSize.map(size => \"\".concat(size, \"%\")).join(\", \")));\n  } else if (!fuzzyNumbersEqual(nextSizeTotalSize, 100) && nextSize.length > 0) {\n    for (let index = 0; index < panels.length; index++) {\n      const unsafeSize = nextSize[index];\n      ensure(unsafeSize, () => \"No size data found for index \".concat(index));\n      const safeSize = 100 / nextSizeTotalSize * unsafeSize;\n      nextSize[index] = safeSize;\n    }\n  }\n  let remainingSize = 0;\n  for (let index = 0; index < panels.length; index++) {\n    const unsafeSize = nextSize[index];\n    ensure(unsafeSize, () => \"No size data found for index \".concat(index));\n    const safeSize = resizePanel({\n      panels,\n      index,\n      size: unsafeSize\n    });\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n      nextSize[index] = safeSize;\n    }\n  }\n  if (!fuzzyNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panels.length; index++) {\n      const prevSize2 = nextSize[index];\n      ensure(prevSize2, () => \"No size data found for index \".concat(index));\n      const unsafeSize = prevSize2 + remainingSize;\n      const safeSize = resizePanel({\n        panels,\n        index,\n        size: unsafeSize\n      });\n      if (prevSize2 !== safeSize) {\n        remainingSize -= safeSize - prevSize2;\n        nextSize[index] = safeSize;\n        if (fuzzyNumbersEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n  return nextSize;\n}\n\n// src/splitter.machine.ts\nvar machine = createMachine({\n  props(_ref6) {\n    let {\n      props: props2\n    } = _ref6;\n    ensureProps(props2, [\"panels\"]);\n    return _objectSpread(_objectSpread({\n      orientation: \"horizontal\",\n      defaultSize: [],\n      dir: \"ltr\"\n    }, props2), {}, {\n      panels: sortPanels(props2.panels)\n    });\n  },\n  initialState() {\n    return \"idle\";\n  },\n  context(_ref7) {\n    let {\n      prop,\n      bindable,\n      getContext,\n      getRefs\n    } = _ref7;\n    return {\n      size: bindable(() => ({\n        value: prop(\"size\"),\n        defaultValue: prop(\"defaultSize\"),\n        isEqual(a, b) {\n          return b != null && fuzzySizeEqual(a, b);\n        },\n        onChange(value) {\n          var _ctx$get$resizeTrigge, _ctx$get, _prop;\n          const ctx = getContext();\n          const refs = getRefs();\n          const sizesBeforeCollapse = refs.get(\"panelSizeBeforeCollapse\");\n          const expandToSizes = Object.fromEntries(sizesBeforeCollapse.entries());\n          const resizeTriggerId = (_ctx$get$resizeTrigge = (_ctx$get = ctx.get(\"dragState\")) === null || _ctx$get === void 0 ? void 0 : _ctx$get.resizeTriggerId) !== null && _ctx$get$resizeTrigge !== void 0 ? _ctx$get$resizeTrigge : null;\n          const layout = getPanelLayout(prop(\"panels\"));\n          (_prop = prop(\"onResize\")) === null || _prop === void 0 || _prop({\n            size: value,\n            layout,\n            resizeTriggerId,\n            expandToSizes\n          });\n        }\n      })),\n      dragState: bindable(() => ({\n        defaultValue: null\n      })),\n      keyboardState: bindable(() => ({\n        defaultValue: null\n      }))\n    };\n  },\n  watch(_ref8) {\n    let {\n      track,\n      action,\n      prop\n    } = _ref8;\n    track([() => serializePanels(prop(\"panels\"))], () => {\n      action([\"syncSize\"]);\n    });\n  },\n  refs() {\n    return {\n      panelSizeBeforeCollapse: /* @__PURE__ */new Map(),\n      prevDelta: 0,\n      panelIdToLastNotifiedSizeMap: /* @__PURE__ */new Map()\n    };\n  },\n  computed: {\n    horizontal(_ref9) {\n      let {\n        prop\n      } = _ref9;\n      return prop(\"orientation\") === \"horizontal\";\n    }\n  },\n  on: {\n    \"SIZE.SET\": {\n      actions: [\"setSize\"]\n    },\n    \"PANEL.COLLAPSE\": {\n      actions: [\"collapsePanel\"]\n    },\n    \"PANEL.EXPAND\": {\n      actions: [\"expandPanel\"]\n    },\n    \"PANEL.RESIZE\": {\n      actions: [\"resizePanel\"]\n    }\n  },\n  entry: [\"syncSize\"],\n  states: {\n    idle: {\n      entry: [\"clearDraggingState\", \"clearKeyboardState\"],\n      on: {\n        POINTER_OVER: {\n          target: \"hover:temp\",\n          actions: [\"setKeyboardState\"]\n        },\n        FOCUS: {\n          target: \"focused\",\n          actions: [\"setKeyboardState\"]\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        }\n      }\n    },\n    \"hover:temp\": {\n      effects: [\"waitForHoverDelay\"],\n      on: {\n        HOVER_DELAY: {\n          target: \"hover\"\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        POINTER_LEAVE: {\n          target: \"idle\"\n        }\n      }\n    },\n    hover: {\n      tags: [\"focus\"],\n      on: {\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        POINTER_LEAVE: {\n          target: \"idle\"\n        }\n      }\n    },\n    focused: {\n      tags: [\"focus\"],\n      on: {\n        BLUR: {\n          target: \"idle\"\n        },\n        ENTER: {\n          actions: [\"collapseOrExpandPanel\"]\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        KEYBOARD_MOVE: {\n          actions: [\"invokeOnResizeStart\", \"setKeyboardValue\", \"invokeOnResizeEnd\"]\n        },\n        \"FOCUS.CYCLE\": {\n          actions: [\"focusNextResizeTrigger\"]\n        }\n      }\n    },\n    dragging: {\n      tags: [\"focus\"],\n      effects: [\"trackPointerMove\"],\n      entry: [\"invokeOnResizeStart\"],\n      on: {\n        POINTER_MOVE: {\n          actions: [\"setPointerValue\", \"setGlobalCursor\"]\n        },\n        POINTER_UP: {\n          target: \"idle\",\n          actions: [\"invokeOnResizeEnd\", \"clearGlobalCursor\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    effects: {\n      waitForHoverDelay: _ref0 => {\n        let {\n          send\n        } = _ref0;\n        return setRafTimeout(() => {\n          send({\n            type: \"HOVER_DELAY\"\n          });\n        }, 250);\n      },\n      trackPointerMove: _ref1 => {\n        let {\n          scope,\n          send\n        } = _ref1;\n        const doc = scope.getDoc();\n        return trackPointerMove(doc, {\n          onPointerMove(info) {\n            send({\n              type: \"POINTER_MOVE\",\n              point: info.point\n            });\n          },\n          onPointerUp() {\n            send({\n              type: \"POINTER_UP\"\n            });\n          }\n        });\n      }\n    },\n    actions: {\n      setSize(params) {\n        const {\n          context,\n          event,\n          prop\n        } = params;\n        const unsafeSize = event.size;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const safeSize = validateSizes({\n          size: unsafeSize,\n          panels\n        });\n        if (!isEqual(prevSize, safeSize)) {\n          setSize(params, safeSize);\n        }\n      },\n      syncSize(_ref10) {\n        let {\n          context,\n          prop\n        } = _ref10;\n        const panels = prop(\"panels\");\n        let prevSize = context.get(\"size\");\n        let unsafeSize = null;\n        if (prevSize.length === 0) {\n          unsafeSize = getUnsafeDefaultSize({\n            panels,\n            size: context.initial(\"size\")\n          });\n        }\n        const nextSize = validateSizes({\n          size: unsafeSize !== null && unsafeSize !== void 0 ? unsafeSize : prevSize,\n          panels\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          context.set(\"size\", nextSize);\n        }\n      },\n      setDraggingState(_ref11) {\n        let {\n          context,\n          event,\n          prop,\n          scope\n        } = _ref11;\n        const orientation = prop(\"orientation\");\n        const size = context.get(\"size\");\n        const resizeTriggerId = event.id;\n        const panelGroupEl = getRootEl(scope);\n        if (!panelGroupEl) return;\n        const handleElement = getResizeTriggerEl(scope, resizeTriggerId);\n        ensure(handleElement, () => \"Drag handle element not found for id \\\"\".concat(resizeTriggerId, \"\\\"\"));\n        const initialCursorPosition = orientation === \"horizontal\" ? event.point.x : event.point.y;\n        context.set(\"dragState\", {\n          resizeTriggerId: event.id,\n          resizeTriggerRect: handleElement.getBoundingClientRect(),\n          initialCursorPosition,\n          initialSize: size\n        });\n      },\n      clearDraggingState(_ref12) {\n        let {\n          context\n        } = _ref12;\n        context.set(\"dragState\", null);\n      },\n      setKeyboardState(_ref13) {\n        let {\n          context,\n          event\n        } = _ref13;\n        context.set(\"keyboardState\", {\n          resizeTriggerId: event.id\n        });\n      },\n      clearKeyboardState(_ref14) {\n        let {\n          context\n        } = _ref14;\n        context.set(\"keyboardState\", null);\n      },\n      collapsePanel(params) {\n        const {\n          context,\n          prop,\n          event,\n          refs\n        } = params;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const panel = panels.find(panel2 => panel2.id === event.id);\n        ensure(panel, () => \"Panel data not found for id \\\"\".concat(event.id, \"\\\"\"));\n        if (panel.collapsible) {\n          const {\n            collapsedSize = 0,\n            panelSize,\n            pivotIndices\n          } = panelDataHelper(panels, panel, prevSize);\n          ensure(panelSize, () => \"Panel size not found for panel \\\"\".concat(panel.id, \"\\\"\"));\n          if (!fuzzyNumbersEqual(panelSize, collapsedSize)) {\n            refs.get(\"panelSizeBeforeCollapse\").set(panel.id, panelSize);\n            const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n            const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;\n            const nextSize = resizeByDelta({\n              delta,\n              initialSize: prevSize,\n              panels,\n              pivotIndices,\n              prevSize,\n              trigger: \"imperative-api\"\n            });\n            if (!isEqual(prevSize, nextSize)) {\n              setSize(params, nextSize);\n            }\n          }\n        }\n      },\n      expandPanel(params) {\n        const {\n          context,\n          prop,\n          event,\n          refs\n        } = params;\n        const panels = prop(\"panels\");\n        const prevSize = context.get(\"size\");\n        const panel = panels.find(panel2 => panel2.id === event.id);\n        ensure(panel, () => \"Panel data not found for id \\\"\".concat(event.id, \"\\\"\"));\n        if (panel.collapsible) {\n          var _event$minSize;\n          const {\n            collapsedSize = 0,\n            panelSize = 0,\n            minSize: minSizeFromProps = 0,\n            pivotIndices\n          } = panelDataHelper(panels, panel, prevSize);\n          const minSize = (_event$minSize = event.minSize) !== null && _event$minSize !== void 0 ? _event$minSize : minSizeFromProps;\n          if (fuzzyNumbersEqual(panelSize, collapsedSize)) {\n            const prevPanelSize = refs.get(\"panelSizeBeforeCollapse\").get(panel.id);\n            const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;\n            const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n            const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;\n            const nextSize = resizeByDelta({\n              delta,\n              initialSize: prevSize,\n              panels,\n              pivotIndices,\n              prevSize,\n              trigger: \"imperative-api\"\n            });\n            if (!isEqual(prevSize, nextSize)) {\n              setSize(params, nextSize);\n            }\n          }\n        }\n      },\n      resizePanel(params) {\n        const {\n          context,\n          prop,\n          event\n        } = params;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const panel = getPanelById(panels, event.id);\n        const unsafePanelSize = event.size;\n        const {\n          panelSize,\n          pivotIndices\n        } = panelDataHelper(panels, panel, prevSize);\n        ensure(panelSize, () => \"Panel size not found for panel \\\"\".concat(panel.id, \"\\\"\"));\n        const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n        const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;\n        const nextSize = resizeByDelta({\n          delta,\n          initialSize: prevSize,\n          panels,\n          pivotIndices,\n          prevSize,\n          trigger: \"imperative-api\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      setPointerValue(params) {\n        const {\n          context,\n          event,\n          prop,\n          scope\n        } = params;\n        const dragState = context.get(\"dragState\");\n        if (!dragState) return;\n        const {\n          resizeTriggerId,\n          initialSize,\n          initialCursorPosition\n        } = dragState;\n        const panels = prop(\"panels\");\n        const panelGroupElement = getRootEl(scope);\n        ensure(panelGroupElement, () => \"Panel group element not found\");\n        const pivotIndices = resizeTriggerId.split(\":\").map(id => panels.findIndex(panel => panel.id === id));\n        const horizontal = prop(\"orientation\") === \"horizontal\";\n        const cursorPosition = horizontal ? event.point.x : event.point.y;\n        const groupRect = panelGroupElement.getBoundingClientRect();\n        const groupSizeInPixels = horizontal ? groupRect.width : groupRect.height;\n        const offsetPixels = cursorPosition - initialCursorPosition;\n        const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\n        const prevSize = context.get(\"size\");\n        const nextSize = resizeByDelta({\n          delta: offsetPercentage,\n          initialSize: initialSize !== null && initialSize !== void 0 ? initialSize : prevSize,\n          panels,\n          pivotIndices,\n          prevSize,\n          trigger: \"mouse-or-touch\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      setKeyboardValue(params) {\n        const {\n          context,\n          event,\n          prop\n        } = params;\n        const panelDataArray = prop(\"panels\");\n        const resizeTriggerId = event.id;\n        const delta = event.delta;\n        const pivotIndices = resizeTriggerId.split(\":\").map(id => panelDataArray.findIndex(panelData => panelData.id === id));\n        const prevSize = context.get(\"size\");\n        const nextSize = resizeByDelta({\n          delta,\n          initialSize: prevSize,\n          panels: panelDataArray,\n          pivotIndices,\n          prevSize,\n          trigger: \"keyboard\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      invokeOnResizeEnd(_ref15) {\n        let {\n          context,\n          prop\n        } = _ref15;\n        queueMicrotask(() => {\n          var _prop2, _dragState$resizeTrig;\n          const dragState = context.get(\"dragState\");\n          (_prop2 = prop(\"onResizeEnd\")) === null || _prop2 === void 0 || _prop2({\n            size: context.get(\"size\"),\n            resizeTriggerId: (_dragState$resizeTrig = dragState === null || dragState === void 0 ? void 0 : dragState.resizeTriggerId) !== null && _dragState$resizeTrig !== void 0 ? _dragState$resizeTrig : null\n          });\n        });\n      },\n      invokeOnResizeStart(_ref16) {\n        let {\n          prop\n        } = _ref16;\n        queueMicrotask(() => {\n          var _prop3;\n          (_prop3 = prop(\"onResizeStart\")) === null || _prop3 === void 0 || _prop3();\n        });\n      },\n      collapseOrExpandPanel(params) {\n        var _context$get3, _resizeTriggerId$spli;\n        const {\n          context,\n          prop\n        } = params;\n        const panelDataArray = prop(\"panels\");\n        const sizes = context.get(\"size\");\n        const resizeTriggerId = (_context$get3 = context.get(\"keyboardState\")) === null || _context$get3 === void 0 ? void 0 : _context$get3.resizeTriggerId;\n        const [idBefore, idAfter] = (_resizeTriggerId$spli = resizeTriggerId === null || resizeTriggerId === void 0 ? void 0 : resizeTriggerId.split(\":\")) !== null && _resizeTriggerId$spli !== void 0 ? _resizeTriggerId$spli : [];\n        const index = panelDataArray.findIndex(panelData2 => panelData2.id === idBefore);\n        if (index === -1) return;\n        const panelData = panelDataArray[index];\n        ensure(panelData, () => \"No panel data found for index \".concat(index));\n        const size = sizes[index];\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelData;\n        if (size != null && collapsible) {\n          const pivotIndices = [idBefore, idAfter].map(id => panelDataArray.findIndex(panelData2 => panelData2.id === id));\n          const nextSize = resizeByDelta({\n            delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\n            initialSize: context.initial(\"size\"),\n            panels: panelDataArray,\n            pivotIndices,\n            prevSize: sizes,\n            trigger: \"keyboard\"\n          });\n          if (!isEqual(sizes, nextSize)) {\n            setSize(params, nextSize);\n          }\n        }\n      },\n      setGlobalCursor(_ref17) {\n        let {\n          context,\n          scope,\n          prop\n        } = _ref17;\n        const dragState = context.get(\"dragState\");\n        if (!dragState) return;\n        const panels = prop(\"panels\");\n        const horizontal = prop(\"orientation\") === \"horizontal\";\n        const [idBefore] = dragState.resizeTriggerId.split(\":\");\n        const indexBefore = panels.findIndex(panel2 => panel2.id === idBefore);\n        const panel = panels[indexBefore];\n        const size = context.get(\"size\");\n        const aria = getAriaValue(size, panels, dragState.resizeTriggerId);\n        const isAtMin = fuzzyNumbersEqual(aria.valueNow, aria.valueMin) || fuzzyNumbersEqual(aria.valueNow, panel.collapsedSize);\n        const isAtMax = fuzzyNumbersEqual(aria.valueNow, aria.valueMax);\n        const cursorState = {\n          isAtMin,\n          isAtMax\n        };\n        setupGlobalCursor(scope, cursorState, horizontal, prop(\"nonce\"));\n      },\n      clearGlobalCursor(_ref18) {\n        let {\n          scope\n        } = _ref18;\n        removeGlobalCursor(scope);\n      },\n      focusNextResizeTrigger(_ref19) {\n        let {\n          event,\n          scope\n        } = _ref19;\n        const resizeTriggers = getResizeTriggerEls(scope);\n        const index = resizeTriggers.findIndex(el => el.dataset.id === event.id);\n        const handleEl = event.shiftKey ? prev(resizeTriggers, index) : next(resizeTriggers, index);\n        handleEl === null || handleEl === void 0 || handleEl.focus();\n      }\n    }\n  }\n});\nfunction setSize(params, sizes) {\n  const {\n    refs,\n    prop,\n    context\n  } = params;\n  const panelsArray = prop(\"panels\");\n  const onCollapse = prop(\"onCollapse\");\n  const onExpand = prop(\"onExpand\");\n  const panelIdToLastNotifiedSizeMap = refs.get(\"panelIdToLastNotifiedSizeMap\");\n  context.set(\"size\", sizes);\n  sizes.forEach((size, index) => {\n    const panelData = panelsArray[index];\n    ensure(panelData, () => \"Panel data not found for index \".concat(index));\n    const {\n      collapsedSize = 0,\n      collapsible,\n      id: panelId\n    } = panelData;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap.get(panelId);\n    if (lastNotifiedSize == null || size !== lastNotifiedSize) {\n      panelIdToLastNotifiedSizeMap.set(panelId, size);\n      if (collapsible && (onCollapse || onExpand)) {\n        if ((lastNotifiedSize == null || fuzzyNumbersEqual(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual(size, collapsedSize)) {\n          onExpand === null || onExpand === void 0 || onExpand({\n            panelId,\n            size\n          });\n        }\n        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual(size, collapsedSize)) {\n          onCollapse === null || onCollapse === void 0 || onCollapse({\n            panelId,\n            size\n          });\n        }\n      }\n    }\n  });\n}\nvar props = createProps()([\"dir\", \"getRootNode\", \"id\", \"ids\", \"onResize\", \"onResizeStart\", \"onResizeEnd\", \"onCollapse\", \"onExpand\", \"orientation\", \"size\", \"defaultSize\", \"panels\", \"keyboardResizeBy\", \"nonce\"]);\nvar splitProps = createSplitProps(props);\nvar panelProps = createProps()([\"id\"]);\nvar splitPanelProps = createSplitProps(panelProps);\nvar resizeTriggerProps = createProps()([\"disabled\", \"id\"]);\nvar splitResizeTriggerProps = createSplitProps(resizeTriggerProps);\nexport { anatomy, connect, getPanelLayout as layout, machine, panelProps, props, resizeTriggerProps, splitPanelProps, splitProps, splitResizeTriggerProps };","map":{"version":3,"names":["createAnatomy","trackPointerMove","queryAll","dataAttr","getEventKey","isLeftClick","getEventPoint","prev","next","ensure","isEqual","setRafTimeout","ensureProps","createSplitProps","createMachine","createProps","anatomy","parts","build","getRootId","ctx","_ctx$ids$root","_ctx$ids","ids","root","concat","id","getResizeTriggerId","_ctx$ids$resizeTrigge","_ctx$ids2","_ctx$ids2$resizeTrigg","resizeTrigger","call","getPanelId","_ctx$ids$panel","_ctx$ids3","_ctx$ids3$panel","panel","getGlobalCursorId","getRootEl","getById","getResizeTriggerEl","getCursor","state","x","cursor","isAtMin","isAtMax","getResizeTriggerEls","CSS","escape","setupGlobalCursor","nonce","styleEl","textContent","style","getDoc","createElement","head","appendChild","removeGlobalCursor","remove","calculateAriaValues","_ref","size","panels","pivotIndices","currentMinSize","currentMaxSize","totalMinSize","totalMaxSize","firstIndex","forEach","index","maxSize","minSize","valueMax","Math","min","valueMin","max","valueNow","getAriaValue","handleId","beforeId","afterId","split","beforeIndex","findIndex","afterIndex","round","PRECISION","fuzzyCompareNumbers","actual","expected","fractionDigits","arguments","length","undefined","toFixed","fuzzyNumbersEqual","fuzzySizeEqual","actualSize","expectedSize","getPanelById","find","panel2","findPanelDataIndex","prevPanel","findPanelIndex","panelDataHelper","sizes","panelSize","_objectSpread","sortPanels","sort","panelA","panelB","orderA","order","orderB","getPanelLayout","map","join","serializePanels","keys","sortedKeys","serialized","key","JSON","stringify","getPanelFlexBoxStyle","_ref2","defaultSize","dragState","panelIndex","precision","flexGrow","toPrecision","flexBasis","flexShrink","overflow","pointerEvents","getUnsafeDefaultSize","_ref3","finalSizes","Array","numPanelsWithSizes","remainingSize","numRemainingPanels","connect","service","normalize","send","prop","computed","context","scope","horizontal","dragging","matches","getPanelStyle","initial","get","getItems","flatMap","arr","nextPanel","type","getSizes","setSizes","resetSizes","collapsePanel","expandPanel","resizePanel","unsafePanelSize","getPanelSize","panelData","isPanelCollapsed","collapsedSize","collapsible","isPanelExpanded","getLayout","getRootProps","element","attrs","dir","display","flexDirection","height","width","getPanelProps","props2","getResizeTriggerProps","_context$get","_context$get2","disabled","aria","dragging2","resizeTriggerId","focused","role","tabIndex","touchAction","userSelect","WebkitUserSelect","flex","onPointerDown","event","preventDefault","point","currentTarget","setPointerCapture","pointerId","stopPropagation","onPointerUp","hasPointerCapture","releasePointerCapture","onPointerOver","onPointerLeave","onBlur","onFocus","onKeyDown","defaultPrevented","keyboardResizeBy","delta","shiftKey","keyMap","Enter","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Home","End","F6","orientation","exec","_ref4","halfwayPoint","parseFloat","resizeByDelta","initialSize","prevSize","trigger","nextSize","firstPivotIndex","secondPivotIndex","deltaApplied","prevSize2","localDelta","abs","increment","maxAvailableDelta","maxSafeSize","delta2","minAbsDelta","pivotIndex","deltaRemaining","unsafeSize","safeSize","localeCompare","numeric","pivotIndex2","prevSize3","unsafeSize2","safeSize2","totalSize","reduce","total","validateSizes","_ref5","nextSizeTotalSize","accumulated","current","Error","machine","props","_ref6","initialState","_ref7","bindable","getContext","getRefs","value","defaultValue","a","b","onChange","_ctx$get$resizeTrigge","_ctx$get","_prop","refs","sizesBeforeCollapse","expandToSizes","Object","fromEntries","entries","layout","keyboardState","watch","_ref8","track","action","panelSizeBeforeCollapse","Map","prevDelta","panelIdToLastNotifiedSizeMap","_ref9","on","actions","entry","states","idle","POINTER_OVER","target","FOCUS","POINTER_DOWN","effects","HOVER_DELAY","POINTER_LEAVE","hover","tags","BLUR","ENTER","KEYBOARD_MOVE","POINTER_MOVE","POINTER_UP","implementations","waitForHoverDelay","_ref0","_ref1","doc","onPointerMove","info","setSize","params","syncSize","_ref10","set","setDraggingState","_ref11","panelGroupEl","handleElement","initialCursorPosition","y","resizeTriggerRect","getBoundingClientRect","clearDraggingState","_ref12","setKeyboardState","_ref13","clearKeyboardState","_ref14","isLastPanel","_event$minSize","minSizeFromProps","prevPanelSize","baseSize","setPointerValue","panelGroupElement","cursorPosition","groupRect","groupSizeInPixels","offsetPixels","offsetPercentage","setKeyboardValue","panelDataArray","invokeOnResizeEnd","_ref15","queueMicrotask","_prop2","_dragState$resizeTrig","invokeOnResizeStart","_ref16","_prop3","collapseOrExpandPanel","_context$get3","_resizeTriggerId$spli","idBefore","idAfter","panelData2","setGlobalCursor","_ref17","indexBefore","cursorState","clearGlobalCursor","_ref18","focusNextResizeTrigger","_ref19","resizeTriggers","el","dataset","handleEl","focus","panelsArray","onCollapse","onExpand","panelId","lastNotifiedSize","splitProps","panelProps","splitPanelProps","resizeTriggerProps","splitResizeTriggerProps"],"sources":["C:/Users/JAMES/cerebras-1/CerebrasApp/frontend/node_modules/@zag-js/splitter/dist/index.mjs"],"sourcesContent":["import { createAnatomy } from '@zag-js/anatomy';\nimport { trackPointerMove, queryAll, dataAttr, getEventKey, isLeftClick, getEventPoint } from '@zag-js/dom-query';\nimport { prev, next, ensure, isEqual, setRafTimeout, ensureProps, createSplitProps } from '@zag-js/utils';\nimport { createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/splitter.anatomy.ts\nvar anatomy = createAnatomy(\"splitter\").parts(\"root\", \"panel\", \"resizeTrigger\");\nvar parts = anatomy.build();\nvar getRootId = (ctx) => ctx.ids?.root ?? `splitter:${ctx.id}`;\nvar getResizeTriggerId = (ctx, id) => ctx.ids?.resizeTrigger?.(id) ?? `splitter:${ctx.id}:splitter:${id}`;\nvar getPanelId = (ctx, id) => ctx.ids?.panel?.(id) ?? `splitter:${ctx.id}:panel:${id}`;\nvar getGlobalCursorId = (ctx) => `splitter:${ctx.id}:global-cursor`;\nvar getRootEl = (ctx) => ctx.getById(getRootId(ctx));\nvar getResizeTriggerEl = (ctx, id) => ctx.getById(getResizeTriggerId(ctx, id));\nvar getCursor = (state, x) => {\n  let cursor = x ? \"col-resize\" : \"row-resize\";\n  if (state.isAtMin) cursor = x ? \"e-resize\" : \"s-resize\";\n  if (state.isAtMax) cursor = x ? \"w-resize\" : \"n-resize\";\n  return cursor;\n};\nvar getResizeTriggerEls = (ctx) => {\n  return queryAll(getRootEl(ctx), `[role=separator][data-ownedby='${CSS.escape(getRootId(ctx))}']`);\n};\nvar setupGlobalCursor = (ctx, state, x, nonce) => {\n  const styleEl = ctx.getById(getGlobalCursorId(ctx));\n  const textContent = `* { cursor: ${getCursor(state, x)} !important; }`;\n  if (styleEl) {\n    styleEl.textContent = textContent;\n  } else {\n    const style = ctx.getDoc().createElement(\"style\");\n    if (nonce) style.nonce = nonce;\n    style.id = getGlobalCursorId(ctx);\n    style.textContent = textContent;\n    ctx.getDoc().head.appendChild(style);\n  }\n};\nvar removeGlobalCursor = (ctx) => {\n  const styleEl = ctx.getById(getGlobalCursorId(ctx));\n  styleEl?.remove();\n};\nfunction calculateAriaValues({\n  size,\n  panels,\n  pivotIndices\n}) {\n  let currentMinSize = 0;\n  let currentMaxSize = 100;\n  let totalMinSize = 0;\n  let totalMaxSize = 0;\n  const firstIndex = pivotIndices[0];\n  ensure(firstIndex, () => \"No pivot index found\");\n  panels.forEach((panel, index) => {\n    const { maxSize = 100, minSize = 0 } = panel;\n    if (index === firstIndex) {\n      currentMinSize = minSize;\n      currentMaxSize = maxSize;\n    } else {\n      totalMinSize += minSize;\n      totalMaxSize += maxSize;\n    }\n  });\n  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n  const valueNow = size[firstIndex];\n  return {\n    valueMax,\n    valueMin,\n    valueNow\n  };\n}\nfunction getAriaValue(size, panels, handleId) {\n  const [beforeId, afterId] = handleId.split(\":\");\n  const beforeIndex = panels.findIndex((panel) => panel.id === beforeId);\n  const afterIndex = panels.findIndex((panel) => panel.id === afterId);\n  const { valueMax, valueMin, valueNow } = calculateAriaValues({\n    size,\n    panels,\n    pivotIndices: [beforeIndex, afterIndex]\n  });\n  return {\n    beforeId,\n    afterId,\n    valueMax: Math.round(valueMax),\n    valueMin: Math.round(valueMin),\n    valueNow: valueNow != null ? Math.round(valueNow) : void 0\n  };\n}\n\n// src/utils/fuzzy.ts\nvar PRECISION = 10;\nfunction fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {\n  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {\n    return 0;\n  } else {\n    return actual > expected ? 1 : -1;\n  }\n}\nfunction fuzzyNumbersEqual(actual, expected, fractionDigits = PRECISION) {\n  if (actual == null || expected == null) return false;\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\nfunction fuzzySizeEqual(actual, expected, fractionDigits) {\n  if (actual.length !== expected.length) {\n    return false;\n  }\n  for (let index = 0; index < actual.length; index++) {\n    const actualSize = actual[index];\n    const expectedSize = expected[index];\n    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getPanelById(panels, id) {\n  const panel = panels.find((panel2) => panel2.id === id);\n  ensure(panel, () => `Panel data not found for id \"${id}\"`);\n  return panel;\n}\nfunction findPanelDataIndex(panels, panel) {\n  return panels.findIndex((prevPanel) => prevPanel === panel || prevPanel.id === panel.id);\n}\nfunction findPanelIndex(panels, id) {\n  return panels.findIndex((panel) => panel.id === id);\n}\nfunction panelDataHelper(panels, panel, sizes) {\n  const index = findPanelIndex(panels, panel.id);\n  const pivotIndices = index === panels.length - 1 ? [index - 1, index] : [index, index + 1];\n  const panelSize = sizes[index];\n  return { ...panel, panelSize, pivotIndices };\n}\nfunction sortPanels(panels) {\n  return panels.sort((panelA, panelB) => {\n    const orderA = panelA.order;\n    const orderB = panelB.order;\n    if (orderA == null && orderB == null) {\n      return 0;\n    } else if (orderA == null) {\n      return -1;\n    } else if (orderB == null) {\n      return 1;\n    } else {\n      return orderA - orderB;\n    }\n  });\n}\nfunction getPanelLayout(panels) {\n  return panels.map((panel) => panel.id).sort().join(\":\");\n}\nfunction serializePanels(panels) {\n  const keys = panels.map((panel) => panel.id);\n  const sortedKeys = keys.sort();\n  const serialized = sortedKeys.map((key) => {\n    const panel = panels.find((panel2) => panel2.id === key);\n    return JSON.stringify(panel);\n  });\n  return serialized.join(\",\");\n}\nfunction getPanelFlexBoxStyle({\n  defaultSize,\n  dragState,\n  sizes,\n  panels,\n  panelIndex,\n  precision = 3\n}) {\n  const size = sizes[panelIndex];\n  let flexGrow;\n  if (size == null) {\n    flexGrow = defaultSize != void 0 ? defaultSize.toPrecision(precision) : \"1\";\n  } else if (panels.length === 1) {\n    flexGrow = \"1\";\n  } else {\n    flexGrow = size.toPrecision(precision);\n  }\n  return {\n    flexBasis: 0,\n    flexGrow,\n    flexShrink: 1,\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: \"hidden\",\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: dragState !== null ? \"none\" : void 0\n  };\n}\nfunction getUnsafeDefaultSize({ panels, size: sizes }) {\n  const finalSizes = Array(panels.length);\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n  for (let index = 0; index < panels.length; index++) {\n    const panel = panels[index];\n    ensure(panel, () => `Panel data not found for index ${index}`);\n    const defaultSize = sizes[index];\n    if (defaultSize != null) {\n      numPanelsWithSizes++;\n      finalSizes[index] = defaultSize;\n      remainingSize -= defaultSize;\n    }\n  }\n  for (let index = 0; index < panels.length; index++) {\n    const panel = panels[index];\n    ensure(panel, () => `Panel data not found for index ${index}`);\n    const defaultSize = sizes[index];\n    if (defaultSize != null) {\n      continue;\n    }\n    const numRemainingPanels = panels.length - numPanelsWithSizes;\n    const size = remainingSize / numRemainingPanels;\n    numPanelsWithSizes++;\n    finalSizes[index] = size;\n    remainingSize -= size;\n  }\n  return finalSizes;\n}\n\n// src/splitter.connect.ts\nfunction connect(service, normalize) {\n  const { state, send, prop, computed, context, scope } = service;\n  const horizontal = computed(\"horizontal\");\n  const dragging = state.matches(\"dragging\");\n  const getPanelStyle = (id) => {\n    const panels = prop(\"panels\");\n    const panelIndex = panels.findIndex((panel) => panel.id === id);\n    const defaultSize = context.initial(\"size\")[panelIndex];\n    const dragState = context.get(\"dragState\");\n    return getPanelFlexBoxStyle({\n      defaultSize,\n      dragState,\n      sizes: context.get(\"size\"),\n      panels,\n      panelIndex\n    });\n  };\n  return {\n    dragging,\n    getItems() {\n      return prop(\"panels\").flatMap((panel, index, arr) => {\n        const nextPanel = arr[index + 1];\n        if (panel && nextPanel) {\n          return [\n            { type: \"panel\", id: panel.id },\n            { type: \"handle\", id: `${panel.id}:${nextPanel.id}` }\n          ];\n        }\n        return [{ type: \"panel\", id: panel.id }];\n      });\n    },\n    getSizes() {\n      return context.get(\"size\");\n    },\n    setSizes(size) {\n      send({ type: \"SIZE.SET\", size });\n    },\n    resetSizes() {\n      send({ type: \"SIZE.SET\", size: context.initial(\"size\") });\n    },\n    collapsePanel(id) {\n      send({ type: \"PANEL.COLLAPSE\", id });\n    },\n    expandPanel(id, minSize) {\n      send({ type: \"PANEL.EXPAND\", id, minSize });\n    },\n    resizePanel(id, unsafePanelSize) {\n      send({ type: \"PANEL.RESIZE\", id, size: unsafePanelSize });\n    },\n    getPanelSize(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const { panelSize } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => `Panel size not found for panel \"${panelData.id}\"`);\n      return panelSize;\n    },\n    isPanelCollapsed(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const { collapsedSize = 0, collapsible, panelSize } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => `Panel size not found for panel \"${panelData.id}\"`);\n      return collapsible === true && fuzzyNumbersEqual(panelSize, collapsedSize);\n    },\n    isPanelExpanded(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const { collapsedSize = 0, collapsible, panelSize } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => `Panel size not found for panel \"${panelData.id}\"`);\n      return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;\n    },\n    getLayout() {\n      return getPanelLayout(prop(\"panels\"));\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        \"data-orientation\": prop(\"orientation\"),\n        id: getRootId(scope),\n        dir: prop(\"dir\"),\n        style: {\n          display: \"flex\",\n          flexDirection: horizontal ? \"row\" : \"column\",\n          height: \"100%\",\n          width: \"100%\",\n          overflow: \"hidden\"\n        }\n      });\n    },\n    getPanelProps(props2) {\n      const { id } = props2;\n      return normalize.element({\n        ...parts.panel.attrs,\n        \"data-orientation\": prop(\"orientation\"),\n        dir: prop(\"dir\"),\n        \"data-id\": id,\n        \"data-index\": findPanelIndex(prop(\"panels\"), id),\n        id: getPanelId(scope, id),\n        \"data-ownedby\": getRootId(scope),\n        style: getPanelStyle(id)\n      });\n    },\n    getResizeTriggerProps(props2) {\n      const { id, disabled } = props2;\n      const aria = getAriaValue(context.get(\"size\"), prop(\"panels\"), id);\n      const dragging2 = context.get(\"dragState\")?.resizeTriggerId === id;\n      const focused = dragging2 || context.get(\"keyboardState\")?.resizeTriggerId === id;\n      return normalize.element({\n        ...parts.resizeTrigger.attrs,\n        dir: prop(\"dir\"),\n        id: getResizeTriggerId(scope, id),\n        role: \"separator\",\n        \"data-id\": id,\n        \"data-ownedby\": getRootId(scope),\n        tabIndex: disabled ? void 0 : 0,\n        \"aria-valuenow\": aria.valueNow,\n        \"aria-valuemin\": aria.valueMin,\n        \"aria-valuemax\": aria.valueMax,\n        \"data-orientation\": prop(\"orientation\"),\n        \"aria-orientation\": prop(\"orientation\"),\n        \"aria-controls\": `${getPanelId(scope, aria.beforeId)} ${getPanelId(scope, aria.afterId)}`,\n        \"data-focus\": dataAttr(focused),\n        \"data-disabled\": dataAttr(disabled),\n        style: {\n          touchAction: \"none\",\n          userSelect: \"none\",\n          WebkitUserSelect: \"none\",\n          flex: \"0 0 auto\",\n          pointerEvents: dragging2 && !focused ? \"none\" : void 0,\n          cursor: horizontal ? \"col-resize\" : \"row-resize\",\n          [horizontal ? \"minHeight\" : \"minWidth\"]: \"0\"\n        },\n        onPointerDown(event) {\n          if (!isLeftClick(event)) return;\n          if (disabled) {\n            event.preventDefault();\n            return;\n          }\n          const point = getEventPoint(event);\n          send({ type: \"POINTER_DOWN\", id, point });\n          event.currentTarget.setPointerCapture(event.pointerId);\n          event.preventDefault();\n          event.stopPropagation();\n        },\n        onPointerUp(event) {\n          if (disabled) return;\n          if (event.currentTarget.hasPointerCapture(event.pointerId)) {\n            event.currentTarget.releasePointerCapture(event.pointerId);\n          }\n        },\n        onPointerOver() {\n          if (disabled) return;\n          send({ type: \"POINTER_OVER\", id });\n        },\n        onPointerLeave() {\n          if (disabled) return;\n          send({ type: \"POINTER_LEAVE\", id });\n        },\n        onBlur() {\n          if (disabled) return;\n          send({ type: \"BLUR\" });\n        },\n        onFocus() {\n          if (disabled) return;\n          send({ type: \"FOCUS\", id });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          const keyboardResizeBy = prop(\"keyboardResizeBy\");\n          let delta = 0;\n          if (event.shiftKey) {\n            delta = 10;\n          } else if (keyboardResizeBy != null) {\n            delta = keyboardResizeBy;\n          } else {\n            delta = 1;\n          }\n          const keyMap = {\n            Enter() {\n              send({ type: \"ENTER\", id });\n            },\n            ArrowUp() {\n              send({ type: \"KEYBOARD_MOVE\", id, delta: horizontal ? 0 : -delta });\n            },\n            ArrowDown() {\n              send({ type: \"KEYBOARD_MOVE\", id, delta: horizontal ? 0 : delta });\n            },\n            ArrowLeft() {\n              send({ type: \"KEYBOARD_MOVE\", id, delta: horizontal ? -delta : 0 });\n            },\n            ArrowRight() {\n              send({ type: \"KEYBOARD_MOVE\", id, delta: horizontal ? delta : 0 });\n            },\n            Home() {\n              send({ type: \"KEYBOARD_MOVE\", id, delta: -100 });\n            },\n            End() {\n              send({ type: \"KEYBOARD_MOVE\", id, delta: 100 });\n            },\n            F6() {\n              send({ type: \"FOCUS.CYCLE\", id, shiftKey: event.shiftKey });\n            }\n          };\n          const key = getEventKey(event, {\n            dir: prop(\"dir\"),\n            orientation: prop(\"orientation\")\n          });\n          const exec = keyMap[key];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n          }\n        }\n      });\n    }\n  };\n}\nfunction resizePanel({ panels, index, size }) {\n  const panel = panels[index];\n  ensure(panel, () => `Panel data not found for index ${index}`);\n  let { collapsedSize = 0, collapsible, maxSize = 100, minSize = 0 } = panel;\n  if (fuzzyCompareNumbers(size, minSize) < 0) {\n    if (collapsible) {\n      const halfwayPoint = (collapsedSize + minSize) / 2;\n      if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n        size = collapsedSize;\n      } else {\n        size = minSize;\n      }\n    } else {\n      size = minSize;\n    }\n  }\n  size = Math.min(maxSize, size);\n  size = parseFloat(size.toFixed(PRECISION));\n  return size;\n}\n\n// src/utils/resize-by-delta.ts\nfunction resizeByDelta(props2) {\n  let { delta, initialSize, panels, pivotIndices, prevSize, trigger } = props2;\n  if (fuzzyNumbersEqual(delta, 0)) {\n    return initialSize;\n  }\n  const nextSize = [...initialSize];\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n  ensure(firstPivotIndex, () => \"Invalid first pivot index\");\n  ensure(secondPivotIndex, () => \"Invalid second pivot index\");\n  let deltaApplied = 0;\n  {\n    if (trigger === \"keyboard\") {\n      {\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const panel = panels[index];\n        ensure(panel, () => `Panel data not found for index ${index}`);\n        const { collapsedSize = 0, collapsible, minSize = 0 } = panel;\n        if (collapsible) {\n          const prevSize2 = initialSize[index];\n          ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize2, collapsedSize)) {\n            const localDelta = minSize - prevSize2;\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n            }\n          }\n        }\n      }\n      {\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        const panel = panels[index];\n        ensure(panel, () => `No panel data found for index ${index}`);\n        const { collapsedSize = 0, collapsible, minSize = 0 } = panel;\n        if (collapsible) {\n          const prevSize2 = initialSize[index];\n          ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize2, minSize)) {\n            const localDelta = prevSize2 - collapsedSize;\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n            }\n          }\n        }\n      }\n    }\n  }\n  {\n    const increment = delta < 0 ? 1 : -1;\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    let maxAvailableDelta = 0;\n    while (true) {\n      const prevSize2 = initialSize[index];\n      ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n      const maxSafeSize = resizePanel({\n        panels,\n        index,\n        size: 100\n      });\n      const delta2 = maxSafeSize - prevSize2;\n      maxAvailableDelta += delta2;\n      index += increment;\n      if (index < 0 || index >= panels.length) {\n        break;\n      }\n    }\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n  }\n  {\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n    let index = pivotIndex;\n    while (index >= 0 && index < panels.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n      const prevSize2 = initialSize[index];\n      ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n      const unsafeSize = prevSize2 - deltaRemaining;\n      const safeSize = resizePanel({ panels, index, size: unsafeSize });\n      if (!fuzzyNumbersEqual(prevSize2, safeSize)) {\n        deltaApplied += prevSize2 - safeSize;\n        nextSize[index] = safeSize;\n        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), void 0, {\n          numeric: true\n        }) >= 0) {\n          break;\n        }\n      }\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n  if (fuzzySizeEqual(prevSize, nextSize)) {\n    return prevSize;\n  }\n  {\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    const prevSize2 = initialSize[pivotIndex];\n    ensure(prevSize2, () => `Previous size not found for panel index ${pivotIndex}`);\n    const unsafeSize = prevSize2 + deltaApplied;\n    const safeSize = resizePanel({ panels, index: pivotIndex, size: unsafeSize });\n    nextSize[pivotIndex] = safeSize;\n    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n      const pivotIndex2 = delta < 0 ? secondPivotIndex : firstPivotIndex;\n      let index = pivotIndex2;\n      while (index >= 0 && index < panels.length) {\n        const prevSize3 = nextSize[index];\n        ensure(prevSize3, () => `Previous size not found for panel index ${index}`);\n        const unsafeSize2 = prevSize3 + deltaRemaining;\n        const safeSize2 = resizePanel({ panels, index, size: unsafeSize2 });\n        if (!fuzzyNumbersEqual(prevSize3, safeSize2)) {\n          deltaRemaining -= safeSize2 - prevSize3;\n          nextSize[index] = safeSize2;\n        }\n        if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n          break;\n        }\n        if (delta > 0) {\n          index--;\n        } else {\n          index++;\n        }\n      }\n    }\n  }\n  const totalSize = nextSize.reduce((total, size) => size + total, 0);\n  if (!fuzzyNumbersEqual(totalSize, 100)) {\n    return prevSize;\n  }\n  return nextSize;\n}\nfunction validateSizes({ size: prevSize, panels }) {\n  const nextSize = [...prevSize];\n  const nextSizeTotalSize = nextSize.reduce((accumulated, current) => accumulated + current, 0);\n  if (nextSize.length !== panels.length) {\n    throw Error(`Invalid ${panels.length} panel size: ${nextSize.map((size) => `${size}%`).join(\", \")}`);\n  } else if (!fuzzyNumbersEqual(nextSizeTotalSize, 100) && nextSize.length > 0) {\n    for (let index = 0; index < panels.length; index++) {\n      const unsafeSize = nextSize[index];\n      ensure(unsafeSize, () => `No size data found for index ${index}`);\n      const safeSize = 100 / nextSizeTotalSize * unsafeSize;\n      nextSize[index] = safeSize;\n    }\n  }\n  let remainingSize = 0;\n  for (let index = 0; index < panels.length; index++) {\n    const unsafeSize = nextSize[index];\n    ensure(unsafeSize, () => `No size data found for index ${index}`);\n    const safeSize = resizePanel({ panels, index, size: unsafeSize });\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n      nextSize[index] = safeSize;\n    }\n  }\n  if (!fuzzyNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panels.length; index++) {\n      const prevSize2 = nextSize[index];\n      ensure(prevSize2, () => `No size data found for index ${index}`);\n      const unsafeSize = prevSize2 + remainingSize;\n      const safeSize = resizePanel({ panels, index, size: unsafeSize });\n      if (prevSize2 !== safeSize) {\n        remainingSize -= safeSize - prevSize2;\n        nextSize[index] = safeSize;\n        if (fuzzyNumbersEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n  return nextSize;\n}\n\n// src/splitter.machine.ts\nvar machine = createMachine({\n  props({ props: props2 }) {\n    ensureProps(props2, [\"panels\"]);\n    return {\n      orientation: \"horizontal\",\n      defaultSize: [],\n      dir: \"ltr\",\n      ...props2,\n      panels: sortPanels(props2.panels)\n    };\n  },\n  initialState() {\n    return \"idle\";\n  },\n  context({ prop, bindable, getContext, getRefs }) {\n    return {\n      size: bindable(() => ({\n        value: prop(\"size\"),\n        defaultValue: prop(\"defaultSize\"),\n        isEqual(a, b) {\n          return b != null && fuzzySizeEqual(a, b);\n        },\n        onChange(value) {\n          const ctx = getContext();\n          const refs = getRefs();\n          const sizesBeforeCollapse = refs.get(\"panelSizeBeforeCollapse\");\n          const expandToSizes = Object.fromEntries(sizesBeforeCollapse.entries());\n          const resizeTriggerId = ctx.get(\"dragState\")?.resizeTriggerId ?? null;\n          const layout = getPanelLayout(prop(\"panels\"));\n          prop(\"onResize\")?.({\n            size: value,\n            layout,\n            resizeTriggerId,\n            expandToSizes\n          });\n        }\n      })),\n      dragState: bindable(() => ({\n        defaultValue: null\n      })),\n      keyboardState: bindable(() => ({\n        defaultValue: null\n      }))\n    };\n  },\n  watch({ track, action, prop }) {\n    track([() => serializePanels(prop(\"panels\"))], () => {\n      action([\"syncSize\"]);\n    });\n  },\n  refs() {\n    return {\n      panelSizeBeforeCollapse: /* @__PURE__ */ new Map(),\n      prevDelta: 0,\n      panelIdToLastNotifiedSizeMap: /* @__PURE__ */ new Map()\n    };\n  },\n  computed: {\n    horizontal({ prop }) {\n      return prop(\"orientation\") === \"horizontal\";\n    }\n  },\n  on: {\n    \"SIZE.SET\": {\n      actions: [\"setSize\"]\n    },\n    \"PANEL.COLLAPSE\": {\n      actions: [\"collapsePanel\"]\n    },\n    \"PANEL.EXPAND\": {\n      actions: [\"expandPanel\"]\n    },\n    \"PANEL.RESIZE\": {\n      actions: [\"resizePanel\"]\n    }\n  },\n  entry: [\"syncSize\"],\n  states: {\n    idle: {\n      entry: [\"clearDraggingState\", \"clearKeyboardState\"],\n      on: {\n        POINTER_OVER: {\n          target: \"hover:temp\",\n          actions: [\"setKeyboardState\"]\n        },\n        FOCUS: {\n          target: \"focused\",\n          actions: [\"setKeyboardState\"]\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        }\n      }\n    },\n    \"hover:temp\": {\n      effects: [\"waitForHoverDelay\"],\n      on: {\n        HOVER_DELAY: {\n          target: \"hover\"\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        POINTER_LEAVE: {\n          target: \"idle\"\n        }\n      }\n    },\n    hover: {\n      tags: [\"focus\"],\n      on: {\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        POINTER_LEAVE: {\n          target: \"idle\"\n        }\n      }\n    },\n    focused: {\n      tags: [\"focus\"],\n      on: {\n        BLUR: {\n          target: \"idle\"\n        },\n        ENTER: {\n          actions: [\"collapseOrExpandPanel\"]\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        KEYBOARD_MOVE: {\n          actions: [\"invokeOnResizeStart\", \"setKeyboardValue\", \"invokeOnResizeEnd\"]\n        },\n        \"FOCUS.CYCLE\": {\n          actions: [\"focusNextResizeTrigger\"]\n        }\n      }\n    },\n    dragging: {\n      tags: [\"focus\"],\n      effects: [\"trackPointerMove\"],\n      entry: [\"invokeOnResizeStart\"],\n      on: {\n        POINTER_MOVE: {\n          actions: [\"setPointerValue\", \"setGlobalCursor\"]\n        },\n        POINTER_UP: {\n          target: \"idle\",\n          actions: [\"invokeOnResizeEnd\", \"clearGlobalCursor\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    effects: {\n      waitForHoverDelay: ({ send }) => {\n        return setRafTimeout(() => {\n          send({ type: \"HOVER_DELAY\" });\n        }, 250);\n      },\n      trackPointerMove: ({ scope, send }) => {\n        const doc = scope.getDoc();\n        return trackPointerMove(doc, {\n          onPointerMove(info) {\n            send({ type: \"POINTER_MOVE\", point: info.point });\n          },\n          onPointerUp() {\n            send({ type: \"POINTER_UP\" });\n          }\n        });\n      }\n    },\n    actions: {\n      setSize(params) {\n        const { context, event, prop } = params;\n        const unsafeSize = event.size;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const safeSize = validateSizes({\n          size: unsafeSize,\n          panels\n        });\n        if (!isEqual(prevSize, safeSize)) {\n          setSize(params, safeSize);\n        }\n      },\n      syncSize({ context, prop }) {\n        const panels = prop(\"panels\");\n        let prevSize = context.get(\"size\");\n        let unsafeSize = null;\n        if (prevSize.length === 0) {\n          unsafeSize = getUnsafeDefaultSize({\n            panels,\n            size: context.initial(\"size\")\n          });\n        }\n        const nextSize = validateSizes({\n          size: unsafeSize ?? prevSize,\n          panels\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          context.set(\"size\", nextSize);\n        }\n      },\n      setDraggingState({ context, event, prop, scope }) {\n        const orientation = prop(\"orientation\");\n        const size = context.get(\"size\");\n        const resizeTriggerId = event.id;\n        const panelGroupEl = getRootEl(scope);\n        if (!panelGroupEl) return;\n        const handleElement = getResizeTriggerEl(scope, resizeTriggerId);\n        ensure(handleElement, () => `Drag handle element not found for id \"${resizeTriggerId}\"`);\n        const initialCursorPosition = orientation === \"horizontal\" ? event.point.x : event.point.y;\n        context.set(\"dragState\", {\n          resizeTriggerId: event.id,\n          resizeTriggerRect: handleElement.getBoundingClientRect(),\n          initialCursorPosition,\n          initialSize: size\n        });\n      },\n      clearDraggingState({ context }) {\n        context.set(\"dragState\", null);\n      },\n      setKeyboardState({ context, event }) {\n        context.set(\"keyboardState\", {\n          resizeTriggerId: event.id\n        });\n      },\n      clearKeyboardState({ context }) {\n        context.set(\"keyboardState\", null);\n      },\n      collapsePanel(params) {\n        const { context, prop, event, refs } = params;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const panel = panels.find((panel2) => panel2.id === event.id);\n        ensure(panel, () => `Panel data not found for id \"${event.id}\"`);\n        if (panel.collapsible) {\n          const { collapsedSize = 0, panelSize, pivotIndices } = panelDataHelper(panels, panel, prevSize);\n          ensure(panelSize, () => `Panel size not found for panel \"${panel.id}\"`);\n          if (!fuzzyNumbersEqual(panelSize, collapsedSize)) {\n            refs.get(\"panelSizeBeforeCollapse\").set(panel.id, panelSize);\n            const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n            const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;\n            const nextSize = resizeByDelta({\n              delta,\n              initialSize: prevSize,\n              panels,\n              pivotIndices,\n              prevSize,\n              trigger: \"imperative-api\"\n            });\n            if (!isEqual(prevSize, nextSize)) {\n              setSize(params, nextSize);\n            }\n          }\n        }\n      },\n      expandPanel(params) {\n        const { context, prop, event, refs } = params;\n        const panels = prop(\"panels\");\n        const prevSize = context.get(\"size\");\n        const panel = panels.find((panel2) => panel2.id === event.id);\n        ensure(panel, () => `Panel data not found for id \"${event.id}\"`);\n        if (panel.collapsible) {\n          const {\n            collapsedSize = 0,\n            panelSize = 0,\n            minSize: minSizeFromProps = 0,\n            pivotIndices\n          } = panelDataHelper(panels, panel, prevSize);\n          const minSize = event.minSize ?? minSizeFromProps;\n          if (fuzzyNumbersEqual(panelSize, collapsedSize)) {\n            const prevPanelSize = refs.get(\"panelSizeBeforeCollapse\").get(panel.id);\n            const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;\n            const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n            const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;\n            const nextSize = resizeByDelta({\n              delta,\n              initialSize: prevSize,\n              panels,\n              pivotIndices,\n              prevSize,\n              trigger: \"imperative-api\"\n            });\n            if (!isEqual(prevSize, nextSize)) {\n              setSize(params, nextSize);\n            }\n          }\n        }\n      },\n      resizePanel(params) {\n        const { context, prop, event } = params;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const panel = getPanelById(panels, event.id);\n        const unsafePanelSize = event.size;\n        const { panelSize, pivotIndices } = panelDataHelper(panels, panel, prevSize);\n        ensure(panelSize, () => `Panel size not found for panel \"${panel.id}\"`);\n        const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n        const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;\n        const nextSize = resizeByDelta({\n          delta,\n          initialSize: prevSize,\n          panels,\n          pivotIndices,\n          prevSize,\n          trigger: \"imperative-api\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      setPointerValue(params) {\n        const { context, event, prop, scope } = params;\n        const dragState = context.get(\"dragState\");\n        if (!dragState) return;\n        const { resizeTriggerId, initialSize, initialCursorPosition } = dragState;\n        const panels = prop(\"panels\");\n        const panelGroupElement = getRootEl(scope);\n        ensure(panelGroupElement, () => `Panel group element not found`);\n        const pivotIndices = resizeTriggerId.split(\":\").map((id) => panels.findIndex((panel) => panel.id === id));\n        const horizontal = prop(\"orientation\") === \"horizontal\";\n        const cursorPosition = horizontal ? event.point.x : event.point.y;\n        const groupRect = panelGroupElement.getBoundingClientRect();\n        const groupSizeInPixels = horizontal ? groupRect.width : groupRect.height;\n        const offsetPixels = cursorPosition - initialCursorPosition;\n        const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\n        const prevSize = context.get(\"size\");\n        const nextSize = resizeByDelta({\n          delta: offsetPercentage,\n          initialSize: initialSize ?? prevSize,\n          panels,\n          pivotIndices,\n          prevSize,\n          trigger: \"mouse-or-touch\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      setKeyboardValue(params) {\n        const { context, event, prop } = params;\n        const panelDataArray = prop(\"panels\");\n        const resizeTriggerId = event.id;\n        const delta = event.delta;\n        const pivotIndices = resizeTriggerId.split(\":\").map((id) => panelDataArray.findIndex((panelData) => panelData.id === id));\n        const prevSize = context.get(\"size\");\n        const nextSize = resizeByDelta({\n          delta,\n          initialSize: prevSize,\n          panels: panelDataArray,\n          pivotIndices,\n          prevSize,\n          trigger: \"keyboard\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      invokeOnResizeEnd({ context, prop }) {\n        queueMicrotask(() => {\n          const dragState = context.get(\"dragState\");\n          prop(\"onResizeEnd\")?.({\n            size: context.get(\"size\"),\n            resizeTriggerId: dragState?.resizeTriggerId ?? null\n          });\n        });\n      },\n      invokeOnResizeStart({ prop }) {\n        queueMicrotask(() => {\n          prop(\"onResizeStart\")?.();\n        });\n      },\n      collapseOrExpandPanel(params) {\n        const { context, prop } = params;\n        const panelDataArray = prop(\"panels\");\n        const sizes = context.get(\"size\");\n        const resizeTriggerId = context.get(\"keyboardState\")?.resizeTriggerId;\n        const [idBefore, idAfter] = resizeTriggerId?.split(\":\") ?? [];\n        const index = panelDataArray.findIndex((panelData2) => panelData2.id === idBefore);\n        if (index === -1) return;\n        const panelData = panelDataArray[index];\n        ensure(panelData, () => `No panel data found for index ${index}`);\n        const size = sizes[index];\n        const { collapsedSize = 0, collapsible, minSize = 0 } = panelData;\n        if (size != null && collapsible) {\n          const pivotIndices = [idBefore, idAfter].map(\n            (id) => panelDataArray.findIndex((panelData2) => panelData2.id === id)\n          );\n          const nextSize = resizeByDelta({\n            delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\n            initialSize: context.initial(\"size\"),\n            panels: panelDataArray,\n            pivotIndices,\n            prevSize: sizes,\n            trigger: \"keyboard\"\n          });\n          if (!isEqual(sizes, nextSize)) {\n            setSize(params, nextSize);\n          }\n        }\n      },\n      setGlobalCursor({ context, scope, prop }) {\n        const dragState = context.get(\"dragState\");\n        if (!dragState) return;\n        const panels = prop(\"panels\");\n        const horizontal = prop(\"orientation\") === \"horizontal\";\n        const [idBefore] = dragState.resizeTriggerId.split(\":\");\n        const indexBefore = panels.findIndex((panel2) => panel2.id === idBefore);\n        const panel = panels[indexBefore];\n        const size = context.get(\"size\");\n        const aria = getAriaValue(size, panels, dragState.resizeTriggerId);\n        const isAtMin = fuzzyNumbersEqual(aria.valueNow, aria.valueMin) || fuzzyNumbersEqual(aria.valueNow, panel.collapsedSize);\n        const isAtMax = fuzzyNumbersEqual(aria.valueNow, aria.valueMax);\n        const cursorState = { isAtMin, isAtMax };\n        setupGlobalCursor(scope, cursorState, horizontal, prop(\"nonce\"));\n      },\n      clearGlobalCursor({ scope }) {\n        removeGlobalCursor(scope);\n      },\n      focusNextResizeTrigger({ event, scope }) {\n        const resizeTriggers = getResizeTriggerEls(scope);\n        const index = resizeTriggers.findIndex((el) => el.dataset.id === event.id);\n        const handleEl = event.shiftKey ? prev(resizeTriggers, index) : next(resizeTriggers, index);\n        handleEl?.focus();\n      }\n    }\n  }\n});\nfunction setSize(params, sizes) {\n  const { refs, prop, context } = params;\n  const panelsArray = prop(\"panels\");\n  const onCollapse = prop(\"onCollapse\");\n  const onExpand = prop(\"onExpand\");\n  const panelIdToLastNotifiedSizeMap = refs.get(\"panelIdToLastNotifiedSizeMap\");\n  context.set(\"size\", sizes);\n  sizes.forEach((size, index) => {\n    const panelData = panelsArray[index];\n    ensure(panelData, () => `Panel data not found for index ${index}`);\n    const { collapsedSize = 0, collapsible, id: panelId } = panelData;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap.get(panelId);\n    if (lastNotifiedSize == null || size !== lastNotifiedSize) {\n      panelIdToLastNotifiedSizeMap.set(panelId, size);\n      if (collapsible && (onCollapse || onExpand)) {\n        if ((lastNotifiedSize == null || fuzzyNumbersEqual(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual(size, collapsedSize)) {\n          onExpand?.({ panelId, size });\n        }\n        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual(size, collapsedSize)) {\n          onCollapse?.({ panelId, size });\n        }\n      }\n    }\n  });\n}\nvar props = createProps()([\n  \"dir\",\n  \"getRootNode\",\n  \"id\",\n  \"ids\",\n  \"onResize\",\n  \"onResizeStart\",\n  \"onResizeEnd\",\n  \"onCollapse\",\n  \"onExpand\",\n  \"orientation\",\n  \"size\",\n  \"defaultSize\",\n  \"panels\",\n  \"keyboardResizeBy\",\n  \"nonce\"\n]);\nvar splitProps = createSplitProps(props);\nvar panelProps = createProps()([\"id\"]);\nvar splitPanelProps = createSplitProps(panelProps);\nvar resizeTriggerProps = createProps()([\"disabled\", \"id\"]);\nvar splitResizeTriggerProps = createSplitProps(resizeTriggerProps);\n\nexport { anatomy, connect, getPanelLayout as layout, machine, panelProps, props, resizeTriggerProps, splitPanelProps, splitProps, splitResizeTriggerProps };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}