{"ast":null,"code":"import _objectSpread from \"C:/Users/JAMES/cerebras-1/CerebrasApp/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { getDocument, getTabbables, getFocusables, isTabbable, getTabIndex, addDomEvent, getActiveElement, raf, getEventTarget, isDocument, isFocusable } from '@zag-js/dom-query';\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar activeFocusTraps = {\n  activateTrap(trapStack, trap) {\n    if (trapStack.length > 0) {\n      const activeTrap = trapStack[trapStack.length - 1];\n      if (activeTrap !== trap) {\n        activeTrap.pause();\n      }\n    }\n    const trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n  deactivateTrap(trapStack, trap) {\n    const trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n    if (trapStack.length > 0) {\n      trapStack[trapStack.length - 1].unpause();\n    }\n  }\n};\nvar sharedTrapStack = [];\nvar FocusTrap = class {\n  constructor(elements, options) {\n    var _this = this;\n    __publicField(this, \"trapStack\");\n    __publicField(this, \"config\");\n    __publicField(this, \"doc\");\n    __publicField(this, \"state\", {\n      containers: [],\n      containerGroups: [],\n      tabbableGroups: [],\n      nodeFocusedBeforeActivation: null,\n      mostRecentlyFocusedNode: null,\n      active: false,\n      paused: false,\n      delayInitialFocusTimer: void 0,\n      recentNavEvent: void 0\n    });\n    __publicField(this, \"listenerCleanups\", []);\n    __publicField(this, \"handleFocus\", event => {\n      const target = getEventTarget(event);\n      const targetContained = this.findContainerIndex(target, event) >= 0;\n      if (targetContained || isDocument(target)) {\n        if (targetContained) {\n          this.state.mostRecentlyFocusedNode = target;\n        }\n      } else {\n        event.stopImmediatePropagation();\n        let nextNode;\n        let navAcrossContainers = true;\n        if (this.state.mostRecentlyFocusedNode) {\n          if (getTabIndex(this.state.mostRecentlyFocusedNode) > 0) {\n            const mruContainerIdx = this.findContainerIndex(this.state.mostRecentlyFocusedNode);\n            const {\n              tabbableNodes\n            } = this.state.containerGroups[mruContainerIdx];\n            if (tabbableNodes.length > 0) {\n              const mruTabIdx = tabbableNodes.findIndex(node => node === this.state.mostRecentlyFocusedNode);\n              if (mruTabIdx >= 0) {\n                if (this.config.isKeyForward(this.state.recentNavEvent)) {\n                  if (mruTabIdx + 1 < tabbableNodes.length) {\n                    nextNode = tabbableNodes[mruTabIdx + 1];\n                    navAcrossContainers = false;\n                  }\n                } else {\n                  if (mruTabIdx - 1 >= 0) {\n                    nextNode = tabbableNodes[mruTabIdx - 1];\n                    navAcrossContainers = false;\n                  }\n                }\n              }\n            }\n          } else {\n            if (!this.state.containerGroups.some(g => g.tabbableNodes.some(n => getTabIndex(n) > 0))) {\n              navAcrossContainers = false;\n            }\n          }\n        } else {\n          navAcrossContainers = false;\n        }\n        if (navAcrossContainers) {\n          nextNode = this.findNextNavNode({\n            // move FROM the MRU node, not event-related node (which will be the node that is\n            //  outside the trap causing the focus escape we're trying to fix)\n            target: this.state.mostRecentlyFocusedNode,\n            isBackward: this.config.isKeyBackward(this.state.recentNavEvent)\n          });\n        }\n        if (nextNode) {\n          this.tryFocus(nextNode);\n        } else {\n          this.tryFocus(this.state.mostRecentlyFocusedNode || this.getInitialFocusNode());\n        }\n      }\n      this.state.recentNavEvent = void 0;\n    });\n    __publicField(this, \"handlePointerDown\", event => {\n      const target = getEventTarget(event);\n      if (this.findContainerIndex(target, event) >= 0) {\n        return;\n      }\n      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {\n        this.deactivate({\n          returnFocus: this.config.returnFocusOnDeactivate\n        });\n        return;\n      }\n      if (valueOrHandler(this.config.allowOutsideClick, event)) {\n        return;\n      }\n      event.preventDefault();\n    });\n    __publicField(this, \"handleClick\", event => {\n      const target = getEventTarget(event);\n      if (this.findContainerIndex(target, event) >= 0) {\n        return;\n      }\n      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {\n        return;\n      }\n      if (valueOrHandler(this.config.allowOutsideClick, event)) {\n        return;\n      }\n      event.preventDefault();\n      event.stopImmediatePropagation();\n    });\n    __publicField(this, \"handleTabKey\", event => {\n      if (this.config.isKeyForward(event) || this.config.isKeyBackward(event)) {\n        this.state.recentNavEvent = event;\n        const isBackward = this.config.isKeyBackward(event);\n        const destinationNode = this.findNextNavNode({\n          event,\n          isBackward\n        });\n        if (!destinationNode) return;\n        if (isTabEvent(event)) {\n          event.preventDefault();\n        }\n        this.tryFocus(destinationNode);\n      }\n    });\n    __publicField(this, \"handleEscapeKey\", event => {\n      if (isEscapeEvent(event) && valueOrHandler(this.config.escapeDeactivates, event) !== false) {\n        event.preventDefault();\n        this.deactivate();\n      }\n    });\n    __publicField(this, \"_mutationObserver\");\n    __publicField(this, \"setupMutationObserver\", () => {\n      const win = this.doc.defaultView || window;\n      this._mutationObserver = new win.MutationObserver(mutations => {\n        const isFocusedNodeRemoved = mutations.some(mutation => {\n          const removedNodes = Array.from(mutation.removedNodes);\n          return removedNodes.some(node => node === this.state.mostRecentlyFocusedNode);\n        });\n        if (isFocusedNodeRemoved) {\n          this.tryFocus(this.getInitialFocusNode());\n        }\n      });\n    });\n    __publicField(this, \"updateObservedNodes\", () => {\n      var _this$_mutationObserv;\n      (_this$_mutationObserv = this._mutationObserver) === null || _this$_mutationObserv === void 0 || _this$_mutationObserv.disconnect();\n      if (this.state.active && !this.state.paused) {\n        this.state.containers.map(container => {\n          var _this$_mutationObserv2;\n          (_this$_mutationObserv2 = this._mutationObserver) === null || _this$_mutationObserv2 === void 0 || _this$_mutationObserv2.observe(container, {\n            subtree: true,\n            childList: true\n          });\n        });\n      }\n    });\n    __publicField(this, \"getInitialFocusNode\", () => {\n      let node = this.getNodeForOption(\"initialFocus\", {\n        hasFallback: true\n      });\n      if (node === false) {\n        return false;\n      }\n      if (node === void 0 || node && !isFocusable(node)) {\n        const activeElement = getActiveElement(this.doc);\n        if (activeElement && this.findContainerIndex(activeElement) >= 0) {\n          node = activeElement;\n        } else {\n          const firstTabbableGroup = this.state.tabbableGroups[0];\n          const firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n          node = firstTabbableNode || this.getNodeForOption(\"fallbackFocus\");\n        }\n      } else if (node === null) {\n        node = this.getNodeForOption(\"fallbackFocus\");\n      }\n      if (!node) {\n        throw new Error(\"Your focus-trap needs to have at least one focusable element\");\n      }\n      if (!node.isConnected) {\n        node = this.getNodeForOption(\"fallbackFocus\");\n      }\n      return node;\n    });\n    __publicField(this, \"tryFocus\", node => {\n      if (node === false) return;\n      if (node === getActiveElement(this.doc)) return;\n      if (!node || !node.focus) {\n        this.tryFocus(this.getInitialFocusNode());\n        return;\n      }\n      node.focus({\n        preventScroll: !!this.config.preventScroll\n      });\n      this.state.mostRecentlyFocusedNode = node;\n      if (isSelectableInput(node)) {\n        node.select();\n      }\n    });\n    __publicField(this, \"deactivate\", deactivateOptions => {\n      if (!this.state.active) return this;\n      const options = _objectSpread({\n        onDeactivate: this.config.onDeactivate,\n        onPostDeactivate: this.config.onPostDeactivate,\n        checkCanReturnFocus: this.config.checkCanReturnFocus\n      }, deactivateOptions);\n      clearTimeout(this.state.delayInitialFocusTimer);\n      this.state.delayInitialFocusTimer = void 0;\n      this.removeListeners();\n      this.state.active = false;\n      this.state.paused = false;\n      this.updateObservedNodes();\n      activeFocusTraps.deactivateTrap(this.trapStack, this);\n      const onDeactivate = this.getOption(options, \"onDeactivate\");\n      const onPostDeactivate = this.getOption(options, \"onPostDeactivate\");\n      const checkCanReturnFocus = this.getOption(options, \"checkCanReturnFocus\");\n      const returnFocus = this.getOption(options, \"returnFocus\", \"returnFocusOnDeactivate\");\n      onDeactivate === null || onDeactivate === void 0 || onDeactivate();\n      const finishDeactivation = () => {\n        delay(() => {\n          if (returnFocus) {\n            const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);\n            this.tryFocus(returnFocusNode);\n          }\n          onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();\n        });\n      };\n      if (returnFocus && checkCanReturnFocus) {\n        const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);\n        checkCanReturnFocus(returnFocusNode).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n      finishDeactivation();\n      return this;\n    });\n    __publicField(this, \"pause\", pauseOptions => {\n      if (this.state.paused || !this.state.active) {\n        return this;\n      }\n      const onPause = this.getOption(pauseOptions, \"onPause\");\n      const onPostPause = this.getOption(pauseOptions, \"onPostPause\");\n      this.state.paused = true;\n      onPause === null || onPause === void 0 || onPause();\n      this.removeListeners();\n      this.updateObservedNodes();\n      onPostPause === null || onPostPause === void 0 || onPostPause();\n      return this;\n    });\n    __publicField(this, \"unpause\", unpauseOptions => {\n      if (!this.state.paused || !this.state.active) {\n        return this;\n      }\n      const onUnpause = this.getOption(unpauseOptions, \"onUnpause\");\n      const onPostUnpause = this.getOption(unpauseOptions, \"onPostUnpause\");\n      this.state.paused = false;\n      onUnpause === null || onUnpause === void 0 || onUnpause();\n      this.updateTabbableNodes();\n      this.addListeners();\n      this.updateObservedNodes();\n      onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();\n      return this;\n    });\n    __publicField(this, \"updateContainerElements\", containerElements => {\n      this.state.containers = Array.isArray(containerElements) ? containerElements.filter(Boolean) : [containerElements].filter(Boolean);\n      if (this.state.active) {\n        this.updateTabbableNodes();\n      }\n      this.updateObservedNodes();\n      return this;\n    });\n    __publicField(this, \"getReturnFocusNode\", previousActiveElement => {\n      const node = this.getNodeForOption(\"setReturnFocus\", {\n        params: [previousActiveElement]\n      });\n      return node ? node : node === false ? false : previousActiveElement;\n    });\n    __publicField(this, \"getOption\", (configOverrideOptions, optionName, configOptionName) => {\n      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] :\n      // @ts-expect-error\n      this.config[configOptionName || optionName];\n    });\n    __publicField(this, \"getNodeForOption\", function (optionName) {\n      let {\n        hasFallback = false,\n        params = []\n      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      let optionValue = _this.config[optionName];\n      if (typeof optionValue === \"function\") optionValue = optionValue(...params);\n      if (optionValue === true) optionValue = void 0;\n      if (!optionValue) {\n        if (optionValue === void 0 || optionValue === false) {\n          return optionValue;\n        }\n        throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n      }\n      let node = optionValue;\n      if (typeof optionValue === \"string\") {\n        try {\n          node = _this.doc.querySelector(optionValue);\n        } catch (err) {\n          throw new Error(\"`\".concat(optionName, \"` appears to be an invalid selector; error=\\\"\").concat(err.message, \"\\\"\"));\n        }\n        if (!node) {\n          if (!hasFallback) {\n            throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n          }\n        }\n      }\n      return node;\n    });\n    __publicField(this, \"findNextNavNode\", opts => {\n      const {\n        event,\n        isBackward = false\n      } = opts;\n      const target = opts.target || getEventTarget(event);\n      this.updateTabbableNodes();\n      let destinationNode = null;\n      if (this.state.tabbableGroups.length > 0) {\n        const containerIndex = this.findContainerIndex(target, event);\n        const containerGroup = containerIndex >= 0 ? this.state.containerGroups[containerIndex] : void 0;\n        if (containerIndex < 0) {\n          if (isBackward) {\n            destinationNode = this.state.tabbableGroups[this.state.tabbableGroups.length - 1].lastTabbableNode;\n          } else {\n            destinationNode = this.state.tabbableGroups[0].firstTabbableNode;\n          }\n        } else if (isBackward) {\n          let startOfGroupIndex = this.state.tabbableGroups.findIndex(_ref => {\n            let {\n              firstTabbableNode\n            } = _ref;\n            return target === firstTabbableNode;\n          });\n          if (startOfGroupIndex < 0 && ((containerGroup === null || containerGroup === void 0 ? void 0 : containerGroup.container) === target || isFocusable(target) && !isTabbable(target) && !(containerGroup !== null && containerGroup !== void 0 && containerGroup.nextTabbableNode(target, false)))) {\n            startOfGroupIndex = containerIndex;\n          }\n          if (startOfGroupIndex >= 0) {\n            const destinationGroupIndex = startOfGroupIndex === 0 ? this.state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];\n            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;\n          } else if (!isTabEvent(event)) {\n            destinationNode = containerGroup === null || containerGroup === void 0 ? void 0 : containerGroup.nextTabbableNode(target, false);\n          }\n        } else {\n          let lastOfGroupIndex = this.state.tabbableGroups.findIndex(_ref2 => {\n            let {\n              lastTabbableNode\n            } = _ref2;\n            return target === lastTabbableNode;\n          });\n          if (lastOfGroupIndex < 0 && ((containerGroup === null || containerGroup === void 0 ? void 0 : containerGroup.container) === target || isFocusable(target) && !isTabbable(target) && !(containerGroup !== null && containerGroup !== void 0 && containerGroup.nextTabbableNode(target)))) {\n            lastOfGroupIndex = containerIndex;\n          }\n          if (lastOfGroupIndex >= 0) {\n            const destinationGroupIndex = lastOfGroupIndex === this.state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];\n            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.firstTabbableNode : destinationGroup.firstDomTabbableNode;\n          } else if (!isTabEvent(event)) {\n            destinationNode = containerGroup === null || containerGroup === void 0 ? void 0 : containerGroup.nextTabbableNode(target);\n          }\n        }\n      } else {\n        destinationNode = this.getNodeForOption(\"fallbackFocus\");\n      }\n      return destinationNode;\n    });\n    this.trapStack = options.trapStack || sharedTrapStack;\n    const config = _objectSpread({\n      returnFocusOnDeactivate: true,\n      escapeDeactivates: true,\n      delayInitialFocus: true,\n      isKeyForward(e) {\n        return isTabEvent(e) && !e.shiftKey;\n      },\n      isKeyBackward(e) {\n        return isTabEvent(e) && e.shiftKey;\n      }\n    }, options);\n    this.doc = config.document || getDocument(Array.isArray(elements) ? elements[0] : elements);\n    this.config = config;\n    this.updateContainerElements(elements);\n    this.setupMutationObserver();\n  }\n  get active() {\n    return this.state.active;\n  }\n  get paused() {\n    return this.state.paused;\n  }\n  findContainerIndex(element, event) {\n    const composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === \"function\" ? event.composedPath() : void 0;\n    return this.state.containerGroups.findIndex(_ref3 => {\n      let {\n        container,\n        tabbableNodes\n      } = _ref3;\n      return container.contains(element) || (composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(node => node === element);\n    });\n  }\n  updateTabbableNodes() {\n    this.state.containerGroups = this.state.containers.map(container => {\n      const tabbableNodes = getTabbables(container);\n      const focusableNodes = getFocusables(container);\n      const firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;\n      const lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;\n      const firstDomTabbableNode = focusableNodes.find(node => isTabbable(node));\n      const lastDomTabbableNode = focusableNodes.slice().reverse().find(node => isTabbable(node));\n      const posTabIndexesFound = !!tabbableNodes.find(node => getTabIndex(node) > 0);\n      function nextTabbableNode(node) {\n        let forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        const nodeIdx = tabbableNodes.indexOf(node);\n        if (nodeIdx < 0) {\n          if (forward) {\n            return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(el => isTabbable(el));\n          }\n          return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(el => isTabbable(el));\n        }\n        return tabbableNodes[nodeIdx + (forward ? 1 : -1)];\n      }\n      return {\n        container,\n        tabbableNodes,\n        focusableNodes,\n        posTabIndexesFound,\n        firstTabbableNode,\n        lastTabbableNode,\n        firstDomTabbableNode,\n        lastDomTabbableNode,\n        nextTabbableNode\n      };\n    });\n    this.state.tabbableGroups = this.state.containerGroups.filter(group => group.tabbableNodes.length > 0);\n    if (this.state.tabbableGroups.length <= 0 && !this.getNodeForOption(\"fallbackFocus\")) {\n      throw new Error(\"Your focus-trap must have at least one container with at least one tabbable node in it at all times\");\n    }\n    if (this.state.containerGroups.find(g => g.posTabIndexesFound) && this.state.containerGroups.length > 1) {\n      throw new Error(\"At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.\");\n    }\n  }\n  addListeners() {\n    if (!this.state.active) return;\n    activeFocusTraps.activateTrap(this.trapStack, this);\n    this.state.delayInitialFocusTimer = this.config.delayInitialFocus ? delay(() => {\n      this.tryFocus(this.getInitialFocusNode());\n    }) : this.tryFocus(this.getInitialFocusNode());\n    this.listenerCleanups.push(addDomEvent(this.doc, \"focusin\", this.handleFocus, true), addDomEvent(this.doc, \"mousedown\", this.handlePointerDown, {\n      capture: true,\n      passive: false\n    }), addDomEvent(this.doc, \"touchstart\", this.handlePointerDown, {\n      capture: true,\n      passive: false\n    }), addDomEvent(this.doc, \"click\", this.handleClick, {\n      capture: true,\n      passive: false\n    }), addDomEvent(this.doc, \"keydown\", this.handleTabKey, {\n      capture: true,\n      passive: false\n    }), addDomEvent(this.doc, \"keydown\", this.handleEscapeKey));\n    return this;\n  }\n  removeListeners() {\n    if (!this.state.active) return;\n    this.listenerCleanups.forEach(cleanup => cleanup());\n    this.listenerCleanups = [];\n    return this;\n  }\n  activate(activateOptions) {\n    if (this.state.active) {\n      return this;\n    }\n    const onActivate = this.getOption(activateOptions, \"onActivate\");\n    const onPostActivate = this.getOption(activateOptions, \"onPostActivate\");\n    const checkCanFocusTrap = this.getOption(activateOptions, \"checkCanFocusTrap\");\n    if (!checkCanFocusTrap) {\n      this.updateTabbableNodes();\n    }\n    this.state.active = true;\n    this.state.paused = false;\n    this.state.nodeFocusedBeforeActivation = getActiveElement(this.doc);\n    onActivate === null || onActivate === void 0 || onActivate();\n    const finishActivation = () => {\n      if (checkCanFocusTrap) {\n        this.updateTabbableNodes();\n      }\n      this.addListeners();\n      this.updateObservedNodes();\n      onPostActivate === null || onPostActivate === void 0 || onPostActivate();\n    };\n    if (checkCanFocusTrap) {\n      checkCanFocusTrap(this.state.containers.concat()).then(finishActivation, finishActivation);\n      return this;\n    }\n    finishActivation();\n    return this;\n  }\n};\nvar isTabEvent = event => event.key === \"Tab\";\nvar valueOrHandler = function (value) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n  return typeof value === \"function\" ? value(...params) : value;\n};\nvar isEscapeEvent = event => !event.isComposing && event.key === \"Escape\";\nvar delay = fn => setTimeout(fn, 0);\nvar isSelectableInput = node => node.localName === \"input\" && \"select\" in node && typeof node.select === \"function\";\n\n// src/index.ts\nfunction trapFocus(el) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let trap;\n  const cleanup = raf(() => {\n    const contentEl = typeof el === \"function\" ? el() : el;\n    if (!contentEl) return;\n    trap = new FocusTrap(contentEl, _objectSpread(_objectSpread({\n      escapeDeactivates: false,\n      allowOutsideClick: true,\n      preventScroll: true,\n      returnFocusOnDeactivate: true,\n      delayInitialFocus: false,\n      fallbackFocus: contentEl\n    }, options), {}, {\n      document: getDocument(contentEl)\n    }));\n    try {\n      trap.activate();\n    } catch (_unused) {}\n  });\n  return function destroy() {\n    var _trap;\n    (_trap = trap) === null || _trap === void 0 || _trap.deactivate();\n    cleanup();\n  };\n}\nexport { FocusTrap, trapFocus };","map":{"version":3,"names":["getDocument","getTabbables","getFocusables","isTabbable","getTabIndex","addDomEvent","getActiveElement","raf","getEventTarget","isDocument","isFocusable","__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","activeFocusTraps","activateTrap","trapStack","trap","length","activeTrap","pause","trapIndex","indexOf","push","splice","deactivateTrap","unpause","sharedTrapStack","FocusTrap","constructor","elements","options","_this","containers","containerGroups","tabbableGroups","nodeFocusedBeforeActivation","mostRecentlyFocusedNode","active","paused","delayInitialFocusTimer","recentNavEvent","event","target","targetContained","findContainerIndex","state","stopImmediatePropagation","nextNode","navAcrossContainers","mruContainerIdx","tabbableNodes","mruTabIdx","findIndex","node","config","isKeyForward","some","g","n","findNextNavNode","isBackward","isKeyBackward","tryFocus","getInitialFocusNode","valueOrHandler","clickOutsideDeactivates","deactivate","returnFocus","returnFocusOnDeactivate","allowOutsideClick","preventDefault","destinationNode","isTabEvent","isEscapeEvent","escapeDeactivates","win","doc","defaultView","window","_mutationObserver","MutationObserver","mutations","isFocusedNodeRemoved","mutation","removedNodes","Array","from","_this$_mutationObserv","disconnect","map","container","_this$_mutationObserv2","observe","subtree","childList","getNodeForOption","hasFallback","activeElement","firstTabbableGroup","firstTabbableNode","Error","isConnected","focus","preventScroll","isSelectableInput","select","deactivateOptions","_objectSpread","onDeactivate","onPostDeactivate","checkCanReturnFocus","clearTimeout","removeListeners","updateObservedNodes","getOption","finishDeactivation","delay","returnFocusNode","getReturnFocusNode","then","pauseOptions","onPause","onPostPause","unpauseOptions","onUnpause","onPostUnpause","updateTabbableNodes","addListeners","containerElements","isArray","filter","Boolean","previousActiveElement","params","configOverrideOptions","optionName","configOptionName","arguments","undefined","optionValue","concat","querySelector","err","message","opts","containerIndex","containerGroup","lastTabbableNode","startOfGroupIndex","_ref","nextTabbableNode","destinationGroupIndex","destinationGroup","lastDomTabbableNode","lastOfGroupIndex","_ref2","firstDomTabbableNode","delayInitialFocus","e","shiftKey","document","updateContainerElements","setupMutationObserver","element","composedPath","_ref3","contains","includes","find","focusableNodes","slice","reverse","posTabIndexesFound","forward","nodeIdx","el","group","listenerCleanups","handleFocus","handlePointerDown","capture","passive","handleClick","handleTabKey","handleEscapeKey","forEach","cleanup","activate","activateOptions","onActivate","onPostActivate","checkCanFocusTrap","finishActivation","_len","_key","isComposing","fn","setTimeout","localName","trapFocus","contentEl","fallbackFocus","_unused","destroy","_trap"],"sources":["C:/Users/JAMES/cerebras-1/CerebrasApp/frontend/node_modules/@zag-js/focus-trap/dist/index.mjs"],"sourcesContent":["import { getDocument, getTabbables, getFocusables, isTabbable, getTabIndex, addDomEvent, getActiveElement, raf, getEventTarget, isDocument, isFocusable } from '@zag-js/dom-query';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar activeFocusTraps = {\n  activateTrap(trapStack, trap) {\n    if (trapStack.length > 0) {\n      const activeTrap = trapStack[trapStack.length - 1];\n      if (activeTrap !== trap) {\n        activeTrap.pause();\n      }\n    }\n    const trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n  deactivateTrap(trapStack, trap) {\n    const trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n    if (trapStack.length > 0) {\n      trapStack[trapStack.length - 1].unpause();\n    }\n  }\n};\nvar sharedTrapStack = [];\nvar FocusTrap = class {\n  constructor(elements, options) {\n    __publicField(this, \"trapStack\");\n    __publicField(this, \"config\");\n    __publicField(this, \"doc\");\n    __publicField(this, \"state\", {\n      containers: [],\n      containerGroups: [],\n      tabbableGroups: [],\n      nodeFocusedBeforeActivation: null,\n      mostRecentlyFocusedNode: null,\n      active: false,\n      paused: false,\n      delayInitialFocusTimer: void 0,\n      recentNavEvent: void 0\n    });\n    __publicField(this, \"listenerCleanups\", []);\n    __publicField(this, \"handleFocus\", (event) => {\n      const target = getEventTarget(event);\n      const targetContained = this.findContainerIndex(target, event) >= 0;\n      if (targetContained || isDocument(target)) {\n        if (targetContained) {\n          this.state.mostRecentlyFocusedNode = target;\n        }\n      } else {\n        event.stopImmediatePropagation();\n        let nextNode;\n        let navAcrossContainers = true;\n        if (this.state.mostRecentlyFocusedNode) {\n          if (getTabIndex(this.state.mostRecentlyFocusedNode) > 0) {\n            const mruContainerIdx = this.findContainerIndex(this.state.mostRecentlyFocusedNode);\n            const { tabbableNodes } = this.state.containerGroups[mruContainerIdx];\n            if (tabbableNodes.length > 0) {\n              const mruTabIdx = tabbableNodes.findIndex((node) => node === this.state.mostRecentlyFocusedNode);\n              if (mruTabIdx >= 0) {\n                if (this.config.isKeyForward(this.state.recentNavEvent)) {\n                  if (mruTabIdx + 1 < tabbableNodes.length) {\n                    nextNode = tabbableNodes[mruTabIdx + 1];\n                    navAcrossContainers = false;\n                  }\n                } else {\n                  if (mruTabIdx - 1 >= 0) {\n                    nextNode = tabbableNodes[mruTabIdx - 1];\n                    navAcrossContainers = false;\n                  }\n                }\n              }\n            }\n          } else {\n            if (!this.state.containerGroups.some((g) => g.tabbableNodes.some((n) => getTabIndex(n) > 0))) {\n              navAcrossContainers = false;\n            }\n          }\n        } else {\n          navAcrossContainers = false;\n        }\n        if (navAcrossContainers) {\n          nextNode = this.findNextNavNode({\n            // move FROM the MRU node, not event-related node (which will be the node that is\n            //  outside the trap causing the focus escape we're trying to fix)\n            target: this.state.mostRecentlyFocusedNode,\n            isBackward: this.config.isKeyBackward(this.state.recentNavEvent)\n          });\n        }\n        if (nextNode) {\n          this.tryFocus(nextNode);\n        } else {\n          this.tryFocus(this.state.mostRecentlyFocusedNode || this.getInitialFocusNode());\n        }\n      }\n      this.state.recentNavEvent = void 0;\n    });\n    __publicField(this, \"handlePointerDown\", (event) => {\n      const target = getEventTarget(event);\n      if (this.findContainerIndex(target, event) >= 0) {\n        return;\n      }\n      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {\n        this.deactivate({ returnFocus: this.config.returnFocusOnDeactivate });\n        return;\n      }\n      if (valueOrHandler(this.config.allowOutsideClick, event)) {\n        return;\n      }\n      event.preventDefault();\n    });\n    __publicField(this, \"handleClick\", (event) => {\n      const target = getEventTarget(event);\n      if (this.findContainerIndex(target, event) >= 0) {\n        return;\n      }\n      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {\n        return;\n      }\n      if (valueOrHandler(this.config.allowOutsideClick, event)) {\n        return;\n      }\n      event.preventDefault();\n      event.stopImmediatePropagation();\n    });\n    __publicField(this, \"handleTabKey\", (event) => {\n      if (this.config.isKeyForward(event) || this.config.isKeyBackward(event)) {\n        this.state.recentNavEvent = event;\n        const isBackward = this.config.isKeyBackward(event);\n        const destinationNode = this.findNextNavNode({ event, isBackward });\n        if (!destinationNode) return;\n        if (isTabEvent(event)) {\n          event.preventDefault();\n        }\n        this.tryFocus(destinationNode);\n      }\n    });\n    __publicField(this, \"handleEscapeKey\", (event) => {\n      if (isEscapeEvent(event) && valueOrHandler(this.config.escapeDeactivates, event) !== false) {\n        event.preventDefault();\n        this.deactivate();\n      }\n    });\n    __publicField(this, \"_mutationObserver\");\n    __publicField(this, \"setupMutationObserver\", () => {\n      const win = this.doc.defaultView || window;\n      this._mutationObserver = new win.MutationObserver((mutations) => {\n        const isFocusedNodeRemoved = mutations.some((mutation) => {\n          const removedNodes = Array.from(mutation.removedNodes);\n          return removedNodes.some((node) => node === this.state.mostRecentlyFocusedNode);\n        });\n        if (isFocusedNodeRemoved) {\n          this.tryFocus(this.getInitialFocusNode());\n        }\n      });\n    });\n    __publicField(this, \"updateObservedNodes\", () => {\n      this._mutationObserver?.disconnect();\n      if (this.state.active && !this.state.paused) {\n        this.state.containers.map((container) => {\n          this._mutationObserver?.observe(container, { subtree: true, childList: true });\n        });\n      }\n    });\n    __publicField(this, \"getInitialFocusNode\", () => {\n      let node = this.getNodeForOption(\"initialFocus\", { hasFallback: true });\n      if (node === false) {\n        return false;\n      }\n      if (node === void 0 || node && !isFocusable(node)) {\n        const activeElement = getActiveElement(this.doc);\n        if (activeElement && this.findContainerIndex(activeElement) >= 0) {\n          node = activeElement;\n        } else {\n          const firstTabbableGroup = this.state.tabbableGroups[0];\n          const firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n          node = firstTabbableNode || this.getNodeForOption(\"fallbackFocus\");\n        }\n      } else if (node === null) {\n        node = this.getNodeForOption(\"fallbackFocus\");\n      }\n      if (!node) {\n        throw new Error(\"Your focus-trap needs to have at least one focusable element\");\n      }\n      if (!node.isConnected) {\n        node = this.getNodeForOption(\"fallbackFocus\");\n      }\n      return node;\n    });\n    __publicField(this, \"tryFocus\", (node) => {\n      if (node === false) return;\n      if (node === getActiveElement(this.doc)) return;\n      if (!node || !node.focus) {\n        this.tryFocus(this.getInitialFocusNode());\n        return;\n      }\n      node.focus({ preventScroll: !!this.config.preventScroll });\n      this.state.mostRecentlyFocusedNode = node;\n      if (isSelectableInput(node)) {\n        node.select();\n      }\n    });\n    __publicField(this, \"deactivate\", (deactivateOptions) => {\n      if (!this.state.active) return this;\n      const options = {\n        onDeactivate: this.config.onDeactivate,\n        onPostDeactivate: this.config.onPostDeactivate,\n        checkCanReturnFocus: this.config.checkCanReturnFocus,\n        ...deactivateOptions\n      };\n      clearTimeout(this.state.delayInitialFocusTimer);\n      this.state.delayInitialFocusTimer = void 0;\n      this.removeListeners();\n      this.state.active = false;\n      this.state.paused = false;\n      this.updateObservedNodes();\n      activeFocusTraps.deactivateTrap(this.trapStack, this);\n      const onDeactivate = this.getOption(options, \"onDeactivate\");\n      const onPostDeactivate = this.getOption(options, \"onPostDeactivate\");\n      const checkCanReturnFocus = this.getOption(options, \"checkCanReturnFocus\");\n      const returnFocus = this.getOption(options, \"returnFocus\", \"returnFocusOnDeactivate\");\n      onDeactivate?.();\n      const finishDeactivation = () => {\n        delay(() => {\n          if (returnFocus) {\n            const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);\n            this.tryFocus(returnFocusNode);\n          }\n          onPostDeactivate?.();\n        });\n      };\n      if (returnFocus && checkCanReturnFocus) {\n        const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);\n        checkCanReturnFocus(returnFocusNode).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n      finishDeactivation();\n      return this;\n    });\n    __publicField(this, \"pause\", (pauseOptions) => {\n      if (this.state.paused || !this.state.active) {\n        return this;\n      }\n      const onPause = this.getOption(pauseOptions, \"onPause\");\n      const onPostPause = this.getOption(pauseOptions, \"onPostPause\");\n      this.state.paused = true;\n      onPause?.();\n      this.removeListeners();\n      this.updateObservedNodes();\n      onPostPause?.();\n      return this;\n    });\n    __publicField(this, \"unpause\", (unpauseOptions) => {\n      if (!this.state.paused || !this.state.active) {\n        return this;\n      }\n      const onUnpause = this.getOption(unpauseOptions, \"onUnpause\");\n      const onPostUnpause = this.getOption(unpauseOptions, \"onPostUnpause\");\n      this.state.paused = false;\n      onUnpause?.();\n      this.updateTabbableNodes();\n      this.addListeners();\n      this.updateObservedNodes();\n      onPostUnpause?.();\n      return this;\n    });\n    __publicField(this, \"updateContainerElements\", (containerElements) => {\n      this.state.containers = Array.isArray(containerElements) ? containerElements.filter(Boolean) : [containerElements].filter(Boolean);\n      if (this.state.active) {\n        this.updateTabbableNodes();\n      }\n      this.updateObservedNodes();\n      return this;\n    });\n    __publicField(this, \"getReturnFocusNode\", (previousActiveElement) => {\n      const node = this.getNodeForOption(\"setReturnFocus\", {\n        params: [previousActiveElement]\n      });\n      return node ? node : node === false ? false : previousActiveElement;\n    });\n    __publicField(this, \"getOption\", (configOverrideOptions, optionName, configOptionName) => {\n      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : (\n        // @ts-expect-error\n        this.config[configOptionName || optionName]\n      );\n    });\n    __publicField(this, \"getNodeForOption\", (optionName, { hasFallback = false, params = [] } = {}) => {\n      let optionValue = this.config[optionName];\n      if (typeof optionValue === \"function\") optionValue = optionValue(...params);\n      if (optionValue === true) optionValue = void 0;\n      if (!optionValue) {\n        if (optionValue === void 0 || optionValue === false) {\n          return optionValue;\n        }\n        throw new Error(`\\`${optionName}\\` was specified but was not a node, or did not return a node`);\n      }\n      let node = optionValue;\n      if (typeof optionValue === \"string\") {\n        try {\n          node = this.doc.querySelector(optionValue);\n        } catch (err) {\n          throw new Error(`\\`${optionName}\\` appears to be an invalid selector; error=\"${err.message}\"`);\n        }\n        if (!node) {\n          if (!hasFallback) {\n            throw new Error(`\\`${optionName}\\` as selector refers to no known node`);\n          }\n        }\n      }\n      return node;\n    });\n    __publicField(this, \"findNextNavNode\", (opts) => {\n      const { event, isBackward = false } = opts;\n      const target = opts.target || getEventTarget(event);\n      this.updateTabbableNodes();\n      let destinationNode = null;\n      if (this.state.tabbableGroups.length > 0) {\n        const containerIndex = this.findContainerIndex(target, event);\n        const containerGroup = containerIndex >= 0 ? this.state.containerGroups[containerIndex] : void 0;\n        if (containerIndex < 0) {\n          if (isBackward) {\n            destinationNode = this.state.tabbableGroups[this.state.tabbableGroups.length - 1].lastTabbableNode;\n          } else {\n            destinationNode = this.state.tabbableGroups[0].firstTabbableNode;\n          }\n        } else if (isBackward) {\n          let startOfGroupIndex = this.state.tabbableGroups.findIndex(\n            ({ firstTabbableNode }) => target === firstTabbableNode\n          );\n          if (startOfGroupIndex < 0 && (containerGroup?.container === target || isFocusable(target) && !isTabbable(target) && !containerGroup?.nextTabbableNode(target, false))) {\n            startOfGroupIndex = containerIndex;\n          }\n          if (startOfGroupIndex >= 0) {\n            const destinationGroupIndex = startOfGroupIndex === 0 ? this.state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];\n            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;\n          } else if (!isTabEvent(event)) {\n            destinationNode = containerGroup?.nextTabbableNode(target, false);\n          }\n        } else {\n          let lastOfGroupIndex = this.state.tabbableGroups.findIndex(\n            ({ lastTabbableNode }) => target === lastTabbableNode\n          );\n          if (lastOfGroupIndex < 0 && (containerGroup?.container === target || isFocusable(target) && !isTabbable(target) && !containerGroup?.nextTabbableNode(target))) {\n            lastOfGroupIndex = containerIndex;\n          }\n          if (lastOfGroupIndex >= 0) {\n            const destinationGroupIndex = lastOfGroupIndex === this.state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];\n            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.firstTabbableNode : destinationGroup.firstDomTabbableNode;\n          } else if (!isTabEvent(event)) {\n            destinationNode = containerGroup?.nextTabbableNode(target);\n          }\n        }\n      } else {\n        destinationNode = this.getNodeForOption(\"fallbackFocus\");\n      }\n      return destinationNode;\n    });\n    this.trapStack = options.trapStack || sharedTrapStack;\n    const config = {\n      returnFocusOnDeactivate: true,\n      escapeDeactivates: true,\n      delayInitialFocus: true,\n      isKeyForward(e) {\n        return isTabEvent(e) && !e.shiftKey;\n      },\n      isKeyBackward(e) {\n        return isTabEvent(e) && e.shiftKey;\n      },\n      ...options\n    };\n    this.doc = config.document || getDocument(Array.isArray(elements) ? elements[0] : elements);\n    this.config = config;\n    this.updateContainerElements(elements);\n    this.setupMutationObserver();\n  }\n  get active() {\n    return this.state.active;\n  }\n  get paused() {\n    return this.state.paused;\n  }\n  findContainerIndex(element, event) {\n    const composedPath = typeof event?.composedPath === \"function\" ? event.composedPath() : void 0;\n    return this.state.containerGroups.findIndex(\n      ({ container, tabbableNodes }) => container.contains(element) || composedPath?.includes(container) || tabbableNodes.find((node) => node === element)\n    );\n  }\n  updateTabbableNodes() {\n    this.state.containerGroups = this.state.containers.map((container) => {\n      const tabbableNodes = getTabbables(container);\n      const focusableNodes = getFocusables(container);\n      const firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;\n      const lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;\n      const firstDomTabbableNode = focusableNodes.find((node) => isTabbable(node));\n      const lastDomTabbableNode = focusableNodes.slice().reverse().find((node) => isTabbable(node));\n      const posTabIndexesFound = !!tabbableNodes.find((node) => getTabIndex(node) > 0);\n      function nextTabbableNode(node, forward = true) {\n        const nodeIdx = tabbableNodes.indexOf(node);\n        if (nodeIdx < 0) {\n          if (forward) {\n            return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find((el) => isTabbable(el));\n          }\n          return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find((el) => isTabbable(el));\n        }\n        return tabbableNodes[nodeIdx + (forward ? 1 : -1)];\n      }\n      return {\n        container,\n        tabbableNodes,\n        focusableNodes,\n        posTabIndexesFound,\n        firstTabbableNode,\n        lastTabbableNode,\n        firstDomTabbableNode,\n        lastDomTabbableNode,\n        nextTabbableNode\n      };\n    });\n    this.state.tabbableGroups = this.state.containerGroups.filter((group) => group.tabbableNodes.length > 0);\n    if (this.state.tabbableGroups.length <= 0 && !this.getNodeForOption(\"fallbackFocus\")) {\n      throw new Error(\n        \"Your focus-trap must have at least one container with at least one tabbable node in it at all times\"\n      );\n    }\n    if (this.state.containerGroups.find((g) => g.posTabIndexesFound) && this.state.containerGroups.length > 1) {\n      throw new Error(\n        \"At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.\"\n      );\n    }\n  }\n  addListeners() {\n    if (!this.state.active) return;\n    activeFocusTraps.activateTrap(this.trapStack, this);\n    this.state.delayInitialFocusTimer = this.config.delayInitialFocus ? delay(() => {\n      this.tryFocus(this.getInitialFocusNode());\n    }) : this.tryFocus(this.getInitialFocusNode());\n    this.listenerCleanups.push(\n      addDomEvent(this.doc, \"focusin\", this.handleFocus, true),\n      addDomEvent(this.doc, \"mousedown\", this.handlePointerDown, { capture: true, passive: false }),\n      addDomEvent(this.doc, \"touchstart\", this.handlePointerDown, { capture: true, passive: false }),\n      addDomEvent(this.doc, \"click\", this.handleClick, { capture: true, passive: false }),\n      addDomEvent(this.doc, \"keydown\", this.handleTabKey, { capture: true, passive: false }),\n      addDomEvent(this.doc, \"keydown\", this.handleEscapeKey)\n    );\n    return this;\n  }\n  removeListeners() {\n    if (!this.state.active) return;\n    this.listenerCleanups.forEach((cleanup) => cleanup());\n    this.listenerCleanups = [];\n    return this;\n  }\n  activate(activateOptions) {\n    if (this.state.active) {\n      return this;\n    }\n    const onActivate = this.getOption(activateOptions, \"onActivate\");\n    const onPostActivate = this.getOption(activateOptions, \"onPostActivate\");\n    const checkCanFocusTrap = this.getOption(activateOptions, \"checkCanFocusTrap\");\n    if (!checkCanFocusTrap) {\n      this.updateTabbableNodes();\n    }\n    this.state.active = true;\n    this.state.paused = false;\n    this.state.nodeFocusedBeforeActivation = getActiveElement(this.doc);\n    onActivate?.();\n    const finishActivation = () => {\n      if (checkCanFocusTrap) {\n        this.updateTabbableNodes();\n      }\n      this.addListeners();\n      this.updateObservedNodes();\n      onPostActivate?.();\n    };\n    if (checkCanFocusTrap) {\n      checkCanFocusTrap(this.state.containers.concat()).then(finishActivation, finishActivation);\n      return this;\n    }\n    finishActivation();\n    return this;\n  }\n};\nvar isTabEvent = (event) => event.key === \"Tab\";\nvar valueOrHandler = (value, ...params) => typeof value === \"function\" ? value(...params) : value;\nvar isEscapeEvent = (event) => !event.isComposing && event.key === \"Escape\";\nvar delay = (fn) => setTimeout(fn, 0);\nvar isSelectableInput = (node) => node.localName === \"input\" && \"select\" in node && typeof node.select === \"function\";\n\n// src/index.ts\nfunction trapFocus(el, options = {}) {\n  let trap;\n  const cleanup = raf(() => {\n    const contentEl = typeof el === \"function\" ? el() : el;\n    if (!contentEl) return;\n    trap = new FocusTrap(contentEl, {\n      escapeDeactivates: false,\n      allowOutsideClick: true,\n      preventScroll: true,\n      returnFocusOnDeactivate: true,\n      delayInitialFocus: false,\n      fallbackFocus: contentEl,\n      ...options,\n      document: getDocument(contentEl)\n    });\n    try {\n      trap.activate();\n    } catch {\n    }\n  });\n  return function destroy() {\n    trap?.deactivate();\n    cleanup();\n  };\n}\n\nexport { FocusTrap, trapFocus };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}