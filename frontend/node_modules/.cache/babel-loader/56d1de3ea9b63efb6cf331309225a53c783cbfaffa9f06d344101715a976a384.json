{"ast":null,"code":"\"use strict\";\n\nimport { esc } from './esc.js';\nconst expandTokenReferences = (str, resolve) => {\n  let expanded = \"\";\n  let index = 0;\n  let state = \"char\";\n  let tokenPath = \"\";\n  let fallback = \"\";\n  const currentStates = [];\n  while (index < str.length) {\n    const char = str[index];\n    if (char === \"{\") {\n      const endIndex = str.indexOf(\"}\", index);\n      if (endIndex === -1) {\n        break;\n      }\n      const path = str.slice(index + 1, endIndex);\n      const resolved = resolve(path);\n      expanded += resolved !== null && resolved !== void 0 ? resolved : path;\n      index = endIndex + 1;\n      continue;\n    }\n    if (state === \"token\") {\n      if (char === \",\") {\n        if (str[index] === \"\") {\n          index++;\n        }\n        state = \"fallback\";\n        currentStates.push(state);\n        const resolved = resolve(tokenPath);\n        if (resolved !== null && resolved !== void 0 && resolved.endsWith(\")\")) {\n          expanded += resolved.slice(0, -1);\n        }\n        tokenPath = \"\";\n        fallback = \"\";\n        continue;\n      }\n    }\n    if (state === \"fallback\") {\n      const nextFallback = fallback + char;\n      if (nextFallback === \", var(\") {\n        var _currentStates$pop;\n        const innerEndIndex = cssVarParser(str.slice(index + 1));\n        const endIndex = innerEndIndex + index + 1;\n        const cssVar = str.slice(index + 1, endIndex);\n        if (endIndex === -1) {\n          break;\n        }\n        expanded += \", var(\" + cssVar + \")\";\n        index = endIndex + 1;\n        state = (_currentStates$pop = currentStates.pop()) !== null && _currentStates$pop !== void 0 ? _currentStates$pop : state;\n        fallback = \"\";\n        continue;\n      }\n    }\n    if (state === \"token\" || state === \"fallback\") {\n      index++;\n      if (char === \")\") {\n        var _ref, _currentStates$pop2, _resolve;\n        state = (_ref = (_currentStates$pop2 = currentStates.pop()) !== null && _currentStates$pop2 !== void 0 ? _currentStates$pop2 : state) !== null && _ref !== void 0 ? _ref : \"char\";\n        fallback += char;\n        const resolved = tokenPath ? (_resolve = resolve(tokenPath)) !== null && _resolve !== void 0 ? _resolve : esc(tokenPath) : tokenPath;\n        if (fallback) {\n          fallback = fallback.slice(1).trim();\n          if (!fallback.startsWith(\"token(\") && fallback.endsWith(\")\")) {\n            fallback = fallback.slice(0, -1);\n          }\n          if (fallback.includes(\"token(\")) {\n            const parsed = expandTokenReferences(fallback, resolve);\n            if (parsed) {\n              fallback = parsed.slice(0, -1);\n            }\n          } else if (fallback) {\n            const resolvedFallback = resolve(fallback);\n            if (resolvedFallback) {\n              fallback = resolvedFallback;\n            }\n          }\n        }\n        const lastChar = expanded.at(-1);\n        if (fallback) {\n          if (lastChar !== null && lastChar !== void 0 && lastChar.trim()) {\n            expanded += resolved.slice(0, -1) + (\", \" + fallback + \")\");\n          } else {\n            expanded += fallback;\n          }\n        } else {\n          expanded += resolved || \")\";\n        }\n        tokenPath = \"\";\n        fallback = \"\";\n        state = \"char\";\n        continue;\n      }\n      if (state === \"token\") {\n        tokenPath += char;\n      }\n      if (state === \"fallback\") {\n        fallback += char;\n      }\n      continue;\n    }\n    const tokenIndex = str.indexOf(\"token(\", index);\n    if (tokenIndex !== -1) {\n      const innerTokenIndex = tokenIndex + \"token(\".length;\n      expanded += str.slice(index, tokenIndex);\n      index = innerTokenIndex;\n      state = \"token\";\n      currentStates.push(state);\n      continue;\n    }\n    expanded += char;\n    index++;\n  }\n  return expanded;\n};\nconst cssVarParser = str => {\n  let index = 0;\n  const openedParenthesises = [\"(\"];\n  while (index < str.length) {\n    const char = str[index];\n    if (char === \"(\") {\n      openedParenthesises.push(char);\n    } else if (char === \")\") {\n      openedParenthesises.pop();\n      if (openedParenthesises.length === 0) {\n        return index;\n      }\n    }\n    index++;\n  }\n  return index;\n};\nexport { expandTokenReferences };","map":{"version":3,"names":["esc","expandTokenReferences","str","resolve","expanded","index","state","tokenPath","fallback","currentStates","length","char","endIndex","indexOf","path","slice","resolved","push","endsWith","nextFallback","_currentStates$pop","innerEndIndex","cssVarParser","cssVar","pop","_ref","_currentStates$pop2","_resolve","trim","startsWith","includes","parsed","resolvedFallback","lastChar","at","tokenIndex","innerTokenIndex","openedParenthesises"],"sources":["C:/Users/JAMES/cerebras-1/CerebrasApp/frontend/node_modules/@chakra-ui/react/dist/esm/styled-system/expand-reference.js"],"sourcesContent":["\"use strict\";\nimport { esc } from './esc.js';\n\nconst expandTokenReferences = (str, resolve) => {\n  let expanded = \"\";\n  let index = 0;\n  let state = \"char\";\n  let tokenPath = \"\";\n  let fallback = \"\";\n  const currentStates = [];\n  while (index < str.length) {\n    const char = str[index];\n    if (char === \"{\") {\n      const endIndex = str.indexOf(\"}\", index);\n      if (endIndex === -1) {\n        break;\n      }\n      const path = str.slice(index + 1, endIndex);\n      const resolved = resolve(path);\n      expanded += resolved ?? path;\n      index = endIndex + 1;\n      continue;\n    }\n    if (state === \"token\") {\n      if (char === \",\") {\n        if (str[index] === \"\") {\n          index++;\n        }\n        state = \"fallback\";\n        currentStates.push(state);\n        const resolved = resolve(tokenPath);\n        if (resolved?.endsWith(\")\")) {\n          expanded += resolved.slice(0, -1);\n        }\n        tokenPath = \"\";\n        fallback = \"\";\n        continue;\n      }\n    }\n    if (state === \"fallback\") {\n      const nextFallback = fallback + char;\n      if (nextFallback === \", var(\") {\n        const innerEndIndex = cssVarParser(str.slice(index + 1));\n        const endIndex = innerEndIndex + index + 1;\n        const cssVar = str.slice(index + 1, endIndex);\n        if (endIndex === -1) {\n          break;\n        }\n        expanded += \", var(\" + cssVar + \")\";\n        index = endIndex + 1;\n        state = currentStates.pop() ?? state;\n        fallback = \"\";\n        continue;\n      }\n    }\n    if (state === \"token\" || state === \"fallback\") {\n      index++;\n      if (char === \")\") {\n        state = currentStates.pop() ?? state ?? \"char\";\n        fallback += char;\n        const resolved = tokenPath ? resolve(tokenPath) ?? esc(tokenPath) : tokenPath;\n        if (fallback) {\n          fallback = fallback.slice(1).trim();\n          if (!fallback.startsWith(\"token(\") && fallback.endsWith(\")\")) {\n            fallback = fallback.slice(0, -1);\n          }\n          if (fallback.includes(\"token(\")) {\n            const parsed = expandTokenReferences(fallback, resolve);\n            if (parsed) {\n              fallback = parsed.slice(0, -1);\n            }\n          } else if (fallback) {\n            const resolvedFallback = resolve(fallback);\n            if (resolvedFallback) {\n              fallback = resolvedFallback;\n            }\n          }\n        }\n        const lastChar = expanded.at(-1);\n        if (fallback) {\n          if (lastChar?.trim()) {\n            expanded += resolved.slice(0, -1) + (\", \" + fallback + \")\");\n          } else {\n            expanded += fallback;\n          }\n        } else {\n          expanded += resolved || \")\";\n        }\n        tokenPath = \"\";\n        fallback = \"\";\n        state = \"char\";\n        continue;\n      }\n      if (state === \"token\") {\n        tokenPath += char;\n      }\n      if (state === \"fallback\") {\n        fallback += char;\n      }\n      continue;\n    }\n    const tokenIndex = str.indexOf(\"token(\", index);\n    if (tokenIndex !== -1) {\n      const innerTokenIndex = tokenIndex + \"token(\".length;\n      expanded += str.slice(index, tokenIndex);\n      index = innerTokenIndex;\n      state = \"token\";\n      currentStates.push(state);\n      continue;\n    }\n    expanded += char;\n    index++;\n  }\n  return expanded;\n};\nconst cssVarParser = (str) => {\n  let index = 0;\n  const openedParenthesises = [\"(\"];\n  while (index < str.length) {\n    const char = str[index];\n    if (char === \"(\") {\n      openedParenthesises.push(char);\n    } else if (char === \")\") {\n      openedParenthesises.pop();\n      if (openedParenthesises.length === 0) {\n        return index;\n      }\n    }\n    index++;\n  }\n  return index;\n};\n\nexport { expandTokenReferences };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}