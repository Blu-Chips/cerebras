{"ast":null,"code":"\"use strict\";\n\nimport { isString } from '../utils/is.js';\nimport { calc } from './calc.js';\nimport { toPx } from './unit-conversion.js';\nconst addNegativeTokens = {\n  enforce: \"pre\",\n  transform(dictionary) {\n    const {\n      prefix,\n      allTokens,\n      formatCssVar,\n      formatTokenName,\n      registerToken\n    } = dictionary;\n    const tokens = allTokens.filter(_ref => {\n      let {\n        extensions\n      } = _ref;\n      return extensions.category === \"spacing\";\n    });\n    tokens.forEach(token => {\n      const originalPath = token.path.slice();\n      const originalVar = formatCssVar(originalPath, prefix);\n      if (isString(token.value) && token.value === \"0rem\") {\n        return;\n      }\n      const nextToken = structuredClone(token);\n      Object.assign(nextToken.extensions, {\n        negative: true,\n        prop: \"-\".concat(token.extensions.prop),\n        originalPath\n      });\n      nextToken.value = calc.negate(originalVar.ref);\n      const lastPath = nextToken.path[nextToken.path.length - 1];\n      if (lastPath != null) {\n        nextToken.path[nextToken.path.length - 1] = \"-\".concat(lastPath);\n      }\n      if (nextToken.path) {\n        nextToken.name = formatTokenName(nextToken.path);\n      }\n      registerToken(nextToken);\n    });\n  }\n};\nconst units = /* @__PURE__ */new Set([\"spacing\", \"sizes\", \"borderWidths\", \"fontSizes\", \"radii\"]);\nconst addPixelUnit = {\n  enforce: \"post\",\n  transform(dictionary) {\n    const tokens = dictionary.allTokens.filter(token => {\n      return units.has(token.extensions.category) && !token.extensions.negative;\n    });\n    tokens.forEach(token => {\n      Object.assign(token.extensions, {\n        pixelValue: toPx(token.value)\n      });\n    });\n  }\n};\nconst addVirtualPalette = {\n  enforce: \"post\",\n  transform(dictionary) {\n    const {\n      allTokens,\n      registerToken,\n      formatTokenName\n    } = dictionary;\n    const tokens = allTokens.filter(_ref2 => {\n      let {\n        extensions\n      } = _ref2;\n      return extensions.category === \"colors\";\n    });\n    const keys = /* @__PURE__ */new Map();\n    const colorPalettes = /* @__PURE__ */new Map();\n    tokens.forEach(token => {\n      const {\n        colorPalette\n      } = token.extensions;\n      if (!colorPalette) return;\n      colorPalette.keys.forEach(keyPath => {\n        keys.set(formatTokenName(keyPath), keyPath);\n      });\n      colorPalette.roots.forEach(colorPaletteRoot => {\n        const name = formatTokenName(colorPaletteRoot);\n        const colorPaletteList = colorPalettes.get(name) || [];\n        colorPaletteList.push(token);\n        colorPalettes.set(name, colorPaletteList);\n        if (token.extensions.default && colorPaletteRoot.length === 1) {\n          var _colorPalette$keys$;\n          const keyPath = (_colorPalette$keys$ = colorPalette.keys[0]) === null || _colorPalette$keys$ === void 0 ? void 0 : _colorPalette$keys$.filter(Boolean);\n          if (!keyPath.length) return;\n          const path = colorPaletteRoot.concat(keyPath);\n          keys.set(formatTokenName(path), []);\n        }\n      });\n    });\n    keys.forEach(segments => {\n      const path = [\"colors\", \"colorPalette\", ...segments].filter(Boolean);\n      const name = formatTokenName(path);\n      const prop = formatTokenName(path.slice(1));\n      const token = {\n        name,\n        value: name,\n        originalValue: name,\n        path,\n        extensions: {\n          condition: \"base\",\n          originalPath: path,\n          category: \"colors\",\n          prop,\n          virtual: true\n        }\n      };\n      registerToken(token, \"pre\");\n    });\n  }\n};\nconst removeEmptyTokens = {\n  enforce: \"post\",\n  transform(dictionary) {\n    dictionary.allTokens = dictionary.allTokens.filter(token => token.value !== \"\");\n  }\n};\nconst tokenMiddlewares = [addNegativeTokens, addVirtualPalette, addPixelUnit, removeEmptyTokens];\nexport { addNegativeTokens, addPixelUnit, addVirtualPalette, removeEmptyTokens, tokenMiddlewares };","map":{"version":3,"names":["isString","calc","toPx","addNegativeTokens","enforce","transform","dictionary","prefix","allTokens","formatCssVar","formatTokenName","registerToken","tokens","filter","_ref","extensions","category","forEach","token","originalPath","path","slice","originalVar","value","nextToken","structuredClone","Object","assign","negative","prop","concat","negate","ref","lastPath","length","name","units","Set","addPixelUnit","has","pixelValue","addVirtualPalette","_ref2","keys","Map","colorPalettes","colorPalette","keyPath","set","roots","colorPaletteRoot","colorPaletteList","get","push","default","_colorPalette$keys$","Boolean","segments","originalValue","condition","virtual","removeEmptyTokens","tokenMiddlewares"],"sources":["C:/Users/JAMES/cerebras-1/CerebrasApp/frontend/node_modules/@chakra-ui/react/dist/esm/styled-system/token-middleware.js"],"sourcesContent":["\"use strict\";\nimport { isString } from '../utils/is.js';\nimport { calc } from './calc.js';\nimport { toPx } from './unit-conversion.js';\n\nconst addNegativeTokens = {\n  enforce: \"pre\",\n  transform(dictionary) {\n    const { prefix, allTokens, formatCssVar, formatTokenName, registerToken } = dictionary;\n    const tokens = allTokens.filter(\n      ({ extensions }) => extensions.category === \"spacing\"\n    );\n    tokens.forEach((token) => {\n      const originalPath = token.path.slice();\n      const originalVar = formatCssVar(originalPath, prefix);\n      if (isString(token.value) && token.value === \"0rem\") {\n        return;\n      }\n      const nextToken = structuredClone(token);\n      Object.assign(nextToken.extensions, {\n        negative: true,\n        prop: `-${token.extensions.prop}`,\n        originalPath\n      });\n      nextToken.value = calc.negate(originalVar.ref);\n      const lastPath = nextToken.path[nextToken.path.length - 1];\n      if (lastPath != null) {\n        nextToken.path[nextToken.path.length - 1] = `-${lastPath}`;\n      }\n      if (nextToken.path) {\n        nextToken.name = formatTokenName(nextToken.path);\n      }\n      registerToken(nextToken);\n    });\n  }\n};\nconst units = /* @__PURE__ */ new Set([\n  \"spacing\",\n  \"sizes\",\n  \"borderWidths\",\n  \"fontSizes\",\n  \"radii\"\n]);\nconst addPixelUnit = {\n  enforce: \"post\",\n  transform(dictionary) {\n    const tokens = dictionary.allTokens.filter((token) => {\n      return units.has(token.extensions.category) && !token.extensions.negative;\n    });\n    tokens.forEach((token) => {\n      Object.assign(token.extensions, {\n        pixelValue: toPx(token.value)\n      });\n    });\n  }\n};\nconst addVirtualPalette = {\n  enforce: \"post\",\n  transform(dictionary) {\n    const { allTokens, registerToken, formatTokenName } = dictionary;\n    const tokens = allTokens.filter(\n      ({ extensions }) => extensions.category === \"colors\"\n    );\n    const keys = /* @__PURE__ */ new Map();\n    const colorPalettes = /* @__PURE__ */ new Map();\n    tokens.forEach((token) => {\n      const { colorPalette } = token.extensions;\n      if (!colorPalette) return;\n      colorPalette.keys.forEach((keyPath) => {\n        keys.set(formatTokenName(keyPath), keyPath);\n      });\n      colorPalette.roots.forEach((colorPaletteRoot) => {\n        const name = formatTokenName(colorPaletteRoot);\n        const colorPaletteList = colorPalettes.get(name) || [];\n        colorPaletteList.push(token);\n        colorPalettes.set(name, colorPaletteList);\n        if (token.extensions.default && colorPaletteRoot.length === 1) {\n          const keyPath = colorPalette.keys[0]?.filter(Boolean);\n          if (!keyPath.length) return;\n          const path = colorPaletteRoot.concat(keyPath);\n          keys.set(formatTokenName(path), []);\n        }\n      });\n    });\n    keys.forEach((segments) => {\n      const path = [\"colors\", \"colorPalette\", ...segments].filter(Boolean);\n      const name = formatTokenName(path);\n      const prop = formatTokenName(path.slice(1));\n      const token = {\n        name,\n        value: name,\n        originalValue: name,\n        path,\n        extensions: {\n          condition: \"base\",\n          originalPath: path,\n          category: \"colors\",\n          prop,\n          virtual: true\n        }\n      };\n      registerToken(token, \"pre\");\n    });\n  }\n};\nconst removeEmptyTokens = {\n  enforce: \"post\",\n  transform(dictionary) {\n    dictionary.allTokens = dictionary.allTokens.filter(\n      (token) => token.value !== \"\"\n    );\n  }\n};\nconst tokenMiddlewares = [\n  addNegativeTokens,\n  addVirtualPalette,\n  addPixelUnit,\n  removeEmptyTokens\n];\n\nexport { addNegativeTokens, addPixelUnit, addVirtualPalette, removeEmptyTokens, tokenMiddlewares };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}